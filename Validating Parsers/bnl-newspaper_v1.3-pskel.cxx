// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "bnl-newspaper_v1.3-pskel.hxx"

// ct_HIERARCHY_pskel
//

void ct_HIERARCHY_pskel::
SUPPLEMENT_parser (::ct_SUPPLEMENT_pskel& p)
{
  this->SUPPLEMENT_parser_ = &p;
}

void ct_HIERARCHY_pskel::
ISSUE_parser (::ct_ISSUE_pskel& p)
{
  this->ISSUE_parser_ = &p;
}

void ct_HIERARCHY_pskel::
parsers (::ct_SUPPLEMENT_pskel& SUPPLEMENT,
         ::ct_ISSUE_pskel& ISSUE)
{
  this->SUPPLEMENT_parser_ = &SUPPLEMENT;
  this->ISSUE_parser_ = &ISSUE;
}

ct_HIERARCHY_pskel::
ct_HIERARCHY_pskel ()
: SUPPLEMENT_parser_ (0),
  ISSUE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_ISSUE_pskel
//

void ct_ISSUE_pskel::
TITLE_SECTION_parser (::TITLE_SECTION_pskel& p)
{
  this->TITLE_SECTION_parser_ = &p;
}

void ct_ISSUE_pskel::
CONTENT_parser (::CONTENT_pskel& p)
{
  this->CONTENT_parser_ = &p;
}

void ct_ISSUE_pskel::
SUPPLEMENT_parser (::ct_SUPPLEMENT_pskel& p)
{
  this->SUPPLEMENT_parser_ = &p;
}

void ct_ISSUE_pskel::
parsers (::TITLE_SECTION_pskel& TITLE_SECTION,
         ::CONTENT_pskel& CONTENT,
         ::ct_SUPPLEMENT_pskel& SUPPLEMENT)
{
  this->TITLE_SECTION_parser_ = &TITLE_SECTION;
  this->CONTENT_parser_ = &CONTENT;
  this->SUPPLEMENT_parser_ = &SUPPLEMENT;
}

ct_ISSUE_pskel::
ct_ISSUE_pskel ()
: TITLE_SECTION_parser_ (0),
  CONTENT_parser_ (0),
  SUPPLEMENT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_SUPPLEMENT_pskel
//

void ct_SUPPLEMENT_pskel::
TITLE_SECTION_parser (::TITLE_SECTION1_pskel& p)
{
  this->TITLE_SECTION_parser_ = &p;
}

void ct_SUPPLEMENT_pskel::
CONTENT_parser (::CONTENT1_pskel& p)
{
  this->CONTENT_parser_ = &p;
}

void ct_SUPPLEMENT_pskel::
parsers (::TITLE_SECTION1_pskel& TITLE_SECTION,
         ::CONTENT1_pskel& CONTENT)
{
  this->TITLE_SECTION_parser_ = &TITLE_SECTION;
  this->CONTENT_parser_ = &CONTENT;
}

ct_SUPPLEMENT_pskel::
ct_SUPPLEMENT_pskel ()
: TITLE_SECTION_parser_ (0),
  CONTENT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_LIST_LIKE_pskel
//

void ct_LIST_LIKE_pskel::
CAPTION_parser (::ct_FINAL_pskel& p)
{
  this->CAPTION_parser_ = &p;
}

void ct_LIST_LIKE_pskel::
DATA_parser (::DATA_pskel& p)
{
  this->DATA_parser_ = &p;
}

void ct_LIST_LIKE_pskel::
TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel& p)
{
  this->TABLE_OF_CONTENTS_parser_ = &p;
}

void ct_LIST_LIKE_pskel::
LIST_parser (::ct_LIST_LIKE_pskel& p)
{
  this->LIST_parser_ = &p;
}

void ct_LIST_LIKE_pskel::
ITEM_parser (::ct_ITEM_pskel& p)
{
  this->ITEM_parser_ = &p;
}

void ct_LIST_LIKE_pskel::
parsers (::ct_FINAL_pskel& CAPTION,
         ::DATA_pskel& DATA,
         ::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
         ::ct_LIST_LIKE_pskel& LIST,
         ::ct_ITEM_pskel& ITEM)
{
  this->CAPTION_parser_ = &CAPTION;
  this->DATA_parser_ = &DATA;
  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
  this->LIST_parser_ = &LIST;
  this->ITEM_parser_ = &ITEM;
}

ct_LIST_LIKE_pskel::
ct_LIST_LIKE_pskel ()
: CAPTION_parser_ (0),
  DATA_parser_ (0),
  TABLE_OF_CONTENTS_parser_ (0),
  LIST_parser_ (0),
  ITEM_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_ITEM_pskel
//

void ct_ITEM_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void ct_ITEM_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void ct_ITEM_pskel::
PAGE_NUMBER_parser (::ct_FINAL_pskel& p)
{
  this->PAGE_NUMBER_parser_ = &p;
}

void ct_ITEM_pskel::
ITEM_CAPTION_parser (::ct_FINAL_pskel& p)
{
  this->ITEM_CAPTION_parser_ = &p;
}

void ct_ITEM_pskel::
SUBHEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->SUBHEADLINE_parser_ = &p;
}

void ct_ITEM_pskel::
OVERLINE_parser (::ct_FINAL_pskel& p)
{
  this->OVERLINE_parser_ = &p;
}

void ct_ITEM_pskel::
HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->HEADLINE_parser_ = &p;
}

void ct_ITEM_pskel::
CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_HEADLINE_parser_ = &p;
}

void ct_ITEM_pskel::
AUTHOR_parser (::ct_FINAL_pskel& p)
{
  this->AUTHOR_parser_ = &p;
}

void ct_ITEM_pskel::
ITEM_parser (::ct_ITEM_pskel& p)
{
  this->ITEM_parser_ = &p;
}

void ct_ITEM_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_FINAL_pskel& PAGE_NUMBER,
         ::ct_FINAL_pskel& ITEM_CAPTION,
         ::ct_FINAL_pskel& SUBHEADLINE,
         ::ct_FINAL_pskel& OVERLINE,
         ::ct_FINAL_pskel& HEADLINE,
         ::ct_FINAL_pskel& CONTINUATION_HEADLINE,
         ::ct_FINAL_pskel& AUTHOR,
         ::ct_ITEM_pskel& ITEM)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->PAGE_NUMBER_parser_ = &PAGE_NUMBER;
  this->ITEM_CAPTION_parser_ = &ITEM_CAPTION;
  this->SUBHEADLINE_parser_ = &SUBHEADLINE;
  this->OVERLINE_parser_ = &OVERLINE;
  this->HEADLINE_parser_ = &HEADLINE;
  this->CONTINUATION_HEADLINE_parser_ = &CONTINUATION_HEADLINE;
  this->AUTHOR_parser_ = &AUTHOR;
  this->ITEM_parser_ = &ITEM;
}

ct_ITEM_pskel::
ct_ITEM_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  PAGE_NUMBER_parser_ (0),
  ITEM_CAPTION_parser_ (0),
  SUBHEADLINE_parser_ (0),
  OVERLINE_parser_ (0),
  HEADLINE_parser_ (0),
  CONTINUATION_HEADLINE_parser_ (0),
  AUTHOR_parser_ (0),
  ITEM_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_SECTION_pskel
//

void ct_SECTION_pskel::
HEADING_parser (::ct_CHAPTER_LIKE_HEADING_pskel& p)
{
  this->HEADING_parser_ = &p;
}

void ct_SECTION_pskel::
BODY_parser (::ct_BODY_SECTION_pskel& p)
{
  this->BODY_parser_ = &p;
}

void ct_SECTION_pskel::
SECTION_parser (::ct_SECTION_pskel& p)
{
  this->SECTION_parser_ = &p;
}

void ct_SECTION_pskel::
NECROLOGY_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->NECROLOGY_parser_ = &p;
}

void ct_SECTION_pskel::
WEATHER_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->WEATHER_parser_ = &p;
}

void ct_SECTION_pskel::
SHIPPING_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->SHIPPING_parser_ = &p;
}

void ct_SECTION_pskel::
RIDAS_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->RIDAS_parser_ = &p;
}

void ct_SECTION_pskel::
LETTER_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->LETTER_parser_ = &p;
}

void ct_SECTION_pskel::
INTERVIEW_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->INTERVIEW_parser_ = &p;
}

void ct_SECTION_pskel::
IMPRINT_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->IMPRINT_parser_ = &p;
}

void ct_SECTION_pskel::
ARTICLE_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->ARTICLE_parser_ = &p;
}

void ct_SECTION_pskel::
ACKNOWLEDGEMENT_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->ACKNOWLEDGEMENT_parser_ = &p;
}

void ct_SECTION_pskel::
parsers (::ct_CHAPTER_LIKE_HEADING_pskel& HEADING,
         ::ct_BODY_SECTION_pskel& BODY,
         ::ct_SECTION_pskel& SECTION,
         ::ct_ARTICLE_LIKE_pskel& NECROLOGY,
         ::ct_ARTICLE_LIKE_pskel& WEATHER,
         ::ct_ARTICLE_LIKE_pskel& SHIPPING,
         ::ct_ARTICLE_LIKE_pskel& RIDAS,
         ::ct_ARTICLE_LIKE_pskel& LETTER,
         ::ct_ARTICLE_LIKE_pskel& INTERVIEW,
         ::ct_ARTICLE_LIKE_pskel& IMPRINT,
         ::ct_ARTICLE_LIKE_pskel& ARTICLE,
         ::ct_ARTICLE_LIKE_pskel& ACKNOWLEDGEMENT)
{
  this->HEADING_parser_ = &HEADING;
  this->BODY_parser_ = &BODY;
  this->SECTION_parser_ = &SECTION;
  this->NECROLOGY_parser_ = &NECROLOGY;
  this->WEATHER_parser_ = &WEATHER;
  this->SHIPPING_parser_ = &SHIPPING;
  this->RIDAS_parser_ = &RIDAS;
  this->LETTER_parser_ = &LETTER;
  this->INTERVIEW_parser_ = &INTERVIEW;
  this->IMPRINT_parser_ = &IMPRINT;
  this->ARTICLE_parser_ = &ARTICLE;
  this->ACKNOWLEDGEMENT_parser_ = &ACKNOWLEDGEMENT;
}

ct_SECTION_pskel::
ct_SECTION_pskel ()
: HEADING_parser_ (0),
  BODY_parser_ (0),
  SECTION_parser_ (0),
  NECROLOGY_parser_ (0),
  WEATHER_parser_ (0),
  SHIPPING_parser_ (0),
  RIDAS_parser_ (0),
  LETTER_parser_ (0),
  INTERVIEW_parser_ (0),
  IMPRINT_parser_ (0),
  ARTICLE_parser_ (0),
  ACKNOWLEDGEMENT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_CHAPTER_pskel
//

void ct_CHAPTER_pskel::
HEADING_parser (::ct_CHAPTER_HEADING_pskel& p)
{
  this->HEADING_parser_ = &p;
}

void ct_CHAPTER_pskel::
BODY_parser (::ct_BODY_CHAPTER_pskel& p)
{
  this->BODY_parser_ = &p;
}

void ct_CHAPTER_pskel::
LIST_parser (::ct_LIST_LIKE_pskel& p)
{
  this->LIST_parser_ = &p;
}

void ct_CHAPTER_pskel::
CHAPTER_parser (::ct_CHAPTER_pskel& p)
{
  this->CHAPTER_parser_ = &p;
}

void ct_CHAPTER_pskel::
parsers (::ct_CHAPTER_HEADING_pskel& HEADING,
         ::ct_BODY_CHAPTER_pskel& BODY,
         ::ct_LIST_LIKE_pskel& LIST,
         ::ct_CHAPTER_pskel& CHAPTER)
{
  this->HEADING_parser_ = &HEADING;
  this->BODY_parser_ = &BODY;
  this->LIST_parser_ = &LIST;
  this->CHAPTER_parser_ = &CHAPTER;
}

ct_CHAPTER_pskel::
ct_CHAPTER_pskel ()
: HEADING_parser_ (0),
  BODY_parser_ (0),
  LIST_parser_ (0),
  CHAPTER_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_ARTICLE_LIKE_pskel
//

void ct_ARTICLE_LIKE_pskel::
HEADING_parser (::ct_CHAPTER_LIKE_HEADING_pskel& p)
{
  this->HEADING_parser_ = &p;
}

void ct_ARTICLE_LIKE_pskel::
BODY_parser (::ct_BODY_ARTICLE_pskel& p)
{
  this->BODY_parser_ = &p;
}

void ct_ARTICLE_LIKE_pskel::
TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel& p)
{
  this->TABLE_OF_CONTENTS_parser_ = &p;
}

void ct_ARTICLE_LIKE_pskel::
LIST_parser (::ct_LIST_LIKE_pskel& p)
{
  this->LIST_parser_ = &p;
}

void ct_ARTICLE_LIKE_pskel::
CHAPTER_parser (::ct_CHAPTER_pskel& p)
{
  this->CHAPTER_parser_ = &p;
}

void ct_ARTICLE_LIKE_pskel::
parsers (::ct_CHAPTER_LIKE_HEADING_pskel& HEADING,
         ::ct_BODY_ARTICLE_pskel& BODY,
         ::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
         ::ct_LIST_LIKE_pskel& LIST,
         ::ct_CHAPTER_pskel& CHAPTER)
{
  this->HEADING_parser_ = &HEADING;
  this->BODY_parser_ = &BODY;
  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
  this->LIST_parser_ = &LIST;
  this->CHAPTER_parser_ = &CHAPTER;
}

ct_ARTICLE_LIKE_pskel::
ct_ARTICLE_LIKE_pskel ()
: HEADING_parser_ (0),
  BODY_parser_ (0),
  TABLE_OF_CONTENTS_parser_ (0),
  LIST_parser_ (0),
  CHAPTER_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_CHAPTER_LIKE_HEADING_pskel
//

void ct_CHAPTER_LIKE_HEADING_pskel::
OVERLINE_parser (::ct_FINAL_pskel& p)
{
  this->OVERLINE_parser_ = &p;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
TITLE_parser (::ct_FINAL_pskel& p)
{
  this->TITLE_parser_ = &p;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
SUBHEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->SUBHEADLINE_parser_ = &p;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
AUTHOR_parser (::ct_FINAL_pskel& p)
{
  this->AUTHOR_parser_ = &p;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
TEXT_parser (::ct_FINAL_pskel& p)
{
  this->TEXT_parser_ = &p;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
parsers (::ct_FINAL_pskel& OVERLINE,
         ::ct_FINAL_pskel& TITLE,
         ::ct_FINAL_pskel& SUBHEADLINE,
         ::ct_FINAL_pskel& AUTHOR,
         ::ct_FINAL_pskel& TEXT)
{
  this->OVERLINE_parser_ = &OVERLINE;
  this->TITLE_parser_ = &TITLE;
  this->SUBHEADLINE_parser_ = &SUBHEADLINE;
  this->AUTHOR_parser_ = &AUTHOR;
  this->TEXT_parser_ = &TEXT;
}

ct_CHAPTER_LIKE_HEADING_pskel::
ct_CHAPTER_LIKE_HEADING_pskel ()
: OVERLINE_parser_ (0),
  TITLE_parser_ (0),
  SUBHEADLINE_parser_ (0),
  AUTHOR_parser_ (0),
  TEXT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_CHAPTER_HEADING_pskel
//

void ct_CHAPTER_HEADING_pskel::
TITLE_parser (::ct_FINAL_pskel& p)
{
  this->TITLE_parser_ = &p;
}

void ct_CHAPTER_HEADING_pskel::
AUTHOR_parser (::ct_FINAL_pskel& p)
{
  this->AUTHOR_parser_ = &p;
}

void ct_CHAPTER_HEADING_pskel::
TEXT_parser (::ct_FINAL_pskel& p)
{
  this->TEXT_parser_ = &p;
}

void ct_CHAPTER_HEADING_pskel::
parsers (::ct_FINAL_pskel& TITLE,
         ::ct_FINAL_pskel& AUTHOR,
         ::ct_FINAL_pskel& TEXT)
{
  this->TITLE_parser_ = &TITLE;
  this->AUTHOR_parser_ = &AUTHOR;
  this->TEXT_parser_ = &TEXT;
}

ct_CHAPTER_HEADING_pskel::
ct_CHAPTER_HEADING_pskel ()
: TITLE_parser_ (0),
  AUTHOR_parser_ (0),
  TEXT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_ILLUSTRATION_LIKE_STRUCT_pskel
//

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
IMAGE_parser (::ct_FINAL_pskel& p)
{
  this->IMAGE_parser_ = &p;
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
CAPTION_parser (::ct_FINAL_pskel& p)
{
  this->CAPTION_parser_ = &p;
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
AUTHOR_parser (::ct_FINAL_pskel& p)
{
  this->AUTHOR_parser_ = &p;
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
parsers (::ct_FINAL_pskel& IMAGE,
         ::ct_FINAL_pskel& CAPTION,
         ::ct_FINAL_pskel& AUTHOR)
{
  this->IMAGE_parser_ = &IMAGE;
  this->CAPTION_parser_ = &CAPTION;
  this->AUTHOR_parser_ = &AUTHOR;
}

ct_ILLUSTRATION_LIKE_STRUCT_pskel::
ct_ILLUSTRATION_LIKE_STRUCT_pskel ()
: IMAGE_parser_ (0),
  CAPTION_parser_ (0),
  AUTHOR_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_TABLE_LIKE_STRUCT_pskel
//

void ct_TABLE_LIKE_STRUCT_pskel::
IMAGE_parser (::ct_FINAL_pskel& p)
{
  this->IMAGE_parser_ = &p;
}

void ct_TABLE_LIKE_STRUCT_pskel::
CAPTION_parser (::ct_FINAL_pskel& p)
{
  this->CAPTION_parser_ = &p;
}

void ct_TABLE_LIKE_STRUCT_pskel::
parsers (::ct_FINAL_pskel& IMAGE,
         ::ct_FINAL_pskel& CAPTION)
{
  this->IMAGE_parser_ = &IMAGE;
  this->CAPTION_parser_ = &CAPTION;
}

ct_TABLE_LIKE_STRUCT_pskel::
ct_TABLE_LIKE_STRUCT_pskel ()
: IMAGE_parser_ (0),
  CAPTION_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_BODY_ARTICLE_pskel
//

void ct_BODY_ARTICLE_pskel::
BODY_CONTENT_parser (::ct_BODY_CONTENT_ARTICLE_pskel& p)
{
  this->BODY_CONTENT_parser_ = &p;
}

void ct_BODY_ARTICLE_pskel::
FOOTNOTE_parser (::ct_FOOTNOTE_PARAGRAPH_pskel& p)
{
  this->FOOTNOTE_parser_ = &p;
}

void ct_BODY_ARTICLE_pskel::
ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
{
  this->ILLUSTRATION_parser_ = &p;
}

void ct_BODY_ARTICLE_pskel::
TABLE_parser (::ct_TABLE_LIKE_STRUCT_pskel& p)
{
  this->TABLE_parser_ = &p;
}

void ct_BODY_ARTICLE_pskel::
parsers (::ct_BODY_CONTENT_ARTICLE_pskel& BODY_CONTENT,
         ::ct_FOOTNOTE_PARAGRAPH_pskel& FOOTNOTE,
         ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
         ::ct_TABLE_LIKE_STRUCT_pskel& TABLE)
{
  this->BODY_CONTENT_parser_ = &BODY_CONTENT;
  this->FOOTNOTE_parser_ = &FOOTNOTE;
  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
  this->TABLE_parser_ = &TABLE;
}

ct_BODY_ARTICLE_pskel::
ct_BODY_ARTICLE_pskel ()
: BODY_CONTENT_parser_ (0),
  FOOTNOTE_parser_ (0),
  ILLUSTRATION_parser_ (0),
  TABLE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_BODY_CHAPTER_pskel
//

void ct_BODY_CHAPTER_pskel::
BODY_CONTENT_parser (::ct_BODY_CONTENT_CHAPTER_pskel& p)
{
  this->BODY_CONTENT_parser_ = &p;
}

void ct_BODY_CHAPTER_pskel::
FOOTNOTE_parser (::ct_FOOTNOTE_PARAGRAPH_pskel& p)
{
  this->FOOTNOTE_parser_ = &p;
}

void ct_BODY_CHAPTER_pskel::
ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
{
  this->ILLUSTRATION_parser_ = &p;
}

void ct_BODY_CHAPTER_pskel::
TABLE_parser (::ct_TABLE_LIKE_STRUCT_pskel& p)
{
  this->TABLE_parser_ = &p;
}

void ct_BODY_CHAPTER_pskel::
parsers (::ct_BODY_CONTENT_CHAPTER_pskel& BODY_CONTENT,
         ::ct_FOOTNOTE_PARAGRAPH_pskel& FOOTNOTE,
         ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
         ::ct_TABLE_LIKE_STRUCT_pskel& TABLE)
{
  this->BODY_CONTENT_parser_ = &BODY_CONTENT;
  this->FOOTNOTE_parser_ = &FOOTNOTE;
  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
  this->TABLE_parser_ = &TABLE;
}

ct_BODY_CHAPTER_pskel::
ct_BODY_CHAPTER_pskel ()
: BODY_CONTENT_parser_ (0),
  FOOTNOTE_parser_ (0),
  ILLUSTRATION_parser_ (0),
  TABLE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_BODY_SECTION_pskel
//

void ct_BODY_SECTION_pskel::
BODY_CONTENT_parser (::ct_BODY_CONTENT_SECTION_pskel& p)
{
  this->BODY_CONTENT_parser_ = &p;
}

void ct_BODY_SECTION_pskel::
FOOTNOTE_parser (::ct_FOOTNOTE_PARAGRAPH_pskel& p)
{
  this->FOOTNOTE_parser_ = &p;
}

void ct_BODY_SECTION_pskel::
ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
{
  this->ILLUSTRATION_parser_ = &p;
}

void ct_BODY_SECTION_pskel::
TABLE_parser (::ct_TABLE_LIKE_STRUCT_pskel& p)
{
  this->TABLE_parser_ = &p;
}

void ct_BODY_SECTION_pskel::
parsers (::ct_BODY_CONTENT_SECTION_pskel& BODY_CONTENT,
         ::ct_FOOTNOTE_PARAGRAPH_pskel& FOOTNOTE,
         ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
         ::ct_TABLE_LIKE_STRUCT_pskel& TABLE)
{
  this->BODY_CONTENT_parser_ = &BODY_CONTENT;
  this->FOOTNOTE_parser_ = &FOOTNOTE;
  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
  this->TABLE_parser_ = &TABLE;
}

ct_BODY_SECTION_pskel::
ct_BODY_SECTION_pskel ()
: BODY_CONTENT_parser_ (0),
  FOOTNOTE_parser_ (0),
  ILLUSTRATION_parser_ (0),
  TABLE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_BODY_CONTENT_ARTICLE_pskel
//

void ct_BODY_CONTENT_ARTICLE_pskel::
AUTHOR_parser (::ct_FINAL_pskel& p)
{
  this->AUTHOR_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
PARAGRAPH_parser (::ct_PARAGRAPH_pskel& p)
{
  this->PARAGRAPH_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
LINK_parser (::ct_FINAL_pskel& p)
{
  this->LINK_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
FORMULA_parser (::ct_FORMULA_pskel& p)
{
  this->FORMULA_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
CROSSHEADING_parser (::ct_FINAL_pskel& p)
{
  this->CROSSHEADING_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
CONTINUATION_LINK_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_LINK_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_HEADLINE_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
ABSTRACT_parser (::ct_FINAL_pskel& p)
{
  this->ABSTRACT_parser_ = &p;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
parsers (::ct_FINAL_pskel& AUTHOR,
         ::ct_PARAGRAPH_pskel& PARAGRAPH,
         ::ct_FINAL_pskel& LINK,
         ::ct_FORMULA_pskel& FORMULA,
         ::ct_FINAL_pskel& CROSSHEADING,
         ::ct_FINAL_pskel& CONTINUATION_LINK,
         ::ct_FINAL_pskel& CONTINUATION_HEADLINE,
         ::ct_FINAL_pskel& ABSTRACT)
{
  this->AUTHOR_parser_ = &AUTHOR;
  this->PARAGRAPH_parser_ = &PARAGRAPH;
  this->LINK_parser_ = &LINK;
  this->FORMULA_parser_ = &FORMULA;
  this->CROSSHEADING_parser_ = &CROSSHEADING;
  this->CONTINUATION_LINK_parser_ = &CONTINUATION_LINK;
  this->CONTINUATION_HEADLINE_parser_ = &CONTINUATION_HEADLINE;
  this->ABSTRACT_parser_ = &ABSTRACT;
}

ct_BODY_CONTENT_ARTICLE_pskel::
ct_BODY_CONTENT_ARTICLE_pskel ()
: AUTHOR_parser_ (0),
  PARAGRAPH_parser_ (0),
  LINK_parser_ (0),
  FORMULA_parser_ (0),
  CROSSHEADING_parser_ (0),
  CONTINUATION_LINK_parser_ (0),
  CONTINUATION_HEADLINE_parser_ (0),
  ABSTRACT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_BODY_CONTENT_CHAPTER_pskel
//

void ct_BODY_CONTENT_CHAPTER_pskel::
PARAGRAPH_parser (::ct_PARAGRAPH_pskel& p)
{
  this->PARAGRAPH_parser_ = &p;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
LINK_parser (::ct_FINAL_pskel& p)
{
  this->LINK_parser_ = &p;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
FORMULA_parser (::ct_FORMULA_pskel& p)
{
  this->FORMULA_parser_ = &p;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
CROSSHEADING_parser (::ct_FINAL_pskel& p)
{
  this->CROSSHEADING_parser_ = &p;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
CONTINUATION_LINK_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_LINK_parser_ = &p;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_HEADLINE_parser_ = &p;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
parsers (::ct_PARAGRAPH_pskel& PARAGRAPH,
         ::ct_FINAL_pskel& LINK,
         ::ct_FORMULA_pskel& FORMULA,
         ::ct_FINAL_pskel& CROSSHEADING,
         ::ct_FINAL_pskel& CONTINUATION_LINK,
         ::ct_FINAL_pskel& CONTINUATION_HEADLINE)
{
  this->PARAGRAPH_parser_ = &PARAGRAPH;
  this->LINK_parser_ = &LINK;
  this->FORMULA_parser_ = &FORMULA;
  this->CROSSHEADING_parser_ = &CROSSHEADING;
  this->CONTINUATION_LINK_parser_ = &CONTINUATION_LINK;
  this->CONTINUATION_HEADLINE_parser_ = &CONTINUATION_HEADLINE;
}

ct_BODY_CONTENT_CHAPTER_pskel::
ct_BODY_CONTENT_CHAPTER_pskel ()
: PARAGRAPH_parser_ (0),
  LINK_parser_ (0),
  FORMULA_parser_ (0),
  CROSSHEADING_parser_ (0),
  CONTINUATION_LINK_parser_ (0),
  CONTINUATION_HEADLINE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_BODY_CONTENT_SECTION_pskel
//

void ct_BODY_CONTENT_SECTION_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
PARAGRAPH_parser (::ct_PARAGRAPH_pskel& p)
{
  this->PARAGRAPH_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
MARRIAGE_parser (::ct_FINAL_pskel& p)
{
  this->MARRIAGE_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
DEATH_NOTICE_parser (::ct_FINAL_pskel& p)
{
  this->DEATH_NOTICE_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
BIRTH_parser (::ct_FINAL_pskel& p)
{
  this->BIRTH_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
ADVERTISEMENT_parser (::ct_FINAL_pskel& p)
{
  this->ADVERTISEMENT_parser_ = &p;
}

void ct_BODY_CONTENT_SECTION_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_PARAGRAPH_pskel& PARAGRAPH,
         ::ct_FINAL_pskel& MARRIAGE,
         ::ct_FINAL_pskel& DEATH_NOTICE,
         ::ct_FINAL_pskel& BIRTH,
         ::ct_FINAL_pskel& ADVERTISEMENT)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->PARAGRAPH_parser_ = &PARAGRAPH;
  this->MARRIAGE_parser_ = &MARRIAGE;
  this->DEATH_NOTICE_parser_ = &DEATH_NOTICE;
  this->BIRTH_parser_ = &BIRTH;
  this->ADVERTISEMENT_parser_ = &ADVERTISEMENT;
}

ct_BODY_CONTENT_SECTION_pskel::
ct_BODY_CONTENT_SECTION_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  PARAGRAPH_parser_ (0),
  MARRIAGE_parser_ (0),
  DEATH_NOTICE_parser_ (0),
  BIRTH_parser_ (0),
  ADVERTISEMENT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_FORMULA_pskel
//

void ct_FORMULA_pskel::
IMAGE_parser (::ct_FINAL_pskel& p)
{
  this->IMAGE_parser_ = &p;
}

void ct_FORMULA_pskel::
parsers (::ct_FINAL_pskel& IMAGE)
{
  this->IMAGE_parser_ = &IMAGE;
}

ct_FORMULA_pskel::
ct_FORMULA_pskel ()
: IMAGE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_PARAGRAPH_pskel
//

void ct_PARAGRAPH_pskel::
TEXT_parser (::ct_FINAL_pskel& p)
{
  this->TEXT_parser_ = &p;
}

void ct_PARAGRAPH_pskel::
parsers (::ct_FINAL_pskel& TEXT)
{
  this->TEXT_parser_ = &TEXT;
}

ct_PARAGRAPH_pskel::
ct_PARAGRAPH_pskel ()
: TEXT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_FOOTNOTE_PARAGRAPH_pskel
//

void ct_FOOTNOTE_PARAGRAPH_pskel::
TEXT_parser (::ct_FINAL_pskel& p)
{
  this->TEXT_parser_ = &p;
}

void ct_FOOTNOTE_PARAGRAPH_pskel::
parsers (::ct_FINAL_pskel& TEXT)
{
  this->TEXT_parser_ = &TEXT;
}

ct_FOOTNOTE_PARAGRAPH_pskel::
ct_FOOTNOTE_PARAGRAPH_pskel ()
: TEXT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_FINAL_pskel
//

void ct_FINAL_pskel::
fptr_parser (::ct_FPTR_pskel& p)
{
  this->fptr_parser_ = &p;
}

void ct_FINAL_pskel::
parsers (::ct_FPTR_pskel& fptr)
{
  this->fptr_parser_ = &fptr;
}

ct_FINAL_pskel::
ct_FINAL_pskel ()
: fptr_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_FPTR_pskel
//

void ct_FPTR_pskel::
area_parser (::xml_schema::any_type_pskel& p)
{
  this->area_parser_ = &p;
}

void ct_FPTR_pskel::
seq_parser (::ct_SEQ_pskel& p)
{
  this->seq_parser_ = &p;
}

void ct_FPTR_pskel::
par_parser (::par_pskel& p)
{
  this->par_parser_ = &p;
}

void ct_FPTR_pskel::
parsers (::xml_schema::any_type_pskel& area,
         ::ct_SEQ_pskel& seq,
         ::par_pskel& par)
{
  this->area_parser_ = &area;
  this->seq_parser_ = &seq;
  this->par_parser_ = &par;
}

ct_FPTR_pskel::
ct_FPTR_pskel ()
: area_parser_ (0),
  seq_parser_ (0),
  par_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_SEQ_pskel
//

void ct_SEQ_pskel::
area_parser (::xml_schema::any_type_pskel& p)
{
  this->area_parser_ = &p;
}

void ct_SEQ_pskel::
parsers (::xml_schema::any_type_pskel& area)
{
  this->area_parser_ = &area;
}

ct_SEQ_pskel::
ct_SEQ_pskel ()
: area_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// Newspaper_pskel
//

void Newspaper_pskel::
VOLUME_parser (::ct_HIERARCHY_pskel& p)
{
  this->VOLUME_parser_ = &p;
}

void Newspaper_pskel::
parsers (::ct_HIERARCHY_pskel& VOLUME)
{
  this->VOLUME_parser_ = &VOLUME;
}

Newspaper_pskel::
Newspaper_pskel ()
: VOLUME_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// TITLE_SECTION_pskel
//

void TITLE_SECTION_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void TITLE_SECTION_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void TITLE_SECTION_pskel::
TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel& p)
{
  this->TABLE_OF_CONTENTS_parser_ = &p;
}

void TITLE_SECTION_pskel::
PAGE_NUMBER_parser (::ct_FINAL_pskel& p)
{
  this->PAGE_NUMBER_parser_ = &p;
}

void TITLE_SECTION_pskel::
ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
{
  this->ILLUSTRATION_parser_ = &p;
}

void TITLE_SECTION_pskel::
SUBHEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->SUBHEADLINE_parser_ = &p;
}

void TITLE_SECTION_pskel::
OVERLINE_parser (::ct_FINAL_pskel& p)
{
  this->OVERLINE_parser_ = &p;
}

void TITLE_SECTION_pskel::
HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->HEADLINE_parser_ = &p;
}

void TITLE_SECTION_pskel::
MOTTO_parser (::ct_FINAL_pskel& p)
{
  this->MOTTO_parser_ = &p;
}

void TITLE_SECTION_pskel::
CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_HEADLINE_parser_ = &p;
}

void TITLE_SECTION_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
         ::ct_FINAL_pskel& PAGE_NUMBER,
         ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
         ::ct_FINAL_pskel& SUBHEADLINE,
         ::ct_FINAL_pskel& OVERLINE,
         ::ct_FINAL_pskel& HEADLINE,
         ::ct_FINAL_pskel& MOTTO,
         ::ct_FINAL_pskel& CONTINUATION_HEADLINE)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
  this->PAGE_NUMBER_parser_ = &PAGE_NUMBER;
  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
  this->SUBHEADLINE_parser_ = &SUBHEADLINE;
  this->OVERLINE_parser_ = &OVERLINE;
  this->HEADLINE_parser_ = &HEADLINE;
  this->MOTTO_parser_ = &MOTTO;
  this->CONTINUATION_HEADLINE_parser_ = &CONTINUATION_HEADLINE;
}

TITLE_SECTION_pskel::
TITLE_SECTION_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  TABLE_OF_CONTENTS_parser_ (0),
  PAGE_NUMBER_parser_ (0),
  ILLUSTRATION_parser_ (0),
  SUBHEADLINE_parser_ (0),
  OVERLINE_parser_ (0),
  HEADLINE_parser_ (0),
  MOTTO_parser_ (0),
  CONTINUATION_HEADLINE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// CONTENT_pskel
//

void CONTENT_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void CONTENT_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void CONTENT_pskel::
SECTION_parser (::ct_SECTION_pskel& p)
{
  this->SECTION_parser_ = &p;
}

void CONTENT_pskel::
PARAGRAPH_parser (::ct_PARAGRAPH_pskel& p)
{
  this->PARAGRAPH_parser_ = &p;
}

void CONTENT_pskel::
NECROLOGY_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->NECROLOGY_parser_ = &p;
}

void CONTENT_pskel::
WEATHER_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->WEATHER_parser_ = &p;
}

void CONTENT_pskel::
SHIPPING_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->SHIPPING_parser_ = &p;
}

void CONTENT_pskel::
RIDAS_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->RIDAS_parser_ = &p;
}

void CONTENT_pskel::
LETTER_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->LETTER_parser_ = &p;
}

void CONTENT_pskel::
INTERVIEW_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->INTERVIEW_parser_ = &p;
}

void CONTENT_pskel::
IMPRINT_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->IMPRINT_parser_ = &p;
}

void CONTENT_pskel::
ARTICLE_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->ARTICLE_parser_ = &p;
}

void CONTENT_pskel::
ACKNOWLEDGEMENT_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->ACKNOWLEDGEMENT_parser_ = &p;
}

void CONTENT_pskel::
MARRIAGE_parser (::ct_FINAL_pskel& p)
{
  this->MARRIAGE_parser_ = &p;
}

void CONTENT_pskel::
DEATH_NOTICE_parser (::ct_FINAL_pskel& p)
{
  this->DEATH_NOTICE_parser_ = &p;
}

void CONTENT_pskel::
BIRTH_parser (::ct_FINAL_pskel& p)
{
  this->BIRTH_parser_ = &p;
}

void CONTENT_pskel::
ADVERTISEMENT_parser (::ct_FINAL_pskel& p)
{
  this->ADVERTISEMENT_parser_ = &p;
}

void CONTENT_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_SECTION_pskel& SECTION,
         ::ct_PARAGRAPH_pskel& PARAGRAPH,
         ::ct_ARTICLE_LIKE_pskel& NECROLOGY,
         ::ct_ARTICLE_LIKE_pskel& WEATHER,
         ::ct_ARTICLE_LIKE_pskel& SHIPPING,
         ::ct_ARTICLE_LIKE_pskel& RIDAS,
         ::ct_ARTICLE_LIKE_pskel& LETTER,
         ::ct_ARTICLE_LIKE_pskel& INTERVIEW,
         ::ct_ARTICLE_LIKE_pskel& IMPRINT,
         ::ct_ARTICLE_LIKE_pskel& ARTICLE,
         ::ct_ARTICLE_LIKE_pskel& ACKNOWLEDGEMENT,
         ::ct_FINAL_pskel& MARRIAGE,
         ::ct_FINAL_pskel& DEATH_NOTICE,
         ::ct_FINAL_pskel& BIRTH,
         ::ct_FINAL_pskel& ADVERTISEMENT)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->SECTION_parser_ = &SECTION;
  this->PARAGRAPH_parser_ = &PARAGRAPH;
  this->NECROLOGY_parser_ = &NECROLOGY;
  this->WEATHER_parser_ = &WEATHER;
  this->SHIPPING_parser_ = &SHIPPING;
  this->RIDAS_parser_ = &RIDAS;
  this->LETTER_parser_ = &LETTER;
  this->INTERVIEW_parser_ = &INTERVIEW;
  this->IMPRINT_parser_ = &IMPRINT;
  this->ARTICLE_parser_ = &ARTICLE;
  this->ACKNOWLEDGEMENT_parser_ = &ACKNOWLEDGEMENT;
  this->MARRIAGE_parser_ = &MARRIAGE;
  this->DEATH_NOTICE_parser_ = &DEATH_NOTICE;
  this->BIRTH_parser_ = &BIRTH;
  this->ADVERTISEMENT_parser_ = &ADVERTISEMENT;
}

CONTENT_pskel::
CONTENT_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  SECTION_parser_ (0),
  PARAGRAPH_parser_ (0),
  NECROLOGY_parser_ (0),
  WEATHER_parser_ (0),
  SHIPPING_parser_ (0),
  RIDAS_parser_ (0),
  LETTER_parser_ (0),
  INTERVIEW_parser_ (0),
  IMPRINT_parser_ (0),
  ARTICLE_parser_ (0),
  ACKNOWLEDGEMENT_parser_ (0),
  MARRIAGE_parser_ (0),
  DEATH_NOTICE_parser_ (0),
  BIRTH_parser_ (0),
  ADVERTISEMENT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// TITLE_SECTION1_pskel
//

void TITLE_SECTION1_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void TITLE_SECTION1_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void TITLE_SECTION1_pskel::
TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel& p)
{
  this->TABLE_OF_CONTENTS_parser_ = &p;
}

void TITLE_SECTION1_pskel::
PAGE_NUMBER_parser (::ct_FINAL_pskel& p)
{
  this->PAGE_NUMBER_parser_ = &p;
}

void TITLE_SECTION1_pskel::
ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
{
  this->ILLUSTRATION_parser_ = &p;
}

void TITLE_SECTION1_pskel::
SUBHEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->SUBHEADLINE_parser_ = &p;
}

void TITLE_SECTION1_pskel::
OVERLINE_parser (::ct_FINAL_pskel& p)
{
  this->OVERLINE_parser_ = &p;
}

void TITLE_SECTION1_pskel::
HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->HEADLINE_parser_ = &p;
}

void TITLE_SECTION1_pskel::
MOTTO_parser (::ct_FINAL_pskel& p)
{
  this->MOTTO_parser_ = &p;
}

void TITLE_SECTION1_pskel::
CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel& p)
{
  this->CONTINUATION_HEADLINE_parser_ = &p;
}

void TITLE_SECTION1_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
         ::ct_FINAL_pskel& PAGE_NUMBER,
         ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
         ::ct_FINAL_pskel& SUBHEADLINE,
         ::ct_FINAL_pskel& OVERLINE,
         ::ct_FINAL_pskel& HEADLINE,
         ::ct_FINAL_pskel& MOTTO,
         ::ct_FINAL_pskel& CONTINUATION_HEADLINE)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
  this->PAGE_NUMBER_parser_ = &PAGE_NUMBER;
  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
  this->SUBHEADLINE_parser_ = &SUBHEADLINE;
  this->OVERLINE_parser_ = &OVERLINE;
  this->HEADLINE_parser_ = &HEADLINE;
  this->MOTTO_parser_ = &MOTTO;
  this->CONTINUATION_HEADLINE_parser_ = &CONTINUATION_HEADLINE;
}

TITLE_SECTION1_pskel::
TITLE_SECTION1_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  TABLE_OF_CONTENTS_parser_ (0),
  PAGE_NUMBER_parser_ (0),
  ILLUSTRATION_parser_ (0),
  SUBHEADLINE_parser_ (0),
  OVERLINE_parser_ (0),
  HEADLINE_parser_ (0),
  MOTTO_parser_ (0),
  CONTINUATION_HEADLINE_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// CONTENT1_pskel
//

void CONTENT1_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void CONTENT1_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void CONTENT1_pskel::
SECTION_parser (::ct_SECTION_pskel& p)
{
  this->SECTION_parser_ = &p;
}

void CONTENT1_pskel::
PARAGRAPH_parser (::ct_PARAGRAPH_pskel& p)
{
  this->PARAGRAPH_parser_ = &p;
}

void CONTENT1_pskel::
NECROLOGY_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->NECROLOGY_parser_ = &p;
}

void CONTENT1_pskel::
WEATHER_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->WEATHER_parser_ = &p;
}

void CONTENT1_pskel::
SHIPPING_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->SHIPPING_parser_ = &p;
}

void CONTENT1_pskel::
RIDAS_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->RIDAS_parser_ = &p;
}

void CONTENT1_pskel::
LETTER_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->LETTER_parser_ = &p;
}

void CONTENT1_pskel::
INTERVIEW_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->INTERVIEW_parser_ = &p;
}

void CONTENT1_pskel::
IMPRINT_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->IMPRINT_parser_ = &p;
}

void CONTENT1_pskel::
ARTICLE_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->ARTICLE_parser_ = &p;
}

void CONTENT1_pskel::
ACKNOWLEDGEMENT_parser (::ct_ARTICLE_LIKE_pskel& p)
{
  this->ACKNOWLEDGEMENT_parser_ = &p;
}

void CONTENT1_pskel::
MARRIAGE_parser (::ct_FINAL_pskel& p)
{
  this->MARRIAGE_parser_ = &p;
}

void CONTENT1_pskel::
DEATH_NOTICE_parser (::ct_FINAL_pskel& p)
{
  this->DEATH_NOTICE_parser_ = &p;
}

void CONTENT1_pskel::
BIRTH_parser (::ct_FINAL_pskel& p)
{
  this->BIRTH_parser_ = &p;
}

void CONTENT1_pskel::
ADVERTISEMENT_parser (::ct_FINAL_pskel& p)
{
  this->ADVERTISEMENT_parser_ = &p;
}

void CONTENT1_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_SECTION_pskel& SECTION,
         ::ct_PARAGRAPH_pskel& PARAGRAPH,
         ::ct_ARTICLE_LIKE_pskel& NECROLOGY,
         ::ct_ARTICLE_LIKE_pskel& WEATHER,
         ::ct_ARTICLE_LIKE_pskel& SHIPPING,
         ::ct_ARTICLE_LIKE_pskel& RIDAS,
         ::ct_ARTICLE_LIKE_pskel& LETTER,
         ::ct_ARTICLE_LIKE_pskel& INTERVIEW,
         ::ct_ARTICLE_LIKE_pskel& IMPRINT,
         ::ct_ARTICLE_LIKE_pskel& ARTICLE,
         ::ct_ARTICLE_LIKE_pskel& ACKNOWLEDGEMENT,
         ::ct_FINAL_pskel& MARRIAGE,
         ::ct_FINAL_pskel& DEATH_NOTICE,
         ::ct_FINAL_pskel& BIRTH,
         ::ct_FINAL_pskel& ADVERTISEMENT)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->SECTION_parser_ = &SECTION;
  this->PARAGRAPH_parser_ = &PARAGRAPH;
  this->NECROLOGY_parser_ = &NECROLOGY;
  this->WEATHER_parser_ = &WEATHER;
  this->SHIPPING_parser_ = &SHIPPING;
  this->RIDAS_parser_ = &RIDAS;
  this->LETTER_parser_ = &LETTER;
  this->INTERVIEW_parser_ = &INTERVIEW;
  this->IMPRINT_parser_ = &IMPRINT;
  this->ARTICLE_parser_ = &ARTICLE;
  this->ACKNOWLEDGEMENT_parser_ = &ACKNOWLEDGEMENT;
  this->MARRIAGE_parser_ = &MARRIAGE;
  this->DEATH_NOTICE_parser_ = &DEATH_NOTICE;
  this->BIRTH_parser_ = &BIRTH;
  this->ADVERTISEMENT_parser_ = &ADVERTISEMENT;
}

CONTENT1_pskel::
CONTENT1_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  SECTION_parser_ (0),
  PARAGRAPH_parser_ (0),
  NECROLOGY_parser_ (0),
  WEATHER_parser_ (0),
  SHIPPING_parser_ (0),
  RIDAS_parser_ (0),
  LETTER_parser_ (0),
  INTERVIEW_parser_ (0),
  IMPRINT_parser_ (0),
  ARTICLE_parser_ (0),
  ACKNOWLEDGEMENT_parser_ (0),
  MARRIAGE_parser_ (0),
  DEATH_NOTICE_parser_ (0),
  BIRTH_parser_ (0),
  ADVERTISEMENT_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// DATA_pskel
//

void DATA_pskel::
TEXTBLOCK_parser (::ct_FINAL_pskel& p)
{
  this->TEXTBLOCK_parser_ = &p;
}

void DATA_pskel::
PUBLISHING_STMT_parser (::ct_FINAL_pskel& p)
{
  this->PUBLISHING_STMT_parser_ = &p;
}

void DATA_pskel::
PAGE_NUMBER_parser (::ct_FINAL_pskel& p)
{
  this->PAGE_NUMBER_parser_ = &p;
}

void DATA_pskel::
ITEM_CAPTION_parser (::ct_FINAL_pskel& p)
{
  this->ITEM_CAPTION_parser_ = &p;
}

void DATA_pskel::
AUTHOR_parser (::ct_FINAL_pskel& p)
{
  this->AUTHOR_parser_ = &p;
}

void DATA_pskel::
parsers (::ct_FINAL_pskel& TEXTBLOCK,
         ::ct_FINAL_pskel& PUBLISHING_STMT,
         ::ct_FINAL_pskel& PAGE_NUMBER,
         ::ct_FINAL_pskel& ITEM_CAPTION,
         ::ct_FINAL_pskel& AUTHOR)
{
  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
  this->PAGE_NUMBER_parser_ = &PAGE_NUMBER;
  this->ITEM_CAPTION_parser_ = &ITEM_CAPTION;
  this->AUTHOR_parser_ = &AUTHOR;
}

DATA_pskel::
DATA_pskel ()
: TEXTBLOCK_parser_ (0),
  PUBLISHING_STMT_parser_ (0),
  PAGE_NUMBER_parser_ (0),
  ITEM_CAPTION_parser_ (0),
  AUTHOR_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// par_pskel
//

void par_pskel::
area_parser (::xml_schema::any_type_pskel& p)
{
  this->area_parser_ = &p;
}

void par_pskel::
seq_parser (::ct_SEQ_pskel& p)
{
  this->seq_parser_ = &p;
}

void par_pskel::
parsers (::xml_schema::any_type_pskel& area,
         ::ct_SEQ_pskel& seq)
{
  this->area_parser_ = &area;
  this->seq_parser_ = &seq;
}

par_pskel::
par_pskel ()
: area_parser_ (0),
  seq_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// ct_HIERARCHY_pskel
//

void ct_HIERARCHY_pskel::
SUPPLEMENT ()
{
}

void ct_HIERARCHY_pskel::
ISSUE ()
{
}

void ct_HIERARCHY_pskel::
post_ct_HIERARCHY ()
{
}

// ct_ISSUE_pskel
//

void ct_ISSUE_pskel::
TITLE_SECTION ()
{
}

void ct_ISSUE_pskel::
CONTENT ()
{
}

void ct_ISSUE_pskel::
SUPPLEMENT ()
{
}

void ct_ISSUE_pskel::
post_ct_ISSUE ()
{
}

// ct_SUPPLEMENT_pskel
//

void ct_SUPPLEMENT_pskel::
TITLE_SECTION ()
{
}

void ct_SUPPLEMENT_pskel::
CONTENT ()
{
}

void ct_SUPPLEMENT_pskel::
post_ct_SUPPLEMENT ()
{
}

// ct_LIST_LIKE_pskel
//

void ct_LIST_LIKE_pskel::
CAPTION ()
{
}

void ct_LIST_LIKE_pskel::
DATA ()
{
}

void ct_LIST_LIKE_pskel::
TABLE_OF_CONTENTS ()
{
}

void ct_LIST_LIKE_pskel::
LIST ()
{
}

void ct_LIST_LIKE_pskel::
ITEM ()
{
}

void ct_LIST_LIKE_pskel::
post_ct_LIST_LIKE ()
{
}

// ct_ITEM_pskel
//

void ct_ITEM_pskel::
TEXTBLOCK ()
{
}

void ct_ITEM_pskel::
PUBLISHING_STMT ()
{
}

void ct_ITEM_pskel::
PAGE_NUMBER ()
{
}

void ct_ITEM_pskel::
ITEM_CAPTION ()
{
}

void ct_ITEM_pskel::
SUBHEADLINE ()
{
}

void ct_ITEM_pskel::
OVERLINE ()
{
}

void ct_ITEM_pskel::
HEADLINE ()
{
}

void ct_ITEM_pskel::
CONTINUATION_HEADLINE ()
{
}

void ct_ITEM_pskel::
AUTHOR ()
{
}

void ct_ITEM_pskel::
ITEM ()
{
}

void ct_ITEM_pskel::
post_ct_ITEM ()
{
}

// ct_SECTION_pskel
//

void ct_SECTION_pskel::
HEADING ()
{
}

void ct_SECTION_pskel::
BODY ()
{
}

void ct_SECTION_pskel::
SECTION ()
{
}

void ct_SECTION_pskel::
NECROLOGY ()
{
}

void ct_SECTION_pskel::
WEATHER ()
{
}

void ct_SECTION_pskel::
SHIPPING ()
{
}

void ct_SECTION_pskel::
RIDAS ()
{
}

void ct_SECTION_pskel::
LETTER ()
{
}

void ct_SECTION_pskel::
INTERVIEW ()
{
}

void ct_SECTION_pskel::
IMPRINT ()
{
}

void ct_SECTION_pskel::
ARTICLE ()
{
}

void ct_SECTION_pskel::
ACKNOWLEDGEMENT ()
{
}

void ct_SECTION_pskel::
post_ct_SECTION ()
{
}

// ct_CHAPTER_pskel
//

void ct_CHAPTER_pskel::
HEADING ()
{
}

void ct_CHAPTER_pskel::
BODY ()
{
}

void ct_CHAPTER_pskel::
LIST ()
{
}

void ct_CHAPTER_pskel::
CHAPTER ()
{
}

void ct_CHAPTER_pskel::
post_ct_CHAPTER ()
{
}

// ct_ARTICLE_LIKE_pskel
//

void ct_ARTICLE_LIKE_pskel::
HEADING ()
{
}

void ct_ARTICLE_LIKE_pskel::
BODY ()
{
}

void ct_ARTICLE_LIKE_pskel::
TABLE_OF_CONTENTS ()
{
}

void ct_ARTICLE_LIKE_pskel::
LIST ()
{
}

void ct_ARTICLE_LIKE_pskel::
CHAPTER ()
{
}

void ct_ARTICLE_LIKE_pskel::
post_ct_ARTICLE_LIKE ()
{
}

// ct_CHAPTER_LIKE_HEADING_pskel
//

void ct_CHAPTER_LIKE_HEADING_pskel::
OVERLINE ()
{
}

void ct_CHAPTER_LIKE_HEADING_pskel::
TITLE ()
{
}

void ct_CHAPTER_LIKE_HEADING_pskel::
SUBHEADLINE ()
{
}

void ct_CHAPTER_LIKE_HEADING_pskel::
AUTHOR ()
{
}

void ct_CHAPTER_LIKE_HEADING_pskel::
TEXT ()
{
}

void ct_CHAPTER_LIKE_HEADING_pskel::
post_ct_CHAPTER_LIKE_HEADING ()
{
}

// ct_CHAPTER_HEADING_pskel
//

void ct_CHAPTER_HEADING_pskel::
TITLE ()
{
}

void ct_CHAPTER_HEADING_pskel::
AUTHOR ()
{
}

void ct_CHAPTER_HEADING_pskel::
TEXT ()
{
}

void ct_CHAPTER_HEADING_pskel::
post_ct_CHAPTER_HEADING ()
{
}

// ct_ILLUSTRATION_LIKE_STRUCT_pskel
//

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
IMAGE ()
{
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
CAPTION ()
{
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
AUTHOR ()
{
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
post_ct_ILLUSTRATION_LIKE_STRUCT ()
{
}

// ct_TABLE_LIKE_STRUCT_pskel
//

void ct_TABLE_LIKE_STRUCT_pskel::
IMAGE ()
{
}

void ct_TABLE_LIKE_STRUCT_pskel::
CAPTION ()
{
}

void ct_TABLE_LIKE_STRUCT_pskel::
post_ct_TABLE_LIKE_STRUCT ()
{
}

// ct_BODY_ARTICLE_pskel
//

void ct_BODY_ARTICLE_pskel::
BODY_CONTENT ()
{
}

void ct_BODY_ARTICLE_pskel::
FOOTNOTE ()
{
}

void ct_BODY_ARTICLE_pskel::
ILLUSTRATION ()
{
}

void ct_BODY_ARTICLE_pskel::
TABLE ()
{
}

void ct_BODY_ARTICLE_pskel::
post_ct_BODY_ARTICLE ()
{
}

// ct_BODY_CHAPTER_pskel
//

void ct_BODY_CHAPTER_pskel::
BODY_CONTENT ()
{
}

void ct_BODY_CHAPTER_pskel::
FOOTNOTE ()
{
}

void ct_BODY_CHAPTER_pskel::
ILLUSTRATION ()
{
}

void ct_BODY_CHAPTER_pskel::
TABLE ()
{
}

void ct_BODY_CHAPTER_pskel::
post_ct_BODY_CHAPTER ()
{
}

// ct_BODY_SECTION_pskel
//

void ct_BODY_SECTION_pskel::
BODY_CONTENT ()
{
}

void ct_BODY_SECTION_pskel::
FOOTNOTE ()
{
}

void ct_BODY_SECTION_pskel::
ILLUSTRATION ()
{
}

void ct_BODY_SECTION_pskel::
TABLE ()
{
}

void ct_BODY_SECTION_pskel::
post_ct_BODY_SECTION ()
{
}

// ct_BODY_CONTENT_ARTICLE_pskel
//

void ct_BODY_CONTENT_ARTICLE_pskel::
AUTHOR ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
PARAGRAPH ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
LINK ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
FORMULA ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
CROSSHEADING ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
CONTINUATION_LINK ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
CONTINUATION_HEADLINE ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
ABSTRACT ()
{
}

void ct_BODY_CONTENT_ARTICLE_pskel::
post_ct_BODY_CONTENT_ARTICLE ()
{
}

// ct_BODY_CONTENT_CHAPTER_pskel
//

void ct_BODY_CONTENT_CHAPTER_pskel::
PARAGRAPH ()
{
}

void ct_BODY_CONTENT_CHAPTER_pskel::
LINK ()
{
}

void ct_BODY_CONTENT_CHAPTER_pskel::
FORMULA ()
{
}

void ct_BODY_CONTENT_CHAPTER_pskel::
CROSSHEADING ()
{
}

void ct_BODY_CONTENT_CHAPTER_pskel::
CONTINUATION_LINK ()
{
}

void ct_BODY_CONTENT_CHAPTER_pskel::
CONTINUATION_HEADLINE ()
{
}

void ct_BODY_CONTENT_CHAPTER_pskel::
post_ct_BODY_CONTENT_CHAPTER ()
{
}

// ct_BODY_CONTENT_SECTION_pskel
//

void ct_BODY_CONTENT_SECTION_pskel::
TEXTBLOCK ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
PUBLISHING_STMT ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
PARAGRAPH ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
MARRIAGE ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
DEATH_NOTICE ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
BIRTH ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
ADVERTISEMENT ()
{
}

void ct_BODY_CONTENT_SECTION_pskel::
post_ct_BODY_CONTENT_SECTION ()
{
}

// ct_FORMULA_pskel
//

void ct_FORMULA_pskel::
IMAGE ()
{
}

void ct_FORMULA_pskel::
post_ct_FORMULA ()
{
}

// ct_PARAGRAPH_pskel
//

void ct_PARAGRAPH_pskel::
TEXT ()
{
}

void ct_PARAGRAPH_pskel::
post_ct_PARAGRAPH ()
{
}

// ct_FOOTNOTE_PARAGRAPH_pskel
//

void ct_FOOTNOTE_PARAGRAPH_pskel::
TEXT ()
{
}

void ct_FOOTNOTE_PARAGRAPH_pskel::
post_ct_FOOTNOTE_PARAGRAPH ()
{
}

// ct_FINAL_pskel
//

void ct_FINAL_pskel::
fptr ()
{
}

void ct_FINAL_pskel::
post_ct_FINAL ()
{
}

// ct_FPTR_pskel
//

void ct_FPTR_pskel::
area ()
{
}

void ct_FPTR_pskel::
seq ()
{
}

void ct_FPTR_pskel::
par ()
{
}

void ct_FPTR_pskel::
post_ct_FPTR ()
{
}

// ct_SEQ_pskel
//

void ct_SEQ_pskel::
area ()
{
}

void ct_SEQ_pskel::
post_ct_SEQ ()
{
}

// Newspaper_pskel
//

void Newspaper_pskel::
VOLUME ()
{
}

void Newspaper_pskel::
post_Newspaper ()
{
}

// TITLE_SECTION_pskel
//

void TITLE_SECTION_pskel::
TEXTBLOCK ()
{
}

void TITLE_SECTION_pskel::
PUBLISHING_STMT ()
{
}

void TITLE_SECTION_pskel::
TABLE_OF_CONTENTS ()
{
}

void TITLE_SECTION_pskel::
PAGE_NUMBER ()
{
}

void TITLE_SECTION_pskel::
ILLUSTRATION ()
{
}

void TITLE_SECTION_pskel::
SUBHEADLINE ()
{
}

void TITLE_SECTION_pskel::
OVERLINE ()
{
}

void TITLE_SECTION_pskel::
HEADLINE ()
{
}

void TITLE_SECTION_pskel::
MOTTO ()
{
}

void TITLE_SECTION_pskel::
CONTINUATION_HEADLINE ()
{
}

void TITLE_SECTION_pskel::
post_TITLE_SECTION ()
{
}

// CONTENT_pskel
//

void CONTENT_pskel::
TEXTBLOCK ()
{
}

void CONTENT_pskel::
PUBLISHING_STMT ()
{
}

void CONTENT_pskel::
SECTION ()
{
}

void CONTENT_pskel::
PARAGRAPH ()
{
}

void CONTENT_pskel::
NECROLOGY ()
{
}

void CONTENT_pskel::
WEATHER ()
{
}

void CONTENT_pskel::
SHIPPING ()
{
}

void CONTENT_pskel::
RIDAS ()
{
}

void CONTENT_pskel::
LETTER ()
{
}

void CONTENT_pskel::
INTERVIEW ()
{
}

void CONTENT_pskel::
IMPRINT ()
{
}

void CONTENT_pskel::
ARTICLE ()
{
}

void CONTENT_pskel::
ACKNOWLEDGEMENT ()
{
}

void CONTENT_pskel::
MARRIAGE ()
{
}

void CONTENT_pskel::
DEATH_NOTICE ()
{
}

void CONTENT_pskel::
BIRTH ()
{
}

void CONTENT_pskel::
ADVERTISEMENT ()
{
}

void CONTENT_pskel::
post_CONTENT ()
{
}

// TITLE_SECTION1_pskel
//

void TITLE_SECTION1_pskel::
TEXTBLOCK ()
{
}

void TITLE_SECTION1_pskel::
PUBLISHING_STMT ()
{
}

void TITLE_SECTION1_pskel::
TABLE_OF_CONTENTS ()
{
}

void TITLE_SECTION1_pskel::
PAGE_NUMBER ()
{
}

void TITLE_SECTION1_pskel::
ILLUSTRATION ()
{
}

void TITLE_SECTION1_pskel::
SUBHEADLINE ()
{
}

void TITLE_SECTION1_pskel::
OVERLINE ()
{
}

void TITLE_SECTION1_pskel::
HEADLINE ()
{
}

void TITLE_SECTION1_pskel::
MOTTO ()
{
}

void TITLE_SECTION1_pskel::
CONTINUATION_HEADLINE ()
{
}

void TITLE_SECTION1_pskel::
post_TITLE_SECTION1 ()
{
}

// CONTENT1_pskel
//

void CONTENT1_pskel::
TEXTBLOCK ()
{
}

void CONTENT1_pskel::
PUBLISHING_STMT ()
{
}

void CONTENT1_pskel::
SECTION ()
{
}

void CONTENT1_pskel::
PARAGRAPH ()
{
}

void CONTENT1_pskel::
NECROLOGY ()
{
}

void CONTENT1_pskel::
WEATHER ()
{
}

void CONTENT1_pskel::
SHIPPING ()
{
}

void CONTENT1_pskel::
RIDAS ()
{
}

void CONTENT1_pskel::
LETTER ()
{
}

void CONTENT1_pskel::
INTERVIEW ()
{
}

void CONTENT1_pskel::
IMPRINT ()
{
}

void CONTENT1_pskel::
ARTICLE ()
{
}

void CONTENT1_pskel::
ACKNOWLEDGEMENT ()
{
}

void CONTENT1_pskel::
MARRIAGE ()
{
}

void CONTENT1_pskel::
DEATH_NOTICE ()
{
}

void CONTENT1_pskel::
BIRTH ()
{
}

void CONTENT1_pskel::
ADVERTISEMENT ()
{
}

void CONTENT1_pskel::
post_CONTENT1 ()
{
}

// DATA_pskel
//

void DATA_pskel::
TEXTBLOCK ()
{
}

void DATA_pskel::
PUBLISHING_STMT ()
{
}

void DATA_pskel::
PAGE_NUMBER ()
{
}

void DATA_pskel::
ITEM_CAPTION ()
{
}

void DATA_pskel::
AUTHOR ()
{
}

void DATA_pskel::
post_DATA ()
{
}

// par_pskel
//

void par_pskel::
area ()
{
}

void par_pskel::
seq ()
{
}

void par_pskel::
post_par ()
{
}

#include <cassert>

// Element validation and dispatch functions for ct_HIERARCHY_pskel.
//
bool ct_HIERARCHY_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "SUPPLEMENT" && ns.empty ())
        s = 0UL;
      else if (n == "ISSUE" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_HIERARCHY_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_HIERARCHY_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_HIERARCHY_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_HIERARCHY_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_HIERARCHY_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SUPPLEMENT_parser_;

        if (this->SUPPLEMENT_parser_)
          this->SUPPLEMENT_parser_->pre ();
      }
      else
      {
        if (this->SUPPLEMENT_parser_)
        {
          this->SUPPLEMENT_parser_->post_ct_SUPPLEMENT ();
          this->SUPPLEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ISSUE_parser_;

        if (this->ISSUE_parser_)
          this->ISSUE_parser_->pre ();
      }
      else
      {
        if (this->ISSUE_parser_)
        {
          this->ISSUE_parser_->post_ct_ISSUE ();
          this->ISSUE ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_ISSUE_pskel.
//
bool ct_ISSUE_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TITLE_SECTION" && ns.empty ())
        s = 0UL;
      else if (n == "CONTENT" && ns.empty ())
        s = 1UL;
      else if (n == "SUPPLEMENT" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_ISSUE_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_ISSUE_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_ISSUE_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_ISSUE_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_ISSUE_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "TITLE_SECTION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_SECTION_parser_;

          if (this->TITLE_SECTION_parser_)
            this->TITLE_SECTION_parser_->pre ();
        }
        else
        {
          if (this->TITLE_SECTION_parser_)
          {
            this->TITLE_SECTION_parser_->post_TITLE_SECTION ();
            this->TITLE_SECTION ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "CONTENT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTENT_parser_;

          if (this->CONTENT_parser_)
            this->CONTENT_parser_->pre ();
        }
        else
        {
          if (this->CONTENT_parser_)
          {
            this->CONTENT_parser_->post_CONTENT ();
            this->CONTENT ();
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "SUPPLEMENT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->SUPPLEMENT_parser_;

          if (this->SUPPLEMENT_parser_)
            this->SUPPLEMENT_parser_->pre ();
        }
        else
        {
          if (this->SUPPLEMENT_parser_)
          {
            this->SUPPLEMENT_parser_->post_ct_SUPPLEMENT ();
            this->SUPPLEMENT ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_SUPPLEMENT_pskel.
//
bool ct_SUPPLEMENT_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TITLE_SECTION" && ns.empty ())
        s = 0UL;
      else if (n == "CONTENT" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_SUPPLEMENT_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_SUPPLEMENT_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_SUPPLEMENT_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_SUPPLEMENT_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_SUPPLEMENT_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "TITLE_SECTION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_SECTION_parser_;

          if (this->TITLE_SECTION_parser_)
            this->TITLE_SECTION_parser_->pre ();
        }
        else
        {
          if (this->TITLE_SECTION_parser_)
          {
            this->TITLE_SECTION_parser_->post_TITLE_SECTION1 ();
            this->TITLE_SECTION ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "CONTENT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTENT_parser_;

          if (this->CONTENT_parser_)
            this->CONTENT_parser_->pre ();
        }
        else
        {
          if (this->CONTENT_parser_)
          {
            this->CONTENT_parser_->post_CONTENT1 ();
            this->CONTENT ();
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_LIST_LIKE_pskel.
//
bool ct_LIST_LIKE_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "CAPTION" && ns.empty ())
        s = 0UL;
      else if (n == "DATA" && ns.empty ())
        s = 1UL;
      else if ((n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
               (n == "LIST" && ns.empty ()) ||
               (n == "ITEM" && ns.empty ()))
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_LIST_LIKE_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_LIST_LIKE_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_LIST_LIKE_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_LIST_LIKE_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_LIST_LIKE_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "CAPTION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->CAPTION_parser_;

          if (this->CAPTION_parser_)
            this->CAPTION_parser_->pre ();
        }
        else
        {
          if (this->CAPTION_parser_)
          {
            this->CAPTION_parser_->post_ct_FINAL ();
            this->CAPTION ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "DATA" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->DATA_parser_;

          if (this->DATA_parser_)
            this->DATA_parser_->pre ();
        }
        else
        {
          if (this->DATA_parser_)
          {
            this->DATA_parser_->post_DATA ();
            this->DATA ();
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      unsigned long s (~0UL);

      if (n == "TABLE_OF_CONTENTS" && ns.empty ())
        s = 0UL;
      else if (n == "LIST" && ns.empty ())
        s = 1UL;
      else if (n == "ITEM" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        assert (start);
        count++;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = &ct_LIST_LIKE_pskel::choice_0;
        vd.state = s;
        vd.count = 0;

        this->choice_0 (vd.state, vd.count, ns, n, t, true);
        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

void ct_LIST_LIKE_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

        if (this->TABLE_OF_CONTENTS_parser_)
          this->TABLE_OF_CONTENTS_parser_->pre ();
      }
      else
      {
        if (this->TABLE_OF_CONTENTS_parser_)
        {
          this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
          this->TABLE_OF_CONTENTS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

        if (this->LIST_parser_)
          this->LIST_parser_->pre ();
      }
      else
      {
        if (this->LIST_parser_)
        {
          this->LIST_parser_->post_ct_LIST_LIKE ();
          this->LIST ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_parser_;

        if (this->ITEM_parser_)
          this->ITEM_parser_->pre ();
      }
      else
      {
        if (this->ITEM_parser_)
        {
          this->ITEM_parser_->post_ct_ITEM ();
          this->ITEM ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_ITEM_pskel.
//
bool ct_ITEM_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if ((n == "TEXTBLOCK" && ns.empty ()) ||
          (n == "PUBLISHING_STMT" && ns.empty ()) ||
          (n == "PAGE_NUMBER" && ns.empty ()) ||
          (n == "ITEM_CAPTION" && ns.empty ()) ||
          (n == "SUBHEADLINE" && ns.empty ()) ||
          (n == "OVERLINE" && ns.empty ()) ||
          (n == "HEADLINE" && ns.empty ()) ||
          (n == "CONTINUATION_HEADLINE" && ns.empty ()) ||
          (n == "AUTHOR" && ns.empty ()))
        s = 0UL;
      else if (n == "ITEM" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_ITEM_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_ITEM_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_ITEM_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_ITEM_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_ITEM_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      unsigned long s (~0UL);

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "PAGE_NUMBER" && ns.empty ())
        s = 2UL;
      else if (n == "ITEM_CAPTION" && ns.empty ())
        s = 3UL;
      else if (n == "SUBHEADLINE" && ns.empty ())
        s = 4UL;
      else if (n == "OVERLINE" && ns.empty ())
        s = 5UL;
      else if (n == "HEADLINE" && ns.empty ())
        s = 6UL;
      else if (n == "CONTINUATION_HEADLINE" && ns.empty ())
        s = 7UL;
      else if (n == "AUTHOR" && ns.empty ())
        s = 8UL;

      if (s != ~0UL)
      {
        assert (start);
        count++;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = &ct_ITEM_pskel::choice_0;
        vd.state = s;
        vd.count = 0;

        this->choice_0 (vd.state, vd.count, ns, n, t, true);
        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "ITEM" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_parser_;

          if (this->ITEM_parser_)
            this->ITEM_parser_->pre ();
        }
        else
        {
          if (this->ITEM_parser_)
          {
            this->ITEM_parser_->post_ct_ITEM ();
            this->ITEM ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

void ct_ITEM_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PAGE_NUMBER_parser_;

        if (this->PAGE_NUMBER_parser_)
          this->PAGE_NUMBER_parser_->pre ();
      }
      else
      {
        if (this->PAGE_NUMBER_parser_)
        {
          this->PAGE_NUMBER_parser_->post_ct_FINAL ();
          this->PAGE_NUMBER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_CAPTION_parser_;

        if (this->ITEM_CAPTION_parser_)
          this->ITEM_CAPTION_parser_->pre ();
      }
      else
      {
        if (this->ITEM_CAPTION_parser_)
        {
          this->ITEM_CAPTION_parser_->post_ct_FINAL ();
          this->ITEM_CAPTION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBHEADLINE_parser_;

        if (this->SUBHEADLINE_parser_)
          this->SUBHEADLINE_parser_->pre ();
      }
      else
      {
        if (this->SUBHEADLINE_parser_)
        {
          this->SUBHEADLINE_parser_->post_ct_FINAL ();
          this->SUBHEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->OVERLINE_parser_;

        if (this->OVERLINE_parser_)
          this->OVERLINE_parser_->pre ();
      }
      else
      {
        if (this->OVERLINE_parser_)
        {
          this->OVERLINE_parser_->post_ct_FINAL ();
          this->OVERLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADLINE_parser_;

        if (this->HEADLINE_parser_)
          this->HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->HEADLINE_parser_)
        {
          this->HEADLINE_parser_->post_ct_FINAL ();
          this->HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_HEADLINE_parser_;

        if (this->CONTINUATION_HEADLINE_parser_)
          this->CONTINUATION_HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_HEADLINE_parser_)
        {
          this->CONTINUATION_HEADLINE_parser_->post_ct_FINAL ();
          this->CONTINUATION_HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 8UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

        if (this->AUTHOR_parser_)
          this->AUTHOR_parser_->pre ();
      }
      else
      {
        if (this->AUTHOR_parser_)
        {
          this->AUTHOR_parser_->post_ct_FINAL ();
          this->AUTHOR ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_SECTION_pskel.
//
bool ct_SECTION_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "HEADING" && ns.empty ())
        s = 0UL;
      else if (n == "BODY" && ns.empty ())
        s = 1UL;
      else if ((n == "SECTION" && ns.empty ()) ||
               (n == "NECROLOGY" && ns.empty ()) ||
               (n == "WEATHER" && ns.empty ()) ||
               (n == "SHIPPING" && ns.empty ()) ||
               (n == "RIDAS" && ns.empty ()) ||
               (n == "LETTER" && ns.empty ()) ||
               (n == "INTERVIEW" && ns.empty ()) ||
               (n == "IMPRINT" && ns.empty ()) ||
               (n == "ARTICLE" && ns.empty ()) ||
               (n == "ACKNOWLEDGEMENT" && ns.empty ()))
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_SECTION_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_SECTION_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_SECTION_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_SECTION_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_SECTION_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "HEADING" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADING_parser_;

          if (this->HEADING_parser_)
            this->HEADING_parser_->pre ();
        }
        else
        {
          if (this->HEADING_parser_)
          {
            this->HEADING_parser_->post_ct_CHAPTER_LIKE_HEADING ();
            this->HEADING ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "BODY" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_parser_;

          if (this->BODY_parser_)
            this->BODY_parser_->pre ();
        }
        else
        {
          if (this->BODY_parser_)
          {
            this->BODY_parser_->post_ct_BODY_SECTION ();
            this->BODY ();
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      unsigned long s (~0UL);

      if (n == "SECTION" && ns.empty ())
        s = 0UL;
      else if (n == "NECROLOGY" && ns.empty ())
        s = 1UL;
      else if (n == "WEATHER" && ns.empty ())
        s = 2UL;
      else if (n == "SHIPPING" && ns.empty ())
        s = 3UL;
      else if (n == "RIDAS" && ns.empty ())
        s = 4UL;
      else if (n == "LETTER" && ns.empty ())
        s = 5UL;
      else if (n == "INTERVIEW" && ns.empty ())
        s = 6UL;
      else if (n == "IMPRINT" && ns.empty ())
        s = 7UL;
      else if (n == "ARTICLE" && ns.empty ())
        s = 8UL;
      else if (n == "ACKNOWLEDGEMENT" && ns.empty ())
        s = 9UL;

      if (s != ~0UL)
      {
        assert (start);
        count++;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = &ct_SECTION_pskel::choice_0;
        vd.state = s;
        vd.count = 0;

        this->choice_0 (vd.state, vd.count, ns, n, t, true);
        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

void ct_SECTION_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SECTION_parser_;

        if (this->SECTION_parser_)
          this->SECTION_parser_->pre ();
      }
      else
      {
        if (this->SECTION_parser_)
        {
          this->SECTION_parser_->post_ct_SECTION ();
          this->SECTION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

        if (this->NECROLOGY_parser_)
          this->NECROLOGY_parser_->pre ();
      }
      else
      {
        if (this->NECROLOGY_parser_)
        {
          this->NECROLOGY_parser_->post_ct_ARTICLE_LIKE ();
          this->NECROLOGY ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->WEATHER_parser_;

        if (this->WEATHER_parser_)
          this->WEATHER_parser_->pre ();
      }
      else
      {
        if (this->WEATHER_parser_)
        {
          this->WEATHER_parser_->post_ct_ARTICLE_LIKE ();
          this->WEATHER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SHIPPING_parser_;

        if (this->SHIPPING_parser_)
          this->SHIPPING_parser_->pre ();
      }
      else
      {
        if (this->SHIPPING_parser_)
        {
          this->SHIPPING_parser_->post_ct_ARTICLE_LIKE ();
          this->SHIPPING ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

        if (this->RIDAS_parser_)
          this->RIDAS_parser_->pre ();
      }
      else
      {
        if (this->RIDAS_parser_)
        {
          this->RIDAS_parser_->post_ct_ARTICLE_LIKE ();
          this->RIDAS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LETTER_parser_;

        if (this->LETTER_parser_)
          this->LETTER_parser_->pre ();
      }
      else
      {
        if (this->LETTER_parser_)
        {
          this->LETTER_parser_->post_ct_ARTICLE_LIKE ();
          this->LETTER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->INTERVIEW_parser_;

        if (this->INTERVIEW_parser_)
          this->INTERVIEW_parser_->pre ();
      }
      else
      {
        if (this->INTERVIEW_parser_)
        {
          this->INTERVIEW_parser_->post_ct_ARTICLE_LIKE ();
          this->INTERVIEW ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->IMPRINT_parser_;

        if (this->IMPRINT_parser_)
          this->IMPRINT_parser_->pre ();
      }
      else
      {
        if (this->IMPRINT_parser_)
        {
          this->IMPRINT_parser_->post_ct_ARTICLE_LIKE ();
          this->IMPRINT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 8UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ARTICLE_parser_;

        if (this->ARTICLE_parser_)
          this->ARTICLE_parser_->pre ();
      }
      else
      {
        if (this->ARTICLE_parser_)
        {
          this->ARTICLE_parser_->post_ct_ARTICLE_LIKE ();
          this->ARTICLE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 9UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENT_parser_;

        if (this->ACKNOWLEDGEMENT_parser_)
          this->ACKNOWLEDGEMENT_parser_->pre ();
      }
      else
      {
        if (this->ACKNOWLEDGEMENT_parser_)
        {
          this->ACKNOWLEDGEMENT_parser_->post_ct_ARTICLE_LIKE ();
          this->ACKNOWLEDGEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_CHAPTER_pskel.
//
bool ct_CHAPTER_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "HEADING" && ns.empty ())
        s = 0UL;
      else if (n == "BODY" && ns.empty ())
        s = 1UL;
      else if ((n == "LIST" && ns.empty ()) ||
               (n == "CHAPTER" && ns.empty ()))
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_CHAPTER_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_CHAPTER_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_CHAPTER_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_CHAPTER_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_CHAPTER_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "HEADING" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADING_parser_;

          if (this->HEADING_parser_)
            this->HEADING_parser_->pre ();
        }
        else
        {
          if (this->HEADING_parser_)
          {
            this->HEADING_parser_->post_ct_CHAPTER_HEADING ();
            this->HEADING ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "BODY" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_parser_;

          if (this->BODY_parser_)
            this->BODY_parser_->pre ();
        }
        else
        {
          if (this->BODY_parser_)
          {
            this->BODY_parser_->post_ct_BODY_CHAPTER ();
            this->BODY ();
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      unsigned long s (~0UL);

      if (n == "LIST" && ns.empty ())
        s = 0UL;
      else if (n == "CHAPTER" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        assert (start);
        count++;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = &ct_CHAPTER_pskel::choice_0;
        vd.state = s;
        vd.count = 0;

        this->choice_0 (vd.state, vd.count, ns, n, t, true);
        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

void ct_CHAPTER_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

        if (this->LIST_parser_)
          this->LIST_parser_->pre ();
      }
      else
      {
        if (this->LIST_parser_)
        {
          this->LIST_parser_->post_ct_LIST_LIKE ();
          this->LIST ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CHAPTER_parser_;

        if (this->CHAPTER_parser_)
          this->CHAPTER_parser_->pre ();
      }
      else
      {
        if (this->CHAPTER_parser_)
        {
          this->CHAPTER_parser_->post_ct_CHAPTER ();
          this->CHAPTER ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_ARTICLE_LIKE_pskel.
//
bool ct_ARTICLE_LIKE_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "HEADING" && ns.empty ())
        s = 0UL;
      else if (n == "BODY" && ns.empty ())
        s = 1UL;
      else if ((n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
               (n == "LIST" && ns.empty ()) ||
               (n == "CHAPTER" && ns.empty ()))
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_ARTICLE_LIKE_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_ARTICLE_LIKE_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_ARTICLE_LIKE_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_ARTICLE_LIKE_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_ARTICLE_LIKE_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "HEADING" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADING_parser_;

          if (this->HEADING_parser_)
            this->HEADING_parser_->pre ();
        }
        else
        {
          if (this->HEADING_parser_)
          {
            this->HEADING_parser_->post_ct_CHAPTER_LIKE_HEADING ();
            this->HEADING ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "BODY" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_parser_;

          if (this->BODY_parser_)
            this->BODY_parser_->pre ();
        }
        else
        {
          if (this->BODY_parser_)
          {
            this->BODY_parser_->post_ct_BODY_ARTICLE ();
            this->BODY ();
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      unsigned long s (~0UL);

      if (n == "TABLE_OF_CONTENTS" && ns.empty ())
        s = 0UL;
      else if (n == "LIST" && ns.empty ())
        s = 1UL;
      else if (n == "CHAPTER" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        assert (start);
        count++;

        v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
        v_state_descr_& vd = vs.data[vs.size++];

        vd.func = &ct_ARTICLE_LIKE_pskel::choice_0;
        vd.state = s;
        vd.count = 0;

        this->choice_0 (vd.state, vd.count, ns, n, t, true);
        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

void ct_ARTICLE_LIKE_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

        if (this->TABLE_OF_CONTENTS_parser_)
          this->TABLE_OF_CONTENTS_parser_->pre ();
      }
      else
      {
        if (this->TABLE_OF_CONTENTS_parser_)
        {
          this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
          this->TABLE_OF_CONTENTS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

        if (this->LIST_parser_)
          this->LIST_parser_->pre ();
      }
      else
      {
        if (this->LIST_parser_)
        {
          this->LIST_parser_->post_ct_LIST_LIKE ();
          this->LIST ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CHAPTER_parser_;

        if (this->CHAPTER_parser_)
          this->CHAPTER_parser_->pre ();
      }
      else
      {
        if (this->CHAPTER_parser_)
        {
          this->CHAPTER_parser_->post_ct_CHAPTER ();
          this->CHAPTER ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_CHAPTER_LIKE_HEADING_pskel.
//
bool ct_CHAPTER_LIKE_HEADING_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "OVERLINE" && ns.empty ())
        s = 0UL;
      else if (n == "TITLE" && ns.empty ())
        s = 1UL;
      else if (n == "SUBHEADLINE" && ns.empty ())
        s = 2UL;
      else if (n == "AUTHOR" && ns.empty ())
        s = 3UL;
      else if (n == "TEXT" && ns.empty ())
        s = 4UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_CHAPTER_LIKE_HEADING_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_CHAPTER_LIKE_HEADING_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_CHAPTER_LIKE_HEADING_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_CHAPTER_LIKE_HEADING_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->OVERLINE_parser_;

        if (this->OVERLINE_parser_)
          this->OVERLINE_parser_->pre ();
      }
      else
      {
        if (this->OVERLINE_parser_)
        {
          this->OVERLINE_parser_->post_ct_FINAL ();
          this->OVERLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_parser_;

        if (this->TITLE_parser_)
          this->TITLE_parser_->pre ();
      }
      else
      {
        if (this->TITLE_parser_)
        {
          this->TITLE_parser_->post_ct_FINAL ();
          this->TITLE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBHEADLINE_parser_;

        if (this->SUBHEADLINE_parser_)
          this->SUBHEADLINE_parser_->pre ();
      }
      else
      {
        if (this->SUBHEADLINE_parser_)
        {
          this->SUBHEADLINE_parser_->post_ct_FINAL ();
          this->SUBHEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

        if (this->AUTHOR_parser_)
          this->AUTHOR_parser_->pre ();
      }
      else
      {
        if (this->AUTHOR_parser_)
        {
          this->AUTHOR_parser_->post_ct_FINAL ();
          this->AUTHOR ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

        if (this->TEXT_parser_)
          this->TEXT_parser_->pre ();
      }
      else
      {
        if (this->TEXT_parser_)
        {
          this->TEXT_parser_->post_ct_FINAL ();
          this->TEXT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_CHAPTER_HEADING_pskel.
//
bool ct_CHAPTER_HEADING_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TITLE" && ns.empty ())
        s = 0UL;
      else if (n == "AUTHOR" && ns.empty ())
        s = 1UL;
      else if (n == "TEXT" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_CHAPTER_HEADING_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_CHAPTER_HEADING_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_CHAPTER_HEADING_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_CHAPTER_HEADING_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_CHAPTER_HEADING_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_parser_;

        if (this->TITLE_parser_)
          this->TITLE_parser_->pre ();
      }
      else
      {
        if (this->TITLE_parser_)
        {
          this->TITLE_parser_->post_ct_FINAL ();
          this->TITLE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

        if (this->AUTHOR_parser_)
          this->AUTHOR_parser_->pre ();
      }
      else
      {
        if (this->AUTHOR_parser_)
        {
          this->AUTHOR_parser_->post_ct_FINAL ();
          this->AUTHOR ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

        if (this->TEXT_parser_)
          this->TEXT_parser_->pre ();
      }
      else
      {
        if (this->TEXT_parser_)
        {
          this->TEXT_parser_->post_ct_FINAL ();
          this->TEXT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_ILLUSTRATION_LIKE_STRUCT_pskel.
//
bool ct_ILLUSTRATION_LIKE_STRUCT_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "IMAGE" && ns.empty ())
        s = 0UL;
      else if (n == "CAPTION" && ns.empty ())
        s = 1UL;
      else if (n == "AUTHOR" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_ILLUSTRATION_LIKE_STRUCT_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_ILLUSTRATION_LIKE_STRUCT_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "IMAGE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->IMAGE_parser_;

          if (this->IMAGE_parser_)
            this->IMAGE_parser_->pre ();
        }
        else
        {
          if (this->IMAGE_parser_)
          {
            this->IMAGE_parser_->post_ct_FINAL ();
            this->IMAGE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "CAPTION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->CAPTION_parser_;

          if (this->CAPTION_parser_)
            this->CAPTION_parser_->pre ();
        }
        else
        {
          if (this->CAPTION_parser_)
          {
            this->CAPTION_parser_->post_ct_FINAL ();
            this->CAPTION ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "AUTHOR" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

          if (this->AUTHOR_parser_)
            this->AUTHOR_parser_->pre ();
        }
        else
        {
          if (this->AUTHOR_parser_)
          {
            this->AUTHOR_parser_->post_ct_FINAL ();
            this->AUTHOR ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_TABLE_LIKE_STRUCT_pskel.
//
bool ct_TABLE_LIKE_STRUCT_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "IMAGE" && ns.empty ())
        s = 0UL;
      else if (n == "CAPTION" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_TABLE_LIKE_STRUCT_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_TABLE_LIKE_STRUCT_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_TABLE_LIKE_STRUCT_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_TABLE_LIKE_STRUCT_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_TABLE_LIKE_STRUCT_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "IMAGE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->IMAGE_parser_;

          if (this->IMAGE_parser_)
            this->IMAGE_parser_->pre ();
        }
        else
        {
          if (this->IMAGE_parser_)
          {
            this->IMAGE_parser_->post_ct_FINAL ();
            this->IMAGE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "CAPTION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->CAPTION_parser_;

          if (this->CAPTION_parser_)
            this->CAPTION_parser_->pre ();
        }
        else
        {
          if (this->CAPTION_parser_)
          {
            this->CAPTION_parser_->post_ct_FINAL ();
            this->CAPTION ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_BODY_ARTICLE_pskel.
//
bool ct_BODY_ARTICLE_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "BODY_CONTENT" && ns.empty ())
        s = 0UL;
      else if (n == "FOOTNOTE" && ns.empty ())
        s = 1UL;
      else if (n == "ILLUSTRATION" && ns.empty ())
        s = 2UL;
      else if (n == "TABLE" && ns.empty ())
        s = 3UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_BODY_ARTICLE_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_BODY_ARTICLE_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_BODY_ARTICLE_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_BODY_ARTICLE_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_BODY_ARTICLE_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "BODY_CONTENT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_CONTENT_parser_;

          if (this->BODY_CONTENT_parser_)
            this->BODY_CONTENT_parser_->pre ();
        }
        else
        {
          if (this->BODY_CONTENT_parser_)
          {
            this->BODY_CONTENT_parser_->post_ct_BODY_CONTENT_ARTICLE ();
            this->BODY_CONTENT ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "FOOTNOTE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->FOOTNOTE_parser_;

          if (this->FOOTNOTE_parser_)
            this->FOOTNOTE_parser_->pre ();
        }
        else
        {
          if (this->FOOTNOTE_parser_)
          {
            this->FOOTNOTE_parser_->post_ct_FOOTNOTE_PARAGRAPH ();
            this->FOOTNOTE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "ILLUSTRATION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

          if (this->ILLUSTRATION_parser_)
            this->ILLUSTRATION_parser_->pre ();
        }
        else
        {
          if (this->ILLUSTRATION_parser_)
          {
            this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
            this->ILLUSTRATION ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "TABLE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

          if (this->TABLE_parser_)
            this->TABLE_parser_->pre ();
        }
        else
        {
          if (this->TABLE_parser_)
          {
            this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
            this->TABLE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_BODY_CHAPTER_pskel.
//
bool ct_BODY_CHAPTER_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "BODY_CONTENT" && ns.empty ())
        s = 0UL;
      else if (n == "FOOTNOTE" && ns.empty ())
        s = 1UL;
      else if (n == "ILLUSTRATION" && ns.empty ())
        s = 2UL;
      else if (n == "TABLE" && ns.empty ())
        s = 3UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_BODY_CHAPTER_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_BODY_CHAPTER_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_BODY_CHAPTER_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_BODY_CHAPTER_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_BODY_CHAPTER_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "BODY_CONTENT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_CONTENT_parser_;

          if (this->BODY_CONTENT_parser_)
            this->BODY_CONTENT_parser_->pre ();
        }
        else
        {
          if (this->BODY_CONTENT_parser_)
          {
            this->BODY_CONTENT_parser_->post_ct_BODY_CONTENT_CHAPTER ();
            this->BODY_CONTENT ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "FOOTNOTE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->FOOTNOTE_parser_;

          if (this->FOOTNOTE_parser_)
            this->FOOTNOTE_parser_->pre ();
        }
        else
        {
          if (this->FOOTNOTE_parser_)
          {
            this->FOOTNOTE_parser_->post_ct_FOOTNOTE_PARAGRAPH ();
            this->FOOTNOTE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "ILLUSTRATION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

          if (this->ILLUSTRATION_parser_)
            this->ILLUSTRATION_parser_->pre ();
        }
        else
        {
          if (this->ILLUSTRATION_parser_)
          {
            this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
            this->ILLUSTRATION ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "TABLE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

          if (this->TABLE_parser_)
            this->TABLE_parser_->pre ();
        }
        else
        {
          if (this->TABLE_parser_)
          {
            this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
            this->TABLE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_BODY_SECTION_pskel.
//
bool ct_BODY_SECTION_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "BODY_CONTENT" && ns.empty ())
        s = 0UL;
      else if (n == "FOOTNOTE" && ns.empty ())
        s = 1UL;
      else if (n == "ILLUSTRATION" && ns.empty ())
        s = 2UL;
      else if (n == "TABLE" && ns.empty ())
        s = 3UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_BODY_SECTION_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_BODY_SECTION_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_BODY_SECTION_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_BODY_SECTION_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_BODY_SECTION_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "BODY_CONTENT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_CONTENT_parser_;

          if (this->BODY_CONTENT_parser_)
            this->BODY_CONTENT_parser_->pre ();
        }
        else
        {
          if (this->BODY_CONTENT_parser_)
          {
            this->BODY_CONTENT_parser_->post_ct_BODY_CONTENT_SECTION ();
            this->BODY_CONTENT ();
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "FOOTNOTE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->FOOTNOTE_parser_;

          if (this->FOOTNOTE_parser_)
            this->FOOTNOTE_parser_->pre ();
        }
        else
        {
          if (this->FOOTNOTE_parser_)
          {
            this->FOOTNOTE_parser_->post_ct_FOOTNOTE_PARAGRAPH ();
            this->FOOTNOTE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "ILLUSTRATION" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

          if (this->ILLUSTRATION_parser_)
            this->ILLUSTRATION_parser_->pre ();
        }
        else
        {
          if (this->ILLUSTRATION_parser_)
          {
            this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
            this->ILLUSTRATION ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "TABLE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

          if (this->TABLE_parser_)
            this->TABLE_parser_->pre ();
        }
        else
        {
          if (this->TABLE_parser_)
          {
            this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
            this->TABLE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_BODY_CONTENT_ARTICLE_pskel.
//
bool ct_BODY_CONTENT_ARTICLE_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "AUTHOR" && ns.empty ())
        s = 0UL;
      else if (n == "PARAGRAPH" && ns.empty ())
        s = 1UL;
      else if (n == "LINK" && ns.empty ())
        s = 2UL;
      else if (n == "FORMULA" && ns.empty ())
        s = 3UL;
      else if (n == "CROSSHEADING" && ns.empty ())
        s = 4UL;
      else if (n == "CONTINUATION_LINK" && ns.empty ())
        s = 5UL;
      else if (n == "CONTINUATION_HEADLINE" && ns.empty ())
        s = 6UL;
      else if (n == "ABSTRACT" && ns.empty ())
        s = 7UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_BODY_CONTENT_ARTICLE_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_BODY_CONTENT_ARTICLE_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_BODY_CONTENT_ARTICLE_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_BODY_CONTENT_ARTICLE_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

        if (this->AUTHOR_parser_)
          this->AUTHOR_parser_->pre ();
      }
      else
      {
        if (this->AUTHOR_parser_)
        {
          this->AUTHOR_parser_->post_ct_FINAL ();
          this->AUTHOR ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

        if (this->PARAGRAPH_parser_)
          this->PARAGRAPH_parser_->pre ();
      }
      else
      {
        if (this->PARAGRAPH_parser_)
        {
          this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
          this->PARAGRAPH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LINK_parser_;

        if (this->LINK_parser_)
          this->LINK_parser_->pre ();
      }
      else
      {
        if (this->LINK_parser_)
        {
          this->LINK_parser_->post_ct_FINAL ();
          this->LINK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->FORMULA_parser_;

        if (this->FORMULA_parser_)
          this->FORMULA_parser_->pre ();
      }
      else
      {
        if (this->FORMULA_parser_)
        {
          this->FORMULA_parser_->post_ct_FORMULA ();
          this->FORMULA ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CROSSHEADING_parser_;

        if (this->CROSSHEADING_parser_)
          this->CROSSHEADING_parser_->pre ();
      }
      else
      {
        if (this->CROSSHEADING_parser_)
        {
          this->CROSSHEADING_parser_->post_ct_FINAL ();
          this->CROSSHEADING ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_LINK_parser_;

        if (this->CONTINUATION_LINK_parser_)
          this->CONTINUATION_LINK_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_LINK_parser_)
        {
          this->CONTINUATION_LINK_parser_->post_ct_FINAL ();
          this->CONTINUATION_LINK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_HEADLINE_parser_;

        if (this->CONTINUATION_HEADLINE_parser_)
          this->CONTINUATION_HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_HEADLINE_parser_)
        {
          this->CONTINUATION_HEADLINE_parser_->post_ct_FINAL ();
          this->CONTINUATION_HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ABSTRACT_parser_;

        if (this->ABSTRACT_parser_)
          this->ABSTRACT_parser_->pre ();
      }
      else
      {
        if (this->ABSTRACT_parser_)
        {
          this->ABSTRACT_parser_->post_ct_FINAL ();
          this->ABSTRACT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_BODY_CONTENT_CHAPTER_pskel.
//
bool ct_BODY_CONTENT_CHAPTER_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "PARAGRAPH" && ns.empty ())
        s = 0UL;
      else if (n == "LINK" && ns.empty ())
        s = 1UL;
      else if (n == "FORMULA" && ns.empty ())
        s = 2UL;
      else if (n == "CROSSHEADING" && ns.empty ())
        s = 3UL;
      else if (n == "CONTINUATION_LINK" && ns.empty ())
        s = 4UL;
      else if (n == "CONTINUATION_HEADLINE" && ns.empty ())
        s = 5UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_BODY_CONTENT_CHAPTER_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_BODY_CONTENT_CHAPTER_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_BODY_CONTENT_CHAPTER_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_BODY_CONTENT_CHAPTER_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

        if (this->PARAGRAPH_parser_)
          this->PARAGRAPH_parser_->pre ();
      }
      else
      {
        if (this->PARAGRAPH_parser_)
        {
          this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
          this->PARAGRAPH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LINK_parser_;

        if (this->LINK_parser_)
          this->LINK_parser_->pre ();
      }
      else
      {
        if (this->LINK_parser_)
        {
          this->LINK_parser_->post_ct_FINAL ();
          this->LINK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->FORMULA_parser_;

        if (this->FORMULA_parser_)
          this->FORMULA_parser_->pre ();
      }
      else
      {
        if (this->FORMULA_parser_)
        {
          this->FORMULA_parser_->post_ct_FORMULA ();
          this->FORMULA ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CROSSHEADING_parser_;

        if (this->CROSSHEADING_parser_)
          this->CROSSHEADING_parser_->pre ();
      }
      else
      {
        if (this->CROSSHEADING_parser_)
        {
          this->CROSSHEADING_parser_->post_ct_FINAL ();
          this->CROSSHEADING ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_LINK_parser_;

        if (this->CONTINUATION_LINK_parser_)
          this->CONTINUATION_LINK_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_LINK_parser_)
        {
          this->CONTINUATION_LINK_parser_->post_ct_FINAL ();
          this->CONTINUATION_LINK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_HEADLINE_parser_;

        if (this->CONTINUATION_HEADLINE_parser_)
          this->CONTINUATION_HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_HEADLINE_parser_)
        {
          this->CONTINUATION_HEADLINE_parser_->post_ct_FINAL ();
          this->CONTINUATION_HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_BODY_CONTENT_SECTION_pskel.
//
bool ct_BODY_CONTENT_SECTION_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "PARAGRAPH" && ns.empty ())
        s = 2UL;
      else if (n == "MARRIAGE" && ns.empty ())
        s = 3UL;
      else if (n == "DEATH_NOTICE" && ns.empty ())
        s = 4UL;
      else if (n == "BIRTH" && ns.empty ())
        s = 5UL;
      else if (n == "ADVERTISEMENT" && ns.empty ())
        s = 6UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_BODY_CONTENT_SECTION_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_BODY_CONTENT_SECTION_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_BODY_CONTENT_SECTION_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_BODY_CONTENT_SECTION_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_BODY_CONTENT_SECTION_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

        if (this->PARAGRAPH_parser_)
          this->PARAGRAPH_parser_->pre ();
      }
      else
      {
        if (this->PARAGRAPH_parser_)
        {
          this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
          this->PARAGRAPH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->MARRIAGE_parser_;

        if (this->MARRIAGE_parser_)
          this->MARRIAGE_parser_->pre ();
      }
      else
      {
        if (this->MARRIAGE_parser_)
        {
          this->MARRIAGE_parser_->post_ct_FINAL ();
          this->MARRIAGE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->DEATH_NOTICE_parser_;

        if (this->DEATH_NOTICE_parser_)
          this->DEATH_NOTICE_parser_->pre ();
      }
      else
      {
        if (this->DEATH_NOTICE_parser_)
        {
          this->DEATH_NOTICE_parser_->post_ct_FINAL ();
          this->DEATH_NOTICE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->BIRTH_parser_;

        if (this->BIRTH_parser_)
          this->BIRTH_parser_->pre ();
      }
      else
      {
        if (this->BIRTH_parser_)
        {
          this->BIRTH_parser_->post_ct_FINAL ();
          this->BIRTH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ADVERTISEMENT_parser_;

        if (this->ADVERTISEMENT_parser_)
          this->ADVERTISEMENT_parser_->pre ();
      }
      else
      {
        if (this->ADVERTISEMENT_parser_)
        {
          this->ADVERTISEMENT_parser_->post_ct_FINAL ();
          this->ADVERTISEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_FORMULA_pskel.
//
bool ct_FORMULA_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "IMAGE" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_FORMULA_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_FORMULA_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_FORMULA_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_FORMULA_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_FORMULA_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "IMAGE" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->IMAGE_parser_;

          if (this->IMAGE_parser_)
            this->IMAGE_parser_->pre ();
        }
        else
        {
          if (this->IMAGE_parser_)
          {
            this->IMAGE_parser_->post_ct_FINAL ();
            this->IMAGE ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_PARAGRAPH_pskel.
//
bool ct_PARAGRAPH_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXT" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_PARAGRAPH_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_PARAGRAPH_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_PARAGRAPH_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_PARAGRAPH_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_PARAGRAPH_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "TEXT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

          if (this->TEXT_parser_)
            this->TEXT_parser_->pre ();
        }
        else
        {
          if (this->TEXT_parser_)
          {
            this->TEXT_parser_->post_ct_FINAL ();
            this->TEXT ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_FOOTNOTE_PARAGRAPH_pskel.
//
bool ct_FOOTNOTE_PARAGRAPH_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXT" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_FOOTNOTE_PARAGRAPH_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_FOOTNOTE_PARAGRAPH_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_FOOTNOTE_PARAGRAPH_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_FOOTNOTE_PARAGRAPH_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ct_FOOTNOTE_PARAGRAPH_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "TEXT" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

          if (this->TEXT_parser_)
            this->TEXT_parser_->pre ();
        }
        else
        {
          if (this->TEXT_parser_)
          {
            this->TEXT_parser_->post_ct_FINAL ();
            this->TEXT ();
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_FINAL_pskel.
//
bool ct_FINAL_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "fptr" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_FINAL_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "fptr",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_FINAL_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_FINAL_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_FINAL_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "fptr");

  this->v_state_stack_.pop ();
}

void ct_FINAL_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "fptr" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->fptr_parser_;

          if (this->fptr_parser_)
            this->fptr_parser_->pre ();
        }
        else
        {
          if (this->fptr_parser_)
          {
            this->fptr_parser_->post_ct_FPTR ();
            this->fptr ();
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "fptr",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ct_FPTR_pskel.
//
bool ct_FPTR_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "area" && ns.empty ())
        s = 0UL;
      else if (n == "seq" && ns.empty ())
        s = 1UL;
      else if (n == "par" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ct_FPTR_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "area",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_FPTR_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_FPTR_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_FPTR_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "area");

  this->v_state_stack_.pop ();
}

void ct_FPTR_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

        if (this->area_parser_)
          this->area_parser_->pre ();
      }
      else
      {
        if (this->area_parser_)
        {
          this->area_parser_->post_any_type ();
          this->area ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->seq_parser_;

        if (this->seq_parser_)
          this->seq_parser_->pre ();
      }
      else
      {
        if (this->seq_parser_)
        {
          this->seq_parser_->post_ct_SEQ ();
          this->seq ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->par_parser_;

        if (this->par_parser_)
          this->par_parser_->pre ();
      }
      else
      {
        if (this->par_parser_)
        {
          this->par_parser_->post_par ();
          this->par ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for ct_SEQ_pskel.
//
bool ct_SEQ_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "area" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &ct_SEQ_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "area",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ct_SEQ_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ct_SEQ_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ct_SEQ_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "area");

  this->v_state_stack_.pop ();
}

void ct_SEQ_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

        if (this->area_parser_)
          this->area_parser_->pre ();
      }
      else
      {
        if (this->area_parser_)
        {
          this->area_parser_->post_any_type ();
          this->area ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for Newspaper_pskel.
//
bool Newspaper_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "VOLUME" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &Newspaper_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "VOLUME",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool Newspaper_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void Newspaper_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void Newspaper_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "VOLUME");

  this->v_state_stack_.pop ();
}

void Newspaper_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "VOLUME" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->VOLUME_parser_;

          if (this->VOLUME_parser_)
            this->VOLUME_parser_->pre ();
        }
        else
        {
          if (this->VOLUME_parser_)
          {
            this->VOLUME_parser_->post_ct_HIERARCHY ();
            this->VOLUME ();
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "VOLUME",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for TITLE_SECTION_pskel.
//
bool TITLE_SECTION_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "TABLE_OF_CONTENTS" && ns.empty ())
        s = 2UL;
      else if (n == "PAGE_NUMBER" && ns.empty ())
        s = 3UL;
      else if (n == "ILLUSTRATION" && ns.empty ())
        s = 4UL;
      else if (n == "SUBHEADLINE" && ns.empty ())
        s = 5UL;
      else if (n == "OVERLINE" && ns.empty ())
        s = 6UL;
      else if (n == "HEADLINE" && ns.empty ())
        s = 7UL;
      else if (n == "MOTTO" && ns.empty ())
        s = 8UL;
      else if (n == "CONTINUATION_HEADLINE" && ns.empty ())
        s = 9UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &TITLE_SECTION_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool TITLE_SECTION_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void TITLE_SECTION_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void TITLE_SECTION_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void TITLE_SECTION_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

        if (this->TABLE_OF_CONTENTS_parser_)
          this->TABLE_OF_CONTENTS_parser_->pre ();
      }
      else
      {
        if (this->TABLE_OF_CONTENTS_parser_)
        {
          this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
          this->TABLE_OF_CONTENTS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PAGE_NUMBER_parser_;

        if (this->PAGE_NUMBER_parser_)
          this->PAGE_NUMBER_parser_->pre ();
      }
      else
      {
        if (this->PAGE_NUMBER_parser_)
        {
          this->PAGE_NUMBER_parser_->post_ct_FINAL ();
          this->PAGE_NUMBER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

        if (this->ILLUSTRATION_parser_)
          this->ILLUSTRATION_parser_->pre ();
      }
      else
      {
        if (this->ILLUSTRATION_parser_)
        {
          this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
          this->ILLUSTRATION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBHEADLINE_parser_;

        if (this->SUBHEADLINE_parser_)
          this->SUBHEADLINE_parser_->pre ();
      }
      else
      {
        if (this->SUBHEADLINE_parser_)
        {
          this->SUBHEADLINE_parser_->post_ct_FINAL ();
          this->SUBHEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->OVERLINE_parser_;

        if (this->OVERLINE_parser_)
          this->OVERLINE_parser_->pre ();
      }
      else
      {
        if (this->OVERLINE_parser_)
        {
          this->OVERLINE_parser_->post_ct_FINAL ();
          this->OVERLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADLINE_parser_;

        if (this->HEADLINE_parser_)
          this->HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->HEADLINE_parser_)
        {
          this->HEADLINE_parser_->post_ct_FINAL ();
          this->HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 8UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->MOTTO_parser_;

        if (this->MOTTO_parser_)
          this->MOTTO_parser_->pre ();
      }
      else
      {
        if (this->MOTTO_parser_)
        {
          this->MOTTO_parser_->post_ct_FINAL ();
          this->MOTTO ();
        }

        state = ~0UL;
      }

      break;
    }
    case 9UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_HEADLINE_parser_;

        if (this->CONTINUATION_HEADLINE_parser_)
          this->CONTINUATION_HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_HEADLINE_parser_)
        {
          this->CONTINUATION_HEADLINE_parser_->post_ct_FINAL ();
          this->CONTINUATION_HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for CONTENT_pskel.
//
bool CONTENT_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "SECTION" && ns.empty ())
        s = 2UL;
      else if (n == "PARAGRAPH" && ns.empty ())
        s = 3UL;
      else if (n == "NECROLOGY" && ns.empty ())
        s = 4UL;
      else if (n == "WEATHER" && ns.empty ())
        s = 5UL;
      else if (n == "SHIPPING" && ns.empty ())
        s = 6UL;
      else if (n == "RIDAS" && ns.empty ())
        s = 7UL;
      else if (n == "LETTER" && ns.empty ())
        s = 8UL;
      else if (n == "INTERVIEW" && ns.empty ())
        s = 9UL;
      else if (n == "IMPRINT" && ns.empty ())
        s = 10UL;
      else if (n == "ARTICLE" && ns.empty ())
        s = 11UL;
      else if (n == "ACKNOWLEDGEMENT" && ns.empty ())
        s = 12UL;
      else if (n == "MARRIAGE" && ns.empty ())
        s = 13UL;
      else if (n == "DEATH_NOTICE" && ns.empty ())
        s = 14UL;
      else if (n == "BIRTH" && ns.empty ())
        s = 15UL;
      else if (n == "ADVERTISEMENT" && ns.empty ())
        s = 16UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &CONTENT_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool CONTENT_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void CONTENT_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void CONTENT_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void CONTENT_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SECTION_parser_;

        if (this->SECTION_parser_)
          this->SECTION_parser_->pre ();
      }
      else
      {
        if (this->SECTION_parser_)
        {
          this->SECTION_parser_->post_ct_SECTION ();
          this->SECTION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

        if (this->PARAGRAPH_parser_)
          this->PARAGRAPH_parser_->pre ();
      }
      else
      {
        if (this->PARAGRAPH_parser_)
        {
          this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
          this->PARAGRAPH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

        if (this->NECROLOGY_parser_)
          this->NECROLOGY_parser_->pre ();
      }
      else
      {
        if (this->NECROLOGY_parser_)
        {
          this->NECROLOGY_parser_->post_ct_ARTICLE_LIKE ();
          this->NECROLOGY ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->WEATHER_parser_;

        if (this->WEATHER_parser_)
          this->WEATHER_parser_->pre ();
      }
      else
      {
        if (this->WEATHER_parser_)
        {
          this->WEATHER_parser_->post_ct_ARTICLE_LIKE ();
          this->WEATHER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SHIPPING_parser_;

        if (this->SHIPPING_parser_)
          this->SHIPPING_parser_->pre ();
      }
      else
      {
        if (this->SHIPPING_parser_)
        {
          this->SHIPPING_parser_->post_ct_ARTICLE_LIKE ();
          this->SHIPPING ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

        if (this->RIDAS_parser_)
          this->RIDAS_parser_->pre ();
      }
      else
      {
        if (this->RIDAS_parser_)
        {
          this->RIDAS_parser_->post_ct_ARTICLE_LIKE ();
          this->RIDAS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 8UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LETTER_parser_;

        if (this->LETTER_parser_)
          this->LETTER_parser_->pre ();
      }
      else
      {
        if (this->LETTER_parser_)
        {
          this->LETTER_parser_->post_ct_ARTICLE_LIKE ();
          this->LETTER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 9UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->INTERVIEW_parser_;

        if (this->INTERVIEW_parser_)
          this->INTERVIEW_parser_->pre ();
      }
      else
      {
        if (this->INTERVIEW_parser_)
        {
          this->INTERVIEW_parser_->post_ct_ARTICLE_LIKE ();
          this->INTERVIEW ();
        }

        state = ~0UL;
      }

      break;
    }
    case 10UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->IMPRINT_parser_;

        if (this->IMPRINT_parser_)
          this->IMPRINT_parser_->pre ();
      }
      else
      {
        if (this->IMPRINT_parser_)
        {
          this->IMPRINT_parser_->post_ct_ARTICLE_LIKE ();
          this->IMPRINT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 11UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ARTICLE_parser_;

        if (this->ARTICLE_parser_)
          this->ARTICLE_parser_->pre ();
      }
      else
      {
        if (this->ARTICLE_parser_)
        {
          this->ARTICLE_parser_->post_ct_ARTICLE_LIKE ();
          this->ARTICLE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 12UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENT_parser_;

        if (this->ACKNOWLEDGEMENT_parser_)
          this->ACKNOWLEDGEMENT_parser_->pre ();
      }
      else
      {
        if (this->ACKNOWLEDGEMENT_parser_)
        {
          this->ACKNOWLEDGEMENT_parser_->post_ct_ARTICLE_LIKE ();
          this->ACKNOWLEDGEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 13UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->MARRIAGE_parser_;

        if (this->MARRIAGE_parser_)
          this->MARRIAGE_parser_->pre ();
      }
      else
      {
        if (this->MARRIAGE_parser_)
        {
          this->MARRIAGE_parser_->post_ct_FINAL ();
          this->MARRIAGE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 14UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->DEATH_NOTICE_parser_;

        if (this->DEATH_NOTICE_parser_)
          this->DEATH_NOTICE_parser_->pre ();
      }
      else
      {
        if (this->DEATH_NOTICE_parser_)
        {
          this->DEATH_NOTICE_parser_->post_ct_FINAL ();
          this->DEATH_NOTICE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 15UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->BIRTH_parser_;

        if (this->BIRTH_parser_)
          this->BIRTH_parser_->pre ();
      }
      else
      {
        if (this->BIRTH_parser_)
        {
          this->BIRTH_parser_->post_ct_FINAL ();
          this->BIRTH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 16UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ADVERTISEMENT_parser_;

        if (this->ADVERTISEMENT_parser_)
          this->ADVERTISEMENT_parser_->pre ();
      }
      else
      {
        if (this->ADVERTISEMENT_parser_)
        {
          this->ADVERTISEMENT_parser_->post_ct_FINAL ();
          this->ADVERTISEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for TITLE_SECTION1_pskel.
//
bool TITLE_SECTION1_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "TABLE_OF_CONTENTS" && ns.empty ())
        s = 2UL;
      else if (n == "PAGE_NUMBER" && ns.empty ())
        s = 3UL;
      else if (n == "ILLUSTRATION" && ns.empty ())
        s = 4UL;
      else if (n == "SUBHEADLINE" && ns.empty ())
        s = 5UL;
      else if (n == "OVERLINE" && ns.empty ())
        s = 6UL;
      else if (n == "HEADLINE" && ns.empty ())
        s = 7UL;
      else if (n == "MOTTO" && ns.empty ())
        s = 8UL;
      else if (n == "CONTINUATION_HEADLINE" && ns.empty ())
        s = 9UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &TITLE_SECTION1_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool TITLE_SECTION1_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void TITLE_SECTION1_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void TITLE_SECTION1_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void TITLE_SECTION1_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

        if (this->TABLE_OF_CONTENTS_parser_)
          this->TABLE_OF_CONTENTS_parser_->pre ();
      }
      else
      {
        if (this->TABLE_OF_CONTENTS_parser_)
        {
          this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
          this->TABLE_OF_CONTENTS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PAGE_NUMBER_parser_;

        if (this->PAGE_NUMBER_parser_)
          this->PAGE_NUMBER_parser_->pre ();
      }
      else
      {
        if (this->PAGE_NUMBER_parser_)
        {
          this->PAGE_NUMBER_parser_->post_ct_FINAL ();
          this->PAGE_NUMBER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

        if (this->ILLUSTRATION_parser_)
          this->ILLUSTRATION_parser_->pre ();
      }
      else
      {
        if (this->ILLUSTRATION_parser_)
        {
          this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
          this->ILLUSTRATION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBHEADLINE_parser_;

        if (this->SUBHEADLINE_parser_)
          this->SUBHEADLINE_parser_->pre ();
      }
      else
      {
        if (this->SUBHEADLINE_parser_)
        {
          this->SUBHEADLINE_parser_->post_ct_FINAL ();
          this->SUBHEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->OVERLINE_parser_;

        if (this->OVERLINE_parser_)
          this->OVERLINE_parser_->pre ();
      }
      else
      {
        if (this->OVERLINE_parser_)
        {
          this->OVERLINE_parser_->post_ct_FINAL ();
          this->OVERLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADLINE_parser_;

        if (this->HEADLINE_parser_)
          this->HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->HEADLINE_parser_)
        {
          this->HEADLINE_parser_->post_ct_FINAL ();
          this->HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 8UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->MOTTO_parser_;

        if (this->MOTTO_parser_)
          this->MOTTO_parser_->pre ();
      }
      else
      {
        if (this->MOTTO_parser_)
        {
          this->MOTTO_parser_->post_ct_FINAL ();
          this->MOTTO ();
        }

        state = ~0UL;
      }

      break;
    }
    case 9UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTINUATION_HEADLINE_parser_;

        if (this->CONTINUATION_HEADLINE_parser_)
          this->CONTINUATION_HEADLINE_parser_->pre ();
      }
      else
      {
        if (this->CONTINUATION_HEADLINE_parser_)
        {
          this->CONTINUATION_HEADLINE_parser_->post_ct_FINAL ();
          this->CONTINUATION_HEADLINE ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for CONTENT1_pskel.
//
bool CONTENT1_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "SECTION" && ns.empty ())
        s = 2UL;
      else if (n == "PARAGRAPH" && ns.empty ())
        s = 3UL;
      else if (n == "NECROLOGY" && ns.empty ())
        s = 4UL;
      else if (n == "WEATHER" && ns.empty ())
        s = 5UL;
      else if (n == "SHIPPING" && ns.empty ())
        s = 6UL;
      else if (n == "RIDAS" && ns.empty ())
        s = 7UL;
      else if (n == "LETTER" && ns.empty ())
        s = 8UL;
      else if (n == "INTERVIEW" && ns.empty ())
        s = 9UL;
      else if (n == "IMPRINT" && ns.empty ())
        s = 10UL;
      else if (n == "ARTICLE" && ns.empty ())
        s = 11UL;
      else if (n == "ACKNOWLEDGEMENT" && ns.empty ())
        s = 12UL;
      else if (n == "MARRIAGE" && ns.empty ())
        s = 13UL;
      else if (n == "DEATH_NOTICE" && ns.empty ())
        s = 14UL;
      else if (n == "BIRTH" && ns.empty ())
        s = 15UL;
      else if (n == "ADVERTISEMENT" && ns.empty ())
        s = 16UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &CONTENT1_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool CONTENT1_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void CONTENT1_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void CONTENT1_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void CONTENT1_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SECTION_parser_;

        if (this->SECTION_parser_)
          this->SECTION_parser_->pre ();
      }
      else
      {
        if (this->SECTION_parser_)
        {
          this->SECTION_parser_->post_ct_SECTION ();
          this->SECTION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

        if (this->PARAGRAPH_parser_)
          this->PARAGRAPH_parser_->pre ();
      }
      else
      {
        if (this->PARAGRAPH_parser_)
        {
          this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
          this->PARAGRAPH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

        if (this->NECROLOGY_parser_)
          this->NECROLOGY_parser_->pre ();
      }
      else
      {
        if (this->NECROLOGY_parser_)
        {
          this->NECROLOGY_parser_->post_ct_ARTICLE_LIKE ();
          this->NECROLOGY ();
        }

        state = ~0UL;
      }

      break;
    }
    case 5UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->WEATHER_parser_;

        if (this->WEATHER_parser_)
          this->WEATHER_parser_->pre ();
      }
      else
      {
        if (this->WEATHER_parser_)
        {
          this->WEATHER_parser_->post_ct_ARTICLE_LIKE ();
          this->WEATHER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 6UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->SHIPPING_parser_;

        if (this->SHIPPING_parser_)
          this->SHIPPING_parser_->pre ();
      }
      else
      {
        if (this->SHIPPING_parser_)
        {
          this->SHIPPING_parser_->post_ct_ARTICLE_LIKE ();
          this->SHIPPING ();
        }

        state = ~0UL;
      }

      break;
    }
    case 7UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

        if (this->RIDAS_parser_)
          this->RIDAS_parser_->pre ();
      }
      else
      {
        if (this->RIDAS_parser_)
        {
          this->RIDAS_parser_->post_ct_ARTICLE_LIKE ();
          this->RIDAS ();
        }

        state = ~0UL;
      }

      break;
    }
    case 8UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->LETTER_parser_;

        if (this->LETTER_parser_)
          this->LETTER_parser_->pre ();
      }
      else
      {
        if (this->LETTER_parser_)
        {
          this->LETTER_parser_->post_ct_ARTICLE_LIKE ();
          this->LETTER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 9UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->INTERVIEW_parser_;

        if (this->INTERVIEW_parser_)
          this->INTERVIEW_parser_->pre ();
      }
      else
      {
        if (this->INTERVIEW_parser_)
        {
          this->INTERVIEW_parser_->post_ct_ARTICLE_LIKE ();
          this->INTERVIEW ();
        }

        state = ~0UL;
      }

      break;
    }
    case 10UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->IMPRINT_parser_;

        if (this->IMPRINT_parser_)
          this->IMPRINT_parser_->pre ();
      }
      else
      {
        if (this->IMPRINT_parser_)
        {
          this->IMPRINT_parser_->post_ct_ARTICLE_LIKE ();
          this->IMPRINT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 11UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ARTICLE_parser_;

        if (this->ARTICLE_parser_)
          this->ARTICLE_parser_->pre ();
      }
      else
      {
        if (this->ARTICLE_parser_)
        {
          this->ARTICLE_parser_->post_ct_ARTICLE_LIKE ();
          this->ARTICLE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 12UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENT_parser_;

        if (this->ACKNOWLEDGEMENT_parser_)
          this->ACKNOWLEDGEMENT_parser_->pre ();
      }
      else
      {
        if (this->ACKNOWLEDGEMENT_parser_)
        {
          this->ACKNOWLEDGEMENT_parser_->post_ct_ARTICLE_LIKE ();
          this->ACKNOWLEDGEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 13UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->MARRIAGE_parser_;

        if (this->MARRIAGE_parser_)
          this->MARRIAGE_parser_->pre ();
      }
      else
      {
        if (this->MARRIAGE_parser_)
        {
          this->MARRIAGE_parser_->post_ct_FINAL ();
          this->MARRIAGE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 14UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->DEATH_NOTICE_parser_;

        if (this->DEATH_NOTICE_parser_)
          this->DEATH_NOTICE_parser_->pre ();
      }
      else
      {
        if (this->DEATH_NOTICE_parser_)
        {
          this->DEATH_NOTICE_parser_->post_ct_FINAL ();
          this->DEATH_NOTICE ();
        }

        state = ~0UL;
      }

      break;
    }
    case 15UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->BIRTH_parser_;

        if (this->BIRTH_parser_)
          this->BIRTH_parser_->pre ();
      }
      else
      {
        if (this->BIRTH_parser_)
        {
          this->BIRTH_parser_->post_ct_FINAL ();
          this->BIRTH ();
        }

        state = ~0UL;
      }

      break;
    }
    case 16UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ADVERTISEMENT_parser_;

        if (this->ADVERTISEMENT_parser_)
          this->ADVERTISEMENT_parser_->pre ();
      }
      else
      {
        if (this->ADVERTISEMENT_parser_)
        {
          this->ADVERTISEMENT_parser_->post_ct_FINAL ();
          this->ADVERTISEMENT ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for DATA_pskel.
//
bool DATA_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "TEXTBLOCK" && ns.empty ())
        s = 0UL;
      else if (n == "PUBLISHING_STMT" && ns.empty ())
        s = 1UL;
      else if (n == "PAGE_NUMBER" && ns.empty ())
        s = 2UL;
      else if (n == "ITEM_CAPTION" && ns.empty ())
        s = 3UL;
      else if (n == "AUTHOR" && ns.empty ())
        s = 4UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &DATA_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DATA_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DATA_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DATA_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void DATA_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

        if (this->TEXTBLOCK_parser_)
          this->TEXTBLOCK_parser_->pre ();
      }
      else
      {
        if (this->TEXTBLOCK_parser_)
        {
          this->TEXTBLOCK_parser_->post_ct_FINAL ();
          this->TEXTBLOCK ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

        if (this->PUBLISHING_STMT_parser_)
          this->PUBLISHING_STMT_parser_->pre ();
      }
      else
      {
        if (this->PUBLISHING_STMT_parser_)
        {
          this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
          this->PUBLISHING_STMT ();
        }

        state = ~0UL;
      }

      break;
    }
    case 2UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->PAGE_NUMBER_parser_;

        if (this->PAGE_NUMBER_parser_)
          this->PAGE_NUMBER_parser_->pre ();
      }
      else
      {
        if (this->PAGE_NUMBER_parser_)
        {
          this->PAGE_NUMBER_parser_->post_ct_FINAL ();
          this->PAGE_NUMBER ();
        }

        state = ~0UL;
      }

      break;
    }
    case 3UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_CAPTION_parser_;

        if (this->ITEM_CAPTION_parser_)
          this->ITEM_CAPTION_parser_->pre ();
      }
      else
      {
        if (this->ITEM_CAPTION_parser_)
        {
          this->ITEM_CAPTION_parser_->post_ct_FINAL ();
          this->ITEM_CAPTION ();
        }

        state = ~0UL;
      }

      break;
    }
    case 4UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

        if (this->AUTHOR_parser_)
          this->AUTHOR_parser_->pre ();
      }
      else
      {
        if (this->AUTHOR_parser_)
        {
          this->AUTHOR_parser_->post_ct_FINAL ();
          this->AUTHOR ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Element validation and dispatch functions for par_pskel.
//
bool par_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "area" && ns.empty ())
        s = 0UL;
      else if (n == "seq" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;

        vd = vs.data + vs.size++;
        vd->func = &par_pskel::choice_0;
        vd->state = s;
        vd->count = 0;

        this->choice_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 2UL)
          this->_expected_element (
            "", "area",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool par_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void par_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void par_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 2UL)
    this->_expected_element (
      "", "area");

  this->v_state_stack_.pop ();
}

void par_pskel::
choice_0 (unsigned long& state,
          unsigned long& count,
          const ::xml_schema::ro_string& ns,
          const ::xml_schema::ro_string& n,
          const ::xml_schema::ro_string* t,
          bool start)
{
  XSD_UNUSED (count);
  XSD_UNUSED (ns);
  XSD_UNUSED (n);
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

        if (this->area_parser_)
          this->area_parser_->pre ();
      }
      else
      {
        if (this->area_parser_)
        {
          this->area_parser_->post_any_type ();
          this->area ();
        }

        state = ~0UL;
      }

      break;
    }
    case 1UL:
    {
      if (start)
      {
        this->::xml_schema::complex_content::context_.top ().parser_ = this->seq_parser_;

        if (this->seq_parser_)
          this->seq_parser_->pre ();
      }
      else
      {
        if (this->seq_parser_)
        {
          this->seq_parser_->post_ct_SEQ ();
          this->seq ();
        }

        state = ~0UL;
      }

      break;
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

