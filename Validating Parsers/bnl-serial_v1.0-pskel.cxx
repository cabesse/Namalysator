// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "bnl-serial_v1.0-pskel.hxx"

// ct_HIERARCHY_pskel
//
namespace bnl_serial_v1_0
{
	void ct_HIERARCHY_pskel::
	FRONT_parser (::bnl_serial_v1_0::ct_FRONT_pskel& p)
	{
	  this->FRONT_parser_ = &p;
	}

	void ct_HIERARCHY_pskel::
	ISSUE_parser (::bnl_serial_v1_0::ct_ISSUE_pskel& p)
	{
	  this->ISSUE_parser_ = &p;
	}

	void ct_HIERARCHY_pskel::
	BACK_parser (::bnl_serial_v1_0::ct_BACK_pskel& p)
	{
	  this->BACK_parser_ = &p;
	}

	void ct_HIERARCHY_pskel::
	parsers (::bnl_serial_v1_0::ct_FRONT_pskel& FRONT,
			 ::bnl_serial_v1_0::ct_ISSUE_pskel& ISSUE,
			 ::bnl_serial_v1_0::ct_BACK_pskel& BACK)
	{
	  this->FRONT_parser_ = &FRONT;
	  this->ISSUE_parser_ = &ISSUE;
	  this->BACK_parser_ = &BACK;
	}

	ct_HIERARCHY_pskel::
	ct_HIERARCHY_pskel ()
	: FRONT_parser_ (0),
	  ISSUE_parser_ (0),
	  BACK_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_FRONT_pskel
	//

	void ct_FRONT_pskel::
	TITLE_SECTION_parser (::bnl_serial_v1_0::ct_TITLE_SECTION_pskel& p)
	{
	  this->TITLE_SECTION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	STATEMENT_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->STATEMENT_SECTION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	PICTURE_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->PICTURE_SECTION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	FRONTISPIECE_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->FRONTISPIECE_parser_ = &p;
	}

	void ct_FRONT_pskel::
	COVER_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->COVER_SECTION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	BASTARD_TITLE_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->BASTARD_TITLE_SECTION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->TABLE_OF_CONTENTS_parser_ = &p;
	}

	void ct_FRONT_pskel::
	REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->REFERENCE_LIST_parser_ = &p;
	}

	void ct_FRONT_pskel::
	LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_PUBLICATIONS_parser_ = &p;
	}

	void ct_FRONT_pskel::
	LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_FIGURES_parser_ = &p;
	}

	void ct_FRONT_pskel::
	INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->INDEX_parser_ = &p;
	}

	void ct_FRONT_pskel::
	CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->CORRECTIONS_parser_ = &p;
	}

	void ct_FRONT_pskel::
	BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->BIBLIOGRAPHY_parser_ = &p;
	}

	void ct_FRONT_pskel::
	ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->ABBREVIATIONS_parser_ = &p;
	}

	void ct_FRONT_pskel::
	RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->RIDAS_parser_ = &p;
	}

	void ct_FRONT_pskel::
	PRODUCTION_NOTE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->PRODUCTION_NOTE_parser_ = &p;
	}

	void ct_FRONT_pskel::
	PREFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->PREFACE_parser_ = &p;
	}

	void ct_FRONT_pskel::
	NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->NECROLOGY_parser_ = &p;
	}

	void ct_FRONT_pskel::
	INTRODUCTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->INTRODUCTION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	DEDICATION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->DEDICATION_parser_ = &p;
	}

	void ct_FRONT_pskel::
	CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->CHAPTER_parser_ = &p;
	}

	void ct_FRONT_pskel::
	ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ACKNOWLEDGEMENTS_parser_ = &p;
	}

	void ct_FRONT_pskel::
	ABSTRACT_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ABSTRACT_parser_ = &p;
	}

	void ct_FRONT_pskel::
	ADVERTISEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->ADVERTISEMENT_parser_ = &p;
	}

	void ct_FRONT_pskel::
	parsers (::bnl_serial_v1_0::ct_TITLE_SECTION_pskel& TITLE_SECTION,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& STATEMENT_SECTION,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& PICTURE_SECTION,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& FRONTISPIECE,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& COVER_SECTION,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& BASTARD_TITLE_SECTION,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& REFERENCE_LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_PUBLICATIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_FIGURES,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& INDEX,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& CORRECTIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& BIBLIOGRAPHY,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& ABBREVIATIONS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& RIDAS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& PRODUCTION_NOTE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& PREFACE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& NECROLOGY,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& INTRODUCTION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& DEDICATION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& CHAPTER,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ACKNOWLEDGEMENTS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ABSTRACT,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& ADVERTISEMENT)
	{
	  this->TITLE_SECTION_parser_ = &TITLE_SECTION;
	  this->STATEMENT_SECTION_parser_ = &STATEMENT_SECTION;
	  this->PICTURE_SECTION_parser_ = &PICTURE_SECTION;
	  this->FRONTISPIECE_parser_ = &FRONTISPIECE;
	  this->COVER_SECTION_parser_ = &COVER_SECTION;
	  this->BASTARD_TITLE_SECTION_parser_ = &BASTARD_TITLE_SECTION;
	  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
	  this->REFERENCE_LIST_parser_ = &REFERENCE_LIST;
	  this->LIST_OF_PUBLICATIONS_parser_ = &LIST_OF_PUBLICATIONS;
	  this->LIST_OF_FIGURES_parser_ = &LIST_OF_FIGURES;
	  this->INDEX_parser_ = &INDEX;
	  this->CORRECTIONS_parser_ = &CORRECTIONS;
	  this->BIBLIOGRAPHY_parser_ = &BIBLIOGRAPHY;
	  this->ABBREVIATIONS_parser_ = &ABBREVIATIONS;
	  this->RIDAS_parser_ = &RIDAS;
	  this->PRODUCTION_NOTE_parser_ = &PRODUCTION_NOTE;
	  this->PREFACE_parser_ = &PREFACE;
	  this->NECROLOGY_parser_ = &NECROLOGY;
	  this->INTRODUCTION_parser_ = &INTRODUCTION;
	  this->DEDICATION_parser_ = &DEDICATION;
	  this->CHAPTER_parser_ = &CHAPTER;
	  this->ACKNOWLEDGEMENTS_parser_ = &ACKNOWLEDGEMENTS;
	  this->ABSTRACT_parser_ = &ABSTRACT;
	  this->ADVERTISEMENT_parser_ = &ADVERTISEMENT;
	}

	ct_FRONT_pskel::
	ct_FRONT_pskel ()
	: TITLE_SECTION_parser_ (0),
	  STATEMENT_SECTION_parser_ (0),
	  PICTURE_SECTION_parser_ (0),
	  FRONTISPIECE_parser_ (0),
	  COVER_SECTION_parser_ (0),
	  BASTARD_TITLE_SECTION_parser_ (0),
	  TABLE_OF_CONTENTS_parser_ (0),
	  REFERENCE_LIST_parser_ (0),
	  LIST_OF_PUBLICATIONS_parser_ (0),
	  LIST_OF_FIGURES_parser_ (0),
	  INDEX_parser_ (0),
	  CORRECTIONS_parser_ (0),
	  BIBLIOGRAPHY_parser_ (0),
	  ABBREVIATIONS_parser_ (0),
	  RIDAS_parser_ (0),
	  PRODUCTION_NOTE_parser_ (0),
	  PREFACE_parser_ (0),
	  NECROLOGY_parser_ (0),
	  INTRODUCTION_parser_ (0),
	  DEDICATION_parser_ (0),
	  CHAPTER_parser_ (0),
	  ACKNOWLEDGEMENTS_parser_ (0),
	  ABSTRACT_parser_ (0),
	  ADVERTISEMENT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_MAIN_pskel
	//

	void ct_MAIN_pskel::
	TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->TABLE_OF_CONTENTS_parser_ = &p;
	}

	void ct_MAIN_pskel::
	REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->REFERENCE_LIST_parser_ = &p;
	}

	void ct_MAIN_pskel::
	LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_PUBLICATIONS_parser_ = &p;
	}

	void ct_MAIN_pskel::
	LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_FIGURES_parser_ = &p;
	}

	void ct_MAIN_pskel::
	LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_parser_ = &p;
	}

	void ct_MAIN_pskel::
	INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->INDEX_parser_ = &p;
	}

	void ct_MAIN_pskel::
	CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->CORRECTIONS_parser_ = &p;
	}

	void ct_MAIN_pskel::
	BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->BIBLIOGRAPHY_parser_ = &p;
	}

	void ct_MAIN_pskel::
	ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->ABBREVIATIONS_parser_ = &p;
	}

	void ct_MAIN_pskel::
	RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->RIDAS_parser_ = &p;
	}

	void ct_MAIN_pskel::
	PRODUCTION_NOTE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->PRODUCTION_NOTE_parser_ = &p;
	}

	void ct_MAIN_pskel::
	PREFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->PREFACE_parser_ = &p;
	}

	void ct_MAIN_pskel::
	POSTFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->POSTFACE_parser_ = &p;
	}

	void ct_MAIN_pskel::
	POEM_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->POEM_parser_ = &p;
	}

	void ct_MAIN_pskel::
	NOTES_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->NOTES_parser_ = &p;
	}

	void ct_MAIN_pskel::
	NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->NECROLOGY_parser_ = &p;
	}

	void ct_MAIN_pskel::
	INTRODUCTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->INTRODUCTION_parser_ = &p;
	}

	void ct_MAIN_pskel::
	GROUP_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->GROUP_parser_ = &p;
	}

	void ct_MAIN_pskel::
	DEDICATION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->DEDICATION_parser_ = &p;
	}

	void ct_MAIN_pskel::
	DEBATE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->DEBATE_parser_ = &p;
	}

	void ct_MAIN_pskel::
	CONTRIBUTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->CONTRIBUTION_parser_ = &p;
	}

	void ct_MAIN_pskel::
	CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->CHAPTER_parser_ = &p;
	}

	void ct_MAIN_pskel::
	BOOK_REVIEW_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->BOOK_REVIEW_parser_ = &p;
	}

	void ct_MAIN_pskel::
	APPENDIX_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->APPENDIX_parser_ = &p;
	}

	void ct_MAIN_pskel::
	ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ACKNOWLEDGEMENTS_parser_ = &p;
	}

	void ct_MAIN_pskel::
	ABSTRACT_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ABSTRACT_parser_ = &p;
	}

	void ct_MAIN_pskel::
	ADVERTISEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->ADVERTISEMENT_parser_ = &p;
	}

	void ct_MAIN_pskel::
	parsers (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& REFERENCE_LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_PUBLICATIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_FIGURES,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& INDEX,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& CORRECTIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& BIBLIOGRAPHY,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& ABBREVIATIONS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& RIDAS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& PRODUCTION_NOTE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& PREFACE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& POSTFACE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& POEM,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& NOTES,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& NECROLOGY,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& INTRODUCTION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& GROUP,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& DEDICATION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& DEBATE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& CONTRIBUTION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& CHAPTER,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& BOOK_REVIEW,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& APPENDIX,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ACKNOWLEDGEMENTS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ABSTRACT,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& ADVERTISEMENT)
	{
	  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
	  this->REFERENCE_LIST_parser_ = &REFERENCE_LIST;
	  this->LIST_OF_PUBLICATIONS_parser_ = &LIST_OF_PUBLICATIONS;
	  this->LIST_OF_FIGURES_parser_ = &LIST_OF_FIGURES;
	  this->LIST_parser_ = &LIST;
	  this->INDEX_parser_ = &INDEX;
	  this->CORRECTIONS_parser_ = &CORRECTIONS;
	  this->BIBLIOGRAPHY_parser_ = &BIBLIOGRAPHY;
	  this->ABBREVIATIONS_parser_ = &ABBREVIATIONS;
	  this->RIDAS_parser_ = &RIDAS;
	  this->PRODUCTION_NOTE_parser_ = &PRODUCTION_NOTE;
	  this->PREFACE_parser_ = &PREFACE;
	  this->POSTFACE_parser_ = &POSTFACE;
	  this->POEM_parser_ = &POEM;
	  this->NOTES_parser_ = &NOTES;
	  this->NECROLOGY_parser_ = &NECROLOGY;
	  this->INTRODUCTION_parser_ = &INTRODUCTION;
	  this->GROUP_parser_ = &GROUP;
	  this->DEDICATION_parser_ = &DEDICATION;
	  this->DEBATE_parser_ = &DEBATE;
	  this->CONTRIBUTION_parser_ = &CONTRIBUTION;
	  this->CHAPTER_parser_ = &CHAPTER;
	  this->BOOK_REVIEW_parser_ = &BOOK_REVIEW;
	  this->APPENDIX_parser_ = &APPENDIX;
	  this->ACKNOWLEDGEMENTS_parser_ = &ACKNOWLEDGEMENTS;
	  this->ABSTRACT_parser_ = &ABSTRACT;
	  this->ADVERTISEMENT_parser_ = &ADVERTISEMENT;
	}

	ct_MAIN_pskel::
	ct_MAIN_pskel ()
	: TABLE_OF_CONTENTS_parser_ (0),
	  REFERENCE_LIST_parser_ (0),
	  LIST_OF_PUBLICATIONS_parser_ (0),
	  LIST_OF_FIGURES_parser_ (0),
	  LIST_parser_ (0),
	  INDEX_parser_ (0),
	  CORRECTIONS_parser_ (0),
	  BIBLIOGRAPHY_parser_ (0),
	  ABBREVIATIONS_parser_ (0),
	  RIDAS_parser_ (0),
	  PRODUCTION_NOTE_parser_ (0),
	  PREFACE_parser_ (0),
	  POSTFACE_parser_ (0),
	  POEM_parser_ (0),
	  NOTES_parser_ (0),
	  NECROLOGY_parser_ (0),
	  INTRODUCTION_parser_ (0),
	  GROUP_parser_ (0),
	  DEDICATION_parser_ (0),
	  DEBATE_parser_ (0),
	  CONTRIBUTION_parser_ (0),
	  CHAPTER_parser_ (0),
	  BOOK_REVIEW_parser_ (0),
	  APPENDIX_parser_ (0),
	  ACKNOWLEDGEMENTS_parser_ (0),
	  ABSTRACT_parser_ (0),
	  ADVERTISEMENT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_BACK_pskel
	//

	void ct_BACK_pskel::
	STATEMENT_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->STATEMENT_SECTION_parser_ = &p;
	}

	void ct_BACK_pskel::
	PICTURE_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->PICTURE_SECTION_parser_ = &p;
	}

	void ct_BACK_pskel::
	COVER_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& p)
	{
	  this->COVER_SECTION_parser_ = &p;
	}

	void ct_BACK_pskel::
	TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->TABLE_OF_CONTENTS_parser_ = &p;
	}

	void ct_BACK_pskel::
	REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->REFERENCE_LIST_parser_ = &p;
	}

	void ct_BACK_pskel::
	LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_PUBLICATIONS_parser_ = &p;
	}

	void ct_BACK_pskel::
	LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_FIGURES_parser_ = &p;
	}

	void ct_BACK_pskel::
	LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_parser_ = &p;
	}

	void ct_BACK_pskel::
	INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->INDEX_parser_ = &p;
	}

	void ct_BACK_pskel::
	CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->CORRECTIONS_parser_ = &p;
	}

	void ct_BACK_pskel::
	BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->BIBLIOGRAPHY_parser_ = &p;
	}

	void ct_BACK_pskel::
	ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->ABBREVIATIONS_parser_ = &p;
	}

	void ct_BACK_pskel::
	RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->RIDAS_parser_ = &p;
	}

	void ct_BACK_pskel::
	POSTFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->POSTFACE_parser_ = &p;
	}

	void ct_BACK_pskel::
	NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->NECROLOGY_parser_ = &p;
	}

	void ct_BACK_pskel::
	CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->CHAPTER_parser_ = &p;
	}

	void ct_BACK_pskel::
	APPENDIX_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->APPENDIX_parser_ = &p;
	}

	void ct_BACK_pskel::
	ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ACKNOWLEDGEMENTS_parser_ = &p;
	}

	void ct_BACK_pskel::
	ADVERTISEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->ADVERTISEMENT_parser_ = &p;
	}

	void ct_BACK_pskel::
	parsers (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& STATEMENT_SECTION,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& PICTURE_SECTION,
			 ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& COVER_SECTION,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& REFERENCE_LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_PUBLICATIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_FIGURES,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& INDEX,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& CORRECTIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& BIBLIOGRAPHY,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& ABBREVIATIONS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& RIDAS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& POSTFACE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& NECROLOGY,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& CHAPTER,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& APPENDIX,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ACKNOWLEDGEMENTS,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& ADVERTISEMENT)
	{
	  this->STATEMENT_SECTION_parser_ = &STATEMENT_SECTION;
	  this->PICTURE_SECTION_parser_ = &PICTURE_SECTION;
	  this->COVER_SECTION_parser_ = &COVER_SECTION;
	  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
	  this->REFERENCE_LIST_parser_ = &REFERENCE_LIST;
	  this->LIST_OF_PUBLICATIONS_parser_ = &LIST_OF_PUBLICATIONS;
	  this->LIST_OF_FIGURES_parser_ = &LIST_OF_FIGURES;
	  this->LIST_parser_ = &LIST;
	  this->INDEX_parser_ = &INDEX;
	  this->CORRECTIONS_parser_ = &CORRECTIONS;
	  this->BIBLIOGRAPHY_parser_ = &BIBLIOGRAPHY;
	  this->ABBREVIATIONS_parser_ = &ABBREVIATIONS;
	  this->RIDAS_parser_ = &RIDAS;
	  this->POSTFACE_parser_ = &POSTFACE;
	  this->NECROLOGY_parser_ = &NECROLOGY;
	  this->CHAPTER_parser_ = &CHAPTER;
	  this->APPENDIX_parser_ = &APPENDIX;
	  this->ACKNOWLEDGEMENTS_parser_ = &ACKNOWLEDGEMENTS;
	  this->ADVERTISEMENT_parser_ = &ADVERTISEMENT;
	}

	ct_BACK_pskel::
	ct_BACK_pskel ()
	: STATEMENT_SECTION_parser_ (0),
	  PICTURE_SECTION_parser_ (0),
	  COVER_SECTION_parser_ (0),
	  TABLE_OF_CONTENTS_parser_ (0),
	  REFERENCE_LIST_parser_ (0),
	  LIST_OF_PUBLICATIONS_parser_ (0),
	  LIST_OF_FIGURES_parser_ (0),
	  LIST_parser_ (0),
	  INDEX_parser_ (0),
	  CORRECTIONS_parser_ (0),
	  BIBLIOGRAPHY_parser_ (0),
	  ABBREVIATIONS_parser_ (0),
	  RIDAS_parser_ (0),
	  POSTFACE_parser_ (0),
	  NECROLOGY_parser_ (0),
	  CHAPTER_parser_ (0),
	  APPENDIX_parser_ (0),
	  ACKNOWLEDGEMENTS_parser_ (0),
	  ADVERTISEMENT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_ISSUE_pskel
	//

	void ct_ISSUE_pskel::
	MAIN_parser (::bnl_serial_v1_0::ct_MAIN_pskel& p)
	{
	  this->MAIN_parser_ = &p;
	}

	void ct_ISSUE_pskel::
	FRONT_parser (::bnl_serial_v1_0::ct_FRONT_pskel& p)
	{
	  this->FRONT_parser_ = &p;
	}

	void ct_ISSUE_pskel::
	BACK_parser (::bnl_serial_v1_0::ct_BACK_pskel& p)
	{
	  this->BACK_parser_ = &p;
	}

	void ct_ISSUE_pskel::
	parsers (::bnl_serial_v1_0::ct_MAIN_pskel& MAIN,
			 ::bnl_serial_v1_0::ct_FRONT_pskel& FRONT,
			 ::bnl_serial_v1_0::ct_BACK_pskel& BACK)
	{
	  this->MAIN_parser_ = &MAIN;
	  this->FRONT_parser_ = &FRONT;
	  this->BACK_parser_ = &BACK;
	}

	ct_ISSUE_pskel::
	ct_ISSUE_pskel ()
	: MAIN_parser_ (0),
	  FRONT_parser_ (0),
	  BACK_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_PAGE_LIKE_pskel
	//

	void ct_PAGE_LIKE_pskel::
		CONTENT_parser (::bnl_serial_v1_0::CONTENT_pskel& p)
	{
	  this->CONTENT_parser_ = &p;
	}

	void ct_PAGE_LIKE_pskel::
	parsers (::bnl_serial_v1_0::CONTENT_pskel& CONTENT)
	{
	  this->CONTENT_parser_ = &CONTENT;
	}

	ct_PAGE_LIKE_pskel::
	ct_PAGE_LIKE_pskel ()
	: CONTENT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_TITLE_SECTION_pskel
	//

	void ct_TITLE_SECTION_pskel::
	TITLE_OF_WORK_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TITLE_OF_WORK_parser_ = &p;
	}

	void ct_TITLE_SECTION_pskel::
	CREATOR_OF_WORK_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->CREATOR_OF_WORK_parser_ = &p;
	}

	void ct_TITLE_SECTION_pskel::
	PUBLISHING_STMT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->PUBLISHING_STMT_parser_ = &p;
	}

	void ct_TITLE_SECTION_pskel::
	STATEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->STATEMENT_parser_ = &p;
	}

	void ct_TITLE_SECTION_pskel::
	CONTENT_parser (::bnl_serial_v1_0::CONTENT1_pskel& p)
	{
	  this->CONTENT_parser_ = &p;
	}

	void ct_TITLE_SECTION_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TITLE_OF_WORK,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& CREATOR_OF_WORK,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& PUBLISHING_STMT,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& STATEMENT,
			 ::bnl_serial_v1_0::CONTENT1_pskel& CONTENT)
	{
	  this->TITLE_OF_WORK_parser_ = &TITLE_OF_WORK;
	  this->CREATOR_OF_WORK_parser_ = &CREATOR_OF_WORK;
	  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
	  this->STATEMENT_parser_ = &STATEMENT;
	  this->CONTENT_parser_ = &CONTENT;
	}

	ct_TITLE_SECTION_pskel::
	ct_TITLE_SECTION_pskel ()
	: TITLE_OF_WORK_parser_ (0),
	  CREATOR_OF_WORK_parser_ (0),
	  PUBLISHING_STMT_parser_ (0),
	  STATEMENT_parser_ (0),
	  CONTENT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_LIST_LIKE_pskel
	//

	void ct_LIST_LIKE_pskel::
	CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->CAPTION_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	DATA_parser (::bnl_serial_v1_0::DATA_pskel& p)
	{
	  this->DATA_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->TABLE_OF_CONTENTS_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->REFERENCE_LIST_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_PUBLICATIONS_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_FIGURES_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->INDEX_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->CORRECTIONS_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->BIBLIOGRAPHY_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->ABBREVIATIONS_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	ITEM_parser (::bnl_serial_v1_0::ct_ITEM_pskel& p)
	{
	  this->ITEM_parser_ = &p;
	}

	void ct_LIST_LIKE_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& CAPTION,
			 ::bnl_serial_v1_0::DATA_pskel& DATA,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& REFERENCE_LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_PUBLICATIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_FIGURES,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& INDEX,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& CORRECTIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& BIBLIOGRAPHY,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& ABBREVIATIONS,
			 ::bnl_serial_v1_0::ct_ITEM_pskel& ITEM)
	{
	  this->CAPTION_parser_ = &CAPTION;
	  this->DATA_parser_ = &DATA;
	  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
	  this->REFERENCE_LIST_parser_ = &REFERENCE_LIST;
	  this->LIST_OF_PUBLICATIONS_parser_ = &LIST_OF_PUBLICATIONS;
	  this->LIST_OF_FIGURES_parser_ = &LIST_OF_FIGURES;
	  this->LIST_parser_ = &LIST;
	  this->INDEX_parser_ = &INDEX;
	  this->CORRECTIONS_parser_ = &CORRECTIONS;
	  this->BIBLIOGRAPHY_parser_ = &BIBLIOGRAPHY;
	  this->ABBREVIATIONS_parser_ = &ABBREVIATIONS;
	  this->ITEM_parser_ = &ITEM;
	}

	ct_LIST_LIKE_pskel::
	ct_LIST_LIKE_pskel ()
	: CAPTION_parser_ (0),
	  DATA_parser_ (0),
	  TABLE_OF_CONTENTS_parser_ (0),
	  REFERENCE_LIST_parser_ (0),
	  LIST_OF_PUBLICATIONS_parser_ (0),
	  LIST_OF_FIGURES_parser_ (0),
	  LIST_parser_ (0),
	  INDEX_parser_ (0),
	  CORRECTIONS_parser_ (0),
	  BIBLIOGRAPHY_parser_ (0),
	  ABBREVIATIONS_parser_ (0),
	  ITEM_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_ITEM_pskel
	//

	void ct_ITEM_pskel::
	TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXTBLOCK_parser_ = &p;
	}

	void ct_ITEM_pskel::
	PAGE_NUMBER_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->PAGE_NUMBER_parser_ = &p;
	}

	void ct_ITEM_pskel::
	ITEM_CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->ITEM_CAPTION_parser_ = &p;
	}

	void ct_ITEM_pskel::
	SUBHEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->SUBHEADLINE_parser_ = &p;
	}

	void ct_ITEM_pskel::
	HEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->HEADLINE_parser_ = &p;
	}

	void ct_ITEM_pskel::
	AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->AUTHOR_parser_ = &p;
	}

	void ct_ITEM_pskel::
	ITEM_parser (::bnl_serial_v1_0::ct_ITEM_pskel& p)
	{
	  this->ITEM_parser_ = &p;
	}

	void ct_ITEM_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXTBLOCK,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& PAGE_NUMBER,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& ITEM_CAPTION,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& SUBHEADLINE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& HEADLINE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& AUTHOR,
			 ::bnl_serial_v1_0::ct_ITEM_pskel& ITEM)
	{
	  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
	  this->PAGE_NUMBER_parser_ = &PAGE_NUMBER;
	  this->ITEM_CAPTION_parser_ = &ITEM_CAPTION;
	  this->SUBHEADLINE_parser_ = &SUBHEADLINE;
	  this->HEADLINE_parser_ = &HEADLINE;
	  this->AUTHOR_parser_ = &AUTHOR;
	  this->ITEM_parser_ = &ITEM;
	}

	ct_ITEM_pskel::
	ct_ITEM_pskel ()
	: TEXTBLOCK_parser_ (0),
	  PAGE_NUMBER_parser_ (0),
	  ITEM_CAPTION_parser_ (0),
	  SUBHEADLINE_parser_ (0),
	  HEADLINE_parser_ (0),
	  AUTHOR_parser_ (0),
	  ITEM_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_HEADING_pskel
	//

	void ct_HEADING_pskel::
	TITLE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TITLE_parser_ = &p;
	}

	void ct_HEADING_pskel::
	SUBTITLE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->SUBTITLE_parser_ = &p;
	}

	void ct_HEADING_pskel::
	AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->AUTHOR_parser_ = &p;
	}

	void ct_HEADING_pskel::
	MOTTO_parser (::bnl_serial_v1_0::MOTTO_pskel& p)
	{
	  this->MOTTO_parser_ = &p;
	}

	void ct_HEADING_pskel::
	HEADING_TEXT_parser (::bnl_serial_v1_0::HEADING_TEXT_pskel& p)
	{
	  this->HEADING_TEXT_parser_ = &p;
	}

	void ct_HEADING_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TITLE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& SUBTITLE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& AUTHOR,
			 ::bnl_serial_v1_0::MOTTO_pskel& MOTTO,
			 ::bnl_serial_v1_0::HEADING_TEXT_pskel& HEADING_TEXT)
	{
	  this->TITLE_parser_ = &TITLE;
	  this->SUBTITLE_parser_ = &SUBTITLE;
	  this->AUTHOR_parser_ = &AUTHOR;
	  this->MOTTO_parser_ = &MOTTO;
	  this->HEADING_TEXT_parser_ = &HEADING_TEXT;
	}

	ct_HEADING_pskel::
	ct_HEADING_pskel ()
	: TITLE_parser_ (0),
	  SUBTITLE_parser_ (0),
	  AUTHOR_parser_ (0),
	  MOTTO_parser_ (0),
	  HEADING_TEXT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_CHAPTER_LIKE_pskel
	//

	void ct_CHAPTER_LIKE_pskel::
	HEADING_parser (::bnl_serial_v1_0::ct_HEADING_pskel& p)
	{
	  this->HEADING_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	ABSTRACT_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ABSTRACT_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	BODY_parser (::bnl_serial_v1_0::ct_BODY_pskel& p)
	{
	  this->BODY_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->TABLE_OF_CONTENTS_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->REFERENCE_LIST_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_PUBLICATIONS_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_OF_FIGURES_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->INDEX_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->CORRECTIONS_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->BIBLIOGRAPHY_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->ABBREVIATIONS_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->RIDAS_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	PRODUCTION_NOTE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->PRODUCTION_NOTE_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	PREFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->PREFACE_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	POSTFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->POSTFACE_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	POEM_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->POEM_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	NOTES_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->NOTES_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->NECROLOGY_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	INTRODUCTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->INTRODUCTION_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	GROUP_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->GROUP_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	DEDICATION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->DEDICATION_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	DEBATE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->DEBATE_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	CONTRIBUTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->CONTRIBUTION_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->CHAPTER_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	BOOK_REVIEW_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->BOOK_REVIEW_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	APPENDIX_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->APPENDIX_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& p)
	{
	  this->ACKNOWLEDGEMENTS_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	MAP_GROUP_parser (::bnl_serial_v1_0::ct_MAP_GROUP_pskel& p)
	{
	  this->MAP_GROUP_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	ILLUSTRATION_GROUP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_GROUP_pskel& p)
	{
	  this->ILLUSTRATION_GROUP_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	CHART_DIAGRAM_GROUP_parser (::bnl_serial_v1_0::ct_CHART_DIAGRAM_GROUP_pskel& p)
	{
	  this->CHART_DIAGRAM_GROUP_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	TABLE_GROUP_parser (::bnl_serial_v1_0::ct_TABLE_GROUP_pskel& p)
	{
	  this->TABLE_GROUP_parser_ = &p;
	}

	void ct_CHAPTER_LIKE_pskel::
	parsers (::bnl_serial_v1_0::ct_HEADING_pskel& HEADING,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ABSTRACT,
			 ::bnl_serial_v1_0::ct_BODY_pskel& BODY,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& TABLE_OF_CONTENTS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& REFERENCE_LIST,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_PUBLICATIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST_OF_FIGURES,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& INDEX,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& CORRECTIONS,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& BIBLIOGRAPHY,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& ABBREVIATIONS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& RIDAS,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& PRODUCTION_NOTE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& PREFACE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& POSTFACE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& POEM,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& NOTES,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& NECROLOGY,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& INTRODUCTION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& GROUP,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& DEDICATION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& DEBATE,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& CONTRIBUTION,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& CHAPTER,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& BOOK_REVIEW,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& APPENDIX,
			 ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& ACKNOWLEDGEMENTS,
			 ::bnl_serial_v1_0::ct_MAP_GROUP_pskel& MAP_GROUP,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_GROUP_pskel& ILLUSTRATION_GROUP,
			 ::bnl_serial_v1_0::ct_CHART_DIAGRAM_GROUP_pskel& CHART_DIAGRAM_GROUP,
			 ::bnl_serial_v1_0::ct_TABLE_GROUP_pskel& TABLE_GROUP)
	{
	  this->HEADING_parser_ = &HEADING;
	  this->ABSTRACT_parser_ = &ABSTRACT;
	  this->BODY_parser_ = &BODY;
	  this->TABLE_OF_CONTENTS_parser_ = &TABLE_OF_CONTENTS;
	  this->REFERENCE_LIST_parser_ = &REFERENCE_LIST;
	  this->LIST_OF_PUBLICATIONS_parser_ = &LIST_OF_PUBLICATIONS;
	  this->LIST_OF_FIGURES_parser_ = &LIST_OF_FIGURES;
	  this->INDEX_parser_ = &INDEX;
	  this->CORRECTIONS_parser_ = &CORRECTIONS;
	  this->BIBLIOGRAPHY_parser_ = &BIBLIOGRAPHY;
	  this->ABBREVIATIONS_parser_ = &ABBREVIATIONS;
	  this->RIDAS_parser_ = &RIDAS;
	  this->PRODUCTION_NOTE_parser_ = &PRODUCTION_NOTE;
	  this->PREFACE_parser_ = &PREFACE;
	  this->POSTFACE_parser_ = &POSTFACE;
	  this->POEM_parser_ = &POEM;
	  this->NOTES_parser_ = &NOTES;
	  this->NECROLOGY_parser_ = &NECROLOGY;
	  this->INTRODUCTION_parser_ = &INTRODUCTION;
	  this->GROUP_parser_ = &GROUP;
	  this->DEDICATION_parser_ = &DEDICATION;
	  this->DEBATE_parser_ = &DEBATE;
	  this->CONTRIBUTION_parser_ = &CONTRIBUTION;
	  this->CHAPTER_parser_ = &CHAPTER;
	  this->BOOK_REVIEW_parser_ = &BOOK_REVIEW;
	  this->APPENDIX_parser_ = &APPENDIX;
	  this->ACKNOWLEDGEMENTS_parser_ = &ACKNOWLEDGEMENTS;
	  this->MAP_GROUP_parser_ = &MAP_GROUP;
	  this->ILLUSTRATION_GROUP_parser_ = &ILLUSTRATION_GROUP;
	  this->CHART_DIAGRAM_GROUP_parser_ = &CHART_DIAGRAM_GROUP;
	  this->TABLE_GROUP_parser_ = &TABLE_GROUP;
	}

	ct_CHAPTER_LIKE_pskel::
	ct_CHAPTER_LIKE_pskel ()
	: HEADING_parser_ (0),
	  ABSTRACT_parser_ (0),
	  BODY_parser_ (0),
	  TABLE_OF_CONTENTS_parser_ (0),
	  REFERENCE_LIST_parser_ (0),
	  LIST_OF_PUBLICATIONS_parser_ (0),
	  LIST_OF_FIGURES_parser_ (0),
	  INDEX_parser_ (0),
	  CORRECTIONS_parser_ (0),
	  BIBLIOGRAPHY_parser_ (0),
	  ABBREVIATIONS_parser_ (0),
	  RIDAS_parser_ (0),
	  PRODUCTION_NOTE_parser_ (0),
	  PREFACE_parser_ (0),
	  POSTFACE_parser_ (0),
	  POEM_parser_ (0),
	  NOTES_parser_ (0),
	  NECROLOGY_parser_ (0),
	  INTRODUCTION_parser_ (0),
	  GROUP_parser_ (0),
	  DEDICATION_parser_ (0),
	  DEBATE_parser_ (0),
	  CONTRIBUTION_parser_ (0),
	  CHAPTER_parser_ (0),
	  BOOK_REVIEW_parser_ (0),
	  APPENDIX_parser_ (0),
	  ACKNOWLEDGEMENTS_parser_ (0),
	  MAP_GROUP_parser_ (0),
	  ILLUSTRATION_GROUP_parser_ (0),
	  CHART_DIAGRAM_GROUP_parser_ (0),
	  TABLE_GROUP_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_MAP_GROUP_pskel
	//

	void ct_MAP_GROUP_pskel::
	MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->MAP_parser_ = &p;
	}

	void ct_MAP_GROUP_pskel::
	parsers (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& MAP)
	{
	  this->MAP_parser_ = &MAP;
	}

	ct_MAP_GROUP_pskel::
	ct_MAP_GROUP_pskel ()
	: MAP_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_ILLUSTRATION_GROUP_pskel
	//

	void ct_ILLUSTRATION_GROUP_pskel::
	ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->ILLUSTRATION_parser_ = &p;
	}

	void ct_ILLUSTRATION_GROUP_pskel::
	parsers (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION)
	{
	  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
	}

	ct_ILLUSTRATION_GROUP_pskel::
	ct_ILLUSTRATION_GROUP_pskel ()
	: ILLUSTRATION_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_CHART_DIAGRAM_GROUP_pskel
	//

	void ct_CHART_DIAGRAM_GROUP_pskel::
	CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->CHART_DIAGRAM_parser_ = &p;
	}

	void ct_CHART_DIAGRAM_GROUP_pskel::
	parsers (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& CHART_DIAGRAM)
	{
	  this->CHART_DIAGRAM_parser_ = &CHART_DIAGRAM;
	}

	ct_CHART_DIAGRAM_GROUP_pskel::
	ct_CHART_DIAGRAM_GROUP_pskel ()
	: CHART_DIAGRAM_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_TABLE_GROUP_pskel
	//

	void ct_TABLE_GROUP_pskel::
	TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& p)
	{
	  this->TABLE_parser_ = &p;
	}

	void ct_TABLE_GROUP_pskel::
	parsers (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& TABLE)
	{
	  this->TABLE_parser_ = &TABLE;
	}

	ct_TABLE_GROUP_pskel::
	ct_TABLE_GROUP_pskel ()
	: TABLE_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_ILLUSTRATION_LIKE_STRUCT_pskel
	//

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	IMAGE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->IMAGE_parser_ = &p;
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->CAPTION_parser_ = &p;
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& IMAGE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& CAPTION)
	{
	  this->IMAGE_parser_ = &IMAGE;
	  this->CAPTION_parser_ = &CAPTION;
	}

	ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	ct_ILLUSTRATION_LIKE_STRUCT_pskel ()
	: IMAGE_parser_ (0),
	  CAPTION_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_TABLE_LIKE_STRUCT_pskel
	//

	void ct_TABLE_LIKE_STRUCT_pskel::
	IMAGE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->IMAGE_parser_ = &p;
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->CAPTION_parser_ = &p;
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& IMAGE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& CAPTION)
	{
	  this->IMAGE_parser_ = &IMAGE;
	  this->CAPTION_parser_ = &CAPTION;
	}

	ct_TABLE_LIKE_STRUCT_pskel::
	ct_TABLE_LIKE_STRUCT_pskel ()
	: IMAGE_parser_ (0),
	  CAPTION_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_BODY_pskel
	//

	void ct_BODY_pskel::
	BODY_CONTENT_parser (::bnl_serial_v1_0::ct_BODY_CONTENT_pskel& p)
	{
	  this->BODY_CONTENT_parser_ = &p;
	}

	void ct_BODY_pskel::
	FOOTNOTE_parser (::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel& p)
	{
	  this->FOOTNOTE_parser_ = &p;
	}

	void ct_BODY_pskel::
	MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->MAP_parser_ = &p;
	}

	void ct_BODY_pskel::
	ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->ILLUSTRATION_parser_ = &p;
	}

	void ct_BODY_pskel::
	CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->CHART_DIAGRAM_parser_ = &p;
	}

	void ct_BODY_pskel::
	BOOKPLATE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->BOOKPLATE_parser_ = &p;
	}

	void ct_BODY_pskel::
	BARCODE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->BARCODE_parser_ = &p;
	}

	void ct_BODY_pskel::
	TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& p)
	{
	  this->TABLE_parser_ = &p;
	}

	void ct_BODY_pskel::
	LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& p)
	{
	  this->LIST_parser_ = &p;
	}

	void ct_BODY_pskel::
	parsers (::bnl_serial_v1_0::ct_BODY_CONTENT_pskel& BODY_CONTENT,
			 ::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel& FOOTNOTE,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& MAP,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& CHART_DIAGRAM,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& BOOKPLATE,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& BARCODE,
			 ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& TABLE,
			 ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& LIST)
	{
	  this->BODY_CONTENT_parser_ = &BODY_CONTENT;
	  this->FOOTNOTE_parser_ = &FOOTNOTE;
	  this->MAP_parser_ = &MAP;
	  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
	  this->CHART_DIAGRAM_parser_ = &CHART_DIAGRAM;
	  this->BOOKPLATE_parser_ = &BOOKPLATE;
	  this->BARCODE_parser_ = &BARCODE;
	  this->TABLE_parser_ = &TABLE;
	  this->LIST_parser_ = &LIST;
	}

	ct_BODY_pskel::
	ct_BODY_pskel ()
	: BODY_CONTENT_parser_ (0),
	  FOOTNOTE_parser_ (0),
	  MAP_parser_ (0),
	  ILLUSTRATION_parser_ (0),
	  CHART_DIAGRAM_parser_ (0),
	  BOOKPLATE_parser_ (0),
	  BARCODE_parser_ (0),
	  TABLE_parser_ (0),
	  LIST_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_BODY_CONTENT_pskel
	//

	void ct_BODY_CONTENT_pskel::
	TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXTBLOCK_parser_ = &p;
	}

	void ct_BODY_CONTENT_pskel::
	PARAGRAPH_parser (::bnl_serial_v1_0::ct_PARAGRAPH_pskel& p)
	{
	  this->PARAGRAPH_parser_ = &p;
	}

	void ct_BODY_CONTENT_pskel::
	FORMULA_parser (::bnl_serial_v1_0::ct_FORMULA_pskel& p)
	{
	  this->FORMULA_parser_ = &p;
	}

	void ct_BODY_CONTENT_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXTBLOCK,
			 ::bnl_serial_v1_0::ct_PARAGRAPH_pskel& PARAGRAPH,
			 ::bnl_serial_v1_0::ct_FORMULA_pskel& FORMULA)
	{
	  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
	  this->PARAGRAPH_parser_ = &PARAGRAPH;
	  this->FORMULA_parser_ = &FORMULA;
	}

	ct_BODY_CONTENT_pskel::
	ct_BODY_CONTENT_pskel ()
	: TEXTBLOCK_parser_ (0),
	  PARAGRAPH_parser_ (0),
	  FORMULA_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_FORMULA_pskel
	//

	void ct_FORMULA_pskel::
	IMAGE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->IMAGE_parser_ = &p;
	}

	void ct_FORMULA_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& IMAGE)
	{
	  this->IMAGE_parser_ = &IMAGE;
	}

	ct_FORMULA_pskel::
	ct_FORMULA_pskel ()
	: IMAGE_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_PARAGRAPH_pskel
	//

	void ct_PARAGRAPH_pskel::
	TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXT_parser_ = &p;
	}

	void ct_PARAGRAPH_pskel::
	MARGINALIA_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->MARGINALIA_parser_ = &p;
	}

	void ct_PARAGRAPH_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXT,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& MARGINALIA)
	{
	  this->TEXT_parser_ = &TEXT;
	  this->MARGINALIA_parser_ = &MARGINALIA;
	}

	ct_PARAGRAPH_pskel::
	ct_PARAGRAPH_pskel ()
	: TEXT_parser_ (0),
	  MARGINALIA_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_FOOTNOTE_PARAGRAPH_pskel
	//

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXT_parser_ = &p;
	}

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXT)
	{
	  this->TEXT_parser_ = &TEXT;
	}

	ct_FOOTNOTE_PARAGRAPH_pskel::
	ct_FOOTNOTE_PARAGRAPH_pskel ()
	: TEXT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_FINAL_pskel
	//

	void ct_FINAL_pskel::
	fptr_parser (::bnl_serial_v1_0::ct_FPTR_pskel& p)
	{
	  this->fptr_parser_ = &p;
	}

	void ct_FINAL_pskel::
	parsers (::bnl_serial_v1_0::ct_FPTR_pskel& fptr)
	{
	  this->fptr_parser_ = &fptr;
	}

	ct_FINAL_pskel::
	ct_FINAL_pskel ()
	: fptr_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_FPTR_pskel
	//

	void ct_FPTR_pskel::
	area_parser (::xml_schema::any_type_pskel& p)
	{
	  this->area_parser_ = &p;
	}

	void ct_FPTR_pskel::
	seq_parser (::bnl_serial_v1_0::ct_SEQ_pskel& p)
	{
	  this->seq_parser_ = &p;
	}

	void ct_FPTR_pskel::
	par_parser (::bnl_serial_v1_0::par_pskel& p)
	{
	  this->par_parser_ = &p;
	}

	void ct_FPTR_pskel::
	parsers (::xml_schema::any_type_pskel& area,
			 ::bnl_serial_v1_0::ct_SEQ_pskel& seq,
			 ::bnl_serial_v1_0::par_pskel& par)
	{
	  this->area_parser_ = &area;
	  this->seq_parser_ = &seq;
	  this->par_parser_ = &par;
	}

	ct_FPTR_pskel::
	ct_FPTR_pskel ()
	: area_parser_ (0),
	  seq_parser_ (0),
	  par_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_SEQ_pskel
	//

	void ct_SEQ_pskel::
	area_parser (::xml_schema::any_type_pskel& p)
	{
	  this->area_parser_ = &p;
	}

	void ct_SEQ_pskel::
	parsers (::xml_schema::any_type_pskel& area)
	{
	  this->area_parser_ = &area;
	}

	ct_SEQ_pskel::
	ct_SEQ_pskel ()
	: area_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// Serial_pskel
	//

	void Serial_pskel::
	VOLUME_parser (::bnl_serial_v1_0::ct_HIERARCHY_pskel& p)
	{
	  this->VOLUME_parser_ = &p;
	}

	void Serial_pskel::
	parsers (::bnl_serial_v1_0::ct_HIERARCHY_pskel& VOLUME)
	{
	  this->VOLUME_parser_ = &VOLUME;
	}

	Serial_pskel::
	Serial_pskel ()
	: VOLUME_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// CONTENT_pskel
	//

	void CONTENT_pskel::
	TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXTBLOCK_parser_ = &p;
	}

	void CONTENT_pskel::
	TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& p)
	{
	  this->TABLE_parser_ = &p;
	}

	void CONTENT_pskel::
	PUBLISHING_STMT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->PUBLISHING_STMT_parser_ = &p;
	}

	void CONTENT_pskel::
	PARAGRAPH_parser (::bnl_serial_v1_0::ct_PARAGRAPH_pskel& p)
	{
	  this->PARAGRAPH_parser_ = &p;
	}

	void CONTENT_pskel::
	MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->MAP_parser_ = &p;
	}

	void CONTENT_pskel::
	ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->ILLUSTRATION_parser_ = &p;
	}

	void CONTENT_pskel::
	CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->CHART_DIAGRAM_parser_ = &p;
	}

	void CONTENT_pskel::
	BOOKPLATE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->BOOKPLATE_parser_ = &p;
	}

	void CONTENT_pskel::
	BARCODE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->BARCODE_parser_ = &p;
	}

	void CONTENT_pskel::
	SUBHEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->SUBHEADLINE_parser_ = &p;
	}

	void CONTENT_pskel::
	HEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->HEADLINE_parser_ = &p;
	}

	void CONTENT_pskel::
	FORMULA_parser (::bnl_serial_v1_0::ct_FORMULA_pskel& p)
	{
	  this->FORMULA_parser_ = &p;
	}

	void CONTENT_pskel::
	FOOTNOTE_parser (::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel& p)
	{
	  this->FOOTNOTE_parser_ = &p;
	}

	void CONTENT_pskel::
	AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->AUTHOR_parser_ = &p;
	}

	void CONTENT_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXTBLOCK,
			 ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& TABLE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& PUBLISHING_STMT,
			 ::bnl_serial_v1_0::ct_PARAGRAPH_pskel& PARAGRAPH,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& MAP,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& CHART_DIAGRAM,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& BOOKPLATE,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& BARCODE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& SUBHEADLINE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& HEADLINE,
			 ::bnl_serial_v1_0::ct_FORMULA_pskel& FORMULA,
			 ::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel& FOOTNOTE,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& AUTHOR)
	{
	  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
	  this->TABLE_parser_ = &TABLE;
	  this->PUBLISHING_STMT_parser_ = &PUBLISHING_STMT;
	  this->PARAGRAPH_parser_ = &PARAGRAPH;
	  this->MAP_parser_ = &MAP;
	  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
	  this->CHART_DIAGRAM_parser_ = &CHART_DIAGRAM;
	  this->BOOKPLATE_parser_ = &BOOKPLATE;
	  this->BARCODE_parser_ = &BARCODE;
	  this->SUBHEADLINE_parser_ = &SUBHEADLINE;
	  this->HEADLINE_parser_ = &HEADLINE;
	  this->FORMULA_parser_ = &FORMULA;
	  this->FOOTNOTE_parser_ = &FOOTNOTE;
	  this->AUTHOR_parser_ = &AUTHOR;
	}

	CONTENT_pskel::
	CONTENT_pskel ()
	: TEXTBLOCK_parser_ (0),
	  TABLE_parser_ (0),
	  PUBLISHING_STMT_parser_ (0),
	  PARAGRAPH_parser_ (0),
	  MAP_parser_ (0),
	  ILLUSTRATION_parser_ (0),
	  CHART_DIAGRAM_parser_ (0),
	  BOOKPLATE_parser_ (0),
	  BARCODE_parser_ (0),
	  SUBHEADLINE_parser_ (0),
	  HEADLINE_parser_ (0),
	  FORMULA_parser_ (0),
	  FOOTNOTE_parser_ (0),
	  AUTHOR_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// CONTENT1_pskel
	//

	void CONTENT1_pskel::
	TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& p)
	{
	  this->TABLE_parser_ = &p;
	}

	void CONTENT1_pskel::
	MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->MAP_parser_ = &p;
	}

	void CONTENT1_pskel::
	ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->ILLUSTRATION_parser_ = &p;
	}

	void CONTENT1_pskel::
	CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->CHART_DIAGRAM_parser_ = &p;
	}

	void CONTENT1_pskel::
	BOOKPLATE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->BOOKPLATE_parser_ = &p;
	}

	void CONTENT1_pskel::
	BARCODE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& p)
	{
	  this->BARCODE_parser_ = &p;
	}

	void CONTENT1_pskel::
	FORMULA_parser (::bnl_serial_v1_0::ct_FORMULA_pskel& p)
	{
	  this->FORMULA_parser_ = &p;
	}

	void CONTENT1_pskel::
	parsers (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& TABLE,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& MAP,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& ILLUSTRATION,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& CHART_DIAGRAM,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& BOOKPLATE,
			 ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& BARCODE,
			 ::bnl_serial_v1_0::ct_FORMULA_pskel& FORMULA)
	{
	  this->TABLE_parser_ = &TABLE;
	  this->MAP_parser_ = &MAP;
	  this->ILLUSTRATION_parser_ = &ILLUSTRATION;
	  this->CHART_DIAGRAM_parser_ = &CHART_DIAGRAM;
	  this->BOOKPLATE_parser_ = &BOOKPLATE;
	  this->BARCODE_parser_ = &BARCODE;
	  this->FORMULA_parser_ = &FORMULA;
	}

	CONTENT1_pskel::
	CONTENT1_pskel ()
	: TABLE_parser_ (0),
	  MAP_parser_ (0),
	  ILLUSTRATION_parser_ (0),
	  CHART_DIAGRAM_parser_ (0),
	  BOOKPLATE_parser_ (0),
	  BARCODE_parser_ (0),
	  FORMULA_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// DATA_pskel
	//

	void DATA_pskel::
	TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXTBLOCK_parser_ = &p;
	}

	void DATA_pskel::
	PAGE_NUMBER_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->PAGE_NUMBER_parser_ = &p;
	}

	void DATA_pskel::
	ITEM_CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->ITEM_CAPTION_parser_ = &p;
	}

	void DATA_pskel::
	AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->AUTHOR_parser_ = &p;
	}

	void DATA_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXTBLOCK,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& PAGE_NUMBER,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& ITEM_CAPTION,
			 ::bnl_serial_v1_0::ct_FINAL_pskel& AUTHOR)
	{
	  this->TEXTBLOCK_parser_ = &TEXTBLOCK;
	  this->PAGE_NUMBER_parser_ = &PAGE_NUMBER;
	  this->ITEM_CAPTION_parser_ = &ITEM_CAPTION;
	  this->AUTHOR_parser_ = &AUTHOR;
	}

	DATA_pskel::
	DATA_pskel ()
	: TEXTBLOCK_parser_ (0),
	  PAGE_NUMBER_parser_ (0),
	  ITEM_CAPTION_parser_ (0),
	  AUTHOR_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// MOTTO_pskel
	//

	void MOTTO_pskel::
	TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXT_parser_ = &p;
	}

	void MOTTO_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXT)
	{
	  this->TEXT_parser_ = &TEXT;
	}

	MOTTO_pskel::
	MOTTO_pskel ()
	: TEXT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// HEADING_TEXT_pskel
	//

	void HEADING_TEXT_pskel::
	TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel& p)
	{
	  this->TEXT_parser_ = &p;
	}

	void HEADING_TEXT_pskel::
	parsers (::bnl_serial_v1_0::ct_FINAL_pskel& TEXT)
	{
	  this->TEXT_parser_ = &TEXT;
	}

	HEADING_TEXT_pskel::
	HEADING_TEXT_pskel ()
	: TEXT_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// par_pskel
	//

	void par_pskel::
	area_parser (::xml_schema::any_type_pskel& p)
	{
	  this->area_parser_ = &p;
	}

	void par_pskel::
	seq_parser (::bnl_serial_v1_0::ct_SEQ_pskel& p)
	{
	  this->seq_parser_ = &p;
	}

	void par_pskel::
	parsers (::xml_schema::any_type_pskel& area,
			 ::bnl_serial_v1_0::ct_SEQ_pskel& seq)
	{
	  this->area_parser_ = &area;
	  this->seq_parser_ = &seq;
	}

	par_pskel::
	par_pskel ()
	: area_parser_ (0),
	  seq_parser_ (0),
	  v_state_stack_ (sizeof (v_state_), &v_state_first_)
	{
	}

	// ct_HIERARCHY_pskel
	//

	void ct_HIERARCHY_pskel::
	FRONT ()
	{
	}

	void ct_HIERARCHY_pskel::
	ISSUE ()
	{
	}

	void ct_HIERARCHY_pskel::
	BACK ()
	{
	}

	void ct_HIERARCHY_pskel::
	post_ct_HIERARCHY ()
	{
	}

	// ct_FRONT_pskel
	//

	void ct_FRONT_pskel::
	TITLE_SECTION ()
	{
	}

	void ct_FRONT_pskel::
	STATEMENT_SECTION ()
	{
	}

	void ct_FRONT_pskel::
	PICTURE_SECTION ()
	{
	}

	void ct_FRONT_pskel::
	FRONTISPIECE ()
	{
	}

	void ct_FRONT_pskel::
	COVER_SECTION ()
	{
	}

	void ct_FRONT_pskel::
	BASTARD_TITLE_SECTION ()
	{
	}

	void ct_FRONT_pskel::
	TABLE_OF_CONTENTS ()
	{
	}

	void ct_FRONT_pskel::
	REFERENCE_LIST ()
	{
	}

	void ct_FRONT_pskel::
	LIST_OF_PUBLICATIONS ()
	{
	}

	void ct_FRONT_pskel::
	LIST_OF_FIGURES ()
	{
	}

	void ct_FRONT_pskel::
	INDEX ()
	{
	}

	void ct_FRONT_pskel::
	CORRECTIONS ()
	{
	}

	void ct_FRONT_pskel::
	BIBLIOGRAPHY ()
	{
	}

	void ct_FRONT_pskel::
	ABBREVIATIONS ()
	{
	}

	void ct_FRONT_pskel::
	RIDAS ()
	{
	}

	void ct_FRONT_pskel::
	PRODUCTION_NOTE ()
	{
	}

	void ct_FRONT_pskel::
	PREFACE ()
	{
	}

	void ct_FRONT_pskel::
	NECROLOGY ()
	{
	}

	void ct_FRONT_pskel::
	INTRODUCTION ()
	{
	}

	void ct_FRONT_pskel::
	DEDICATION ()
	{
	}

	void ct_FRONT_pskel::
	CHAPTER ()
	{
	}

	void ct_FRONT_pskel::
	ACKNOWLEDGEMENTS ()
	{
	}

	void ct_FRONT_pskel::
	ABSTRACT ()
	{
	}

	void ct_FRONT_pskel::
	ADVERTISEMENT ()
	{
	}

	void ct_FRONT_pskel::
	post_ct_FRONT ()
	{
	}

	// ct_MAIN_pskel
	//

	void ct_MAIN_pskel::
	TABLE_OF_CONTENTS ()
	{
	}

	void ct_MAIN_pskel::
	REFERENCE_LIST ()
	{
	}

	void ct_MAIN_pskel::
	LIST_OF_PUBLICATIONS ()
	{
	}

	void ct_MAIN_pskel::
	LIST_OF_FIGURES ()
	{
	}

	void ct_MAIN_pskel::
	LIST ()
	{
	}

	void ct_MAIN_pskel::
	INDEX ()
	{
	}

	void ct_MAIN_pskel::
	CORRECTIONS ()
	{
	}

	void ct_MAIN_pskel::
	BIBLIOGRAPHY ()
	{
	}

	void ct_MAIN_pskel::
	ABBREVIATIONS ()
	{
	}

	void ct_MAIN_pskel::
	RIDAS ()
	{
	}

	void ct_MAIN_pskel::
	PRODUCTION_NOTE ()
	{
	}

	void ct_MAIN_pskel::
	PREFACE ()
	{
	}

	void ct_MAIN_pskel::
	POSTFACE ()
	{
	}

	void ct_MAIN_pskel::
	POEM ()
	{
	}

	void ct_MAIN_pskel::
	NOTES ()
	{
	}

	void ct_MAIN_pskel::
	NECROLOGY ()
	{
	}

	void ct_MAIN_pskel::
	INTRODUCTION ()
	{
	}

	void ct_MAIN_pskel::
	GROUP ()
	{
	}

	void ct_MAIN_pskel::
	DEDICATION ()
	{
	}

	void ct_MAIN_pskel::
	DEBATE ()
	{
	}

	void ct_MAIN_pskel::
	CONTRIBUTION ()
	{
	}

	void ct_MAIN_pskel::
	CHAPTER ()
	{
	}

	void ct_MAIN_pskel::
	BOOK_REVIEW ()
	{
	}

	void ct_MAIN_pskel::
	APPENDIX ()
	{
	}

	void ct_MAIN_pskel::
	ACKNOWLEDGEMENTS ()
	{
	}

	void ct_MAIN_pskel::
	ABSTRACT ()
	{
	}

	void ct_MAIN_pskel::
	ADVERTISEMENT ()
	{
	}

	void ct_MAIN_pskel::
	post_ct_MAIN ()
	{
	}

	// ct_BACK_pskel
	//

	void ct_BACK_pskel::
	STATEMENT_SECTION ()
	{
	}

	void ct_BACK_pskel::
	PICTURE_SECTION ()
	{
	}

	void ct_BACK_pskel::
	COVER_SECTION ()
	{
	}

	void ct_BACK_pskel::
	TABLE_OF_CONTENTS ()
	{
	}

	void ct_BACK_pskel::
	REFERENCE_LIST ()
	{
	}

	void ct_BACK_pskel::
	LIST_OF_PUBLICATIONS ()
	{
	}

	void ct_BACK_pskel::
	LIST_OF_FIGURES ()
	{
	}

	void ct_BACK_pskel::
	LIST ()
	{
	}

	void ct_BACK_pskel::
	INDEX ()
	{
	}

	void ct_BACK_pskel::
	CORRECTIONS ()
	{
	}

	void ct_BACK_pskel::
	BIBLIOGRAPHY ()
	{
	}

	void ct_BACK_pskel::
	ABBREVIATIONS ()
	{
	}

	void ct_BACK_pskel::
	RIDAS ()
	{
	}

	void ct_BACK_pskel::
	POSTFACE ()
	{
	}

	void ct_BACK_pskel::
	NECROLOGY ()
	{
	}

	void ct_BACK_pskel::
	CHAPTER ()
	{
	}

	void ct_BACK_pskel::
	APPENDIX ()
	{
	}

	void ct_BACK_pskel::
	ACKNOWLEDGEMENTS ()
	{
	}

	void ct_BACK_pskel::
	ADVERTISEMENT ()
	{
	}

	void ct_BACK_pskel::
	post_ct_BACK ()
	{
	}

	// ct_ISSUE_pskel
	//

	void ct_ISSUE_pskel::
	MAIN ()
	{
	}

	void ct_ISSUE_pskel::
	FRONT ()
	{
	}

	void ct_ISSUE_pskel::
	BACK ()
	{
	}

	void ct_ISSUE_pskel::
	post_ct_ISSUE ()
	{
	}

	// ct_PAGE_LIKE_pskel
	//

	void ct_PAGE_LIKE_pskel::
	CONTENT ()
	{
	}

	void ct_PAGE_LIKE_pskel::
	post_ct_PAGE_LIKE ()
	{
	}

	// ct_TITLE_SECTION_pskel
	//

	void ct_TITLE_SECTION_pskel::
	TITLE_OF_WORK ()
	{
	}

	void ct_TITLE_SECTION_pskel::
	CREATOR_OF_WORK ()
	{
	}

	void ct_TITLE_SECTION_pskel::
	PUBLISHING_STMT ()
	{
	}

	void ct_TITLE_SECTION_pskel::
	STATEMENT ()
	{
	}

	void ct_TITLE_SECTION_pskel::
	CONTENT ()
	{
	}

	void ct_TITLE_SECTION_pskel::
	post_ct_TITLE_SECTION ()
	{
	}

	// ct_LIST_LIKE_pskel
	//

	void ct_LIST_LIKE_pskel::
	CAPTION ()
	{
	}

	void ct_LIST_LIKE_pskel::
	DATA ()
	{
	}

	void ct_LIST_LIKE_pskel::
	TABLE_OF_CONTENTS ()
	{
	}

	void ct_LIST_LIKE_pskel::
	REFERENCE_LIST ()
	{
	}

	void ct_LIST_LIKE_pskel::
	LIST_OF_PUBLICATIONS ()
	{
	}

	void ct_LIST_LIKE_pskel::
	LIST_OF_FIGURES ()
	{
	}

	void ct_LIST_LIKE_pskel::
	LIST ()
	{
	}

	void ct_LIST_LIKE_pskel::
	INDEX ()
	{
	}

	void ct_LIST_LIKE_pskel::
	CORRECTIONS ()
	{
	}

	void ct_LIST_LIKE_pskel::
	BIBLIOGRAPHY ()
	{
	}

	void ct_LIST_LIKE_pskel::
	ABBREVIATIONS ()
	{
	}

	void ct_LIST_LIKE_pskel::
	ITEM ()
	{
	}

	void ct_LIST_LIKE_pskel::
	post_ct_LIST_LIKE ()
	{
	}

	// ct_ITEM_pskel
	//

	void ct_ITEM_pskel::
	TEXTBLOCK ()
	{
	}

	void ct_ITEM_pskel::
	PAGE_NUMBER ()
	{
	}

	void ct_ITEM_pskel::
	ITEM_CAPTION ()
	{
	}

	void ct_ITEM_pskel::
	SUBHEADLINE ()
	{
	}

	void ct_ITEM_pskel::
	HEADLINE ()
	{
	}

	void ct_ITEM_pskel::
	AUTHOR ()
	{
	}

	void ct_ITEM_pskel::
	ITEM ()
	{
	}

	void ct_ITEM_pskel::
	post_ct_ITEM ()
	{
	}

	// ct_HEADING_pskel
	//

	void ct_HEADING_pskel::
	TITLE ()
	{
	}

	void ct_HEADING_pskel::
	SUBTITLE ()
	{
	}

	void ct_HEADING_pskel::
	AUTHOR ()
	{
	}

	void ct_HEADING_pskel::
	MOTTO ()
	{
	}

	void ct_HEADING_pskel::
	HEADING_TEXT ()
	{
	}

	void ct_HEADING_pskel::
	post_ct_HEADING ()
	{
	}

	// ct_CHAPTER_LIKE_pskel
	//

	void ct_CHAPTER_LIKE_pskel::
	HEADING ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	ABSTRACT ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	BODY ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	TABLE_OF_CONTENTS ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	REFERENCE_LIST ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	LIST_OF_PUBLICATIONS ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	LIST_OF_FIGURES ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	INDEX ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	CORRECTIONS ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	BIBLIOGRAPHY ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	ABBREVIATIONS ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	RIDAS ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	PRODUCTION_NOTE ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	PREFACE ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	POSTFACE ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	POEM ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	NOTES ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	NECROLOGY ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	INTRODUCTION ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	GROUP ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	DEDICATION ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	DEBATE ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	CONTRIBUTION ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	CHAPTER ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	BOOK_REVIEW ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	APPENDIX ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	ACKNOWLEDGEMENTS ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	MAP_GROUP ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	ILLUSTRATION_GROUP ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	CHART_DIAGRAM_GROUP ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	TABLE_GROUP ()
	{
	}

	void ct_CHAPTER_LIKE_pskel::
	post_ct_CHAPTER_LIKE ()
	{
	}

	// ct_MAP_GROUP_pskel
	//

	void ct_MAP_GROUP_pskel::
	MAP ()
	{
	}

	void ct_MAP_GROUP_pskel::
	post_ct_MAP_GROUP ()
	{
	}

	// ct_ILLUSTRATION_GROUP_pskel
	//

	void ct_ILLUSTRATION_GROUP_pskel::
	ILLUSTRATION ()
	{
	}

	void ct_ILLUSTRATION_GROUP_pskel::
	post_ct_ILLUSTRATION_GROUP ()
	{
	}

	// ct_CHART_DIAGRAM_GROUP_pskel
	//

	void ct_CHART_DIAGRAM_GROUP_pskel::
	CHART_DIAGRAM ()
	{
	}

	void ct_CHART_DIAGRAM_GROUP_pskel::
	post_ct_CHART_DIAGRAM_GROUP ()
	{
	}

	// ct_TABLE_GROUP_pskel
	//

	void ct_TABLE_GROUP_pskel::
	TABLE ()
	{
	}

	void ct_TABLE_GROUP_pskel::
	post_ct_TABLE_GROUP ()
	{
	}

	// ct_ILLUSTRATION_LIKE_STRUCT_pskel
	//

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	IMAGE ()
	{
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	CAPTION ()
	{
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	post_ct_ILLUSTRATION_LIKE_STRUCT ()
	{
	}

	// ct_TABLE_LIKE_STRUCT_pskel
	//

	void ct_TABLE_LIKE_STRUCT_pskel::
	IMAGE ()
	{
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	CAPTION ()
	{
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	post_ct_TABLE_LIKE_STRUCT ()
	{
	}

	// ct_BODY_pskel
	//

	void ct_BODY_pskel::
	BODY_CONTENT ()
	{
	}

	void ct_BODY_pskel::
	FOOTNOTE ()
	{
	}

	void ct_BODY_pskel::
	MAP ()
	{
	}

	void ct_BODY_pskel::
	ILLUSTRATION ()
	{
	}

	void ct_BODY_pskel::
	CHART_DIAGRAM ()
	{
	}

	void ct_BODY_pskel::
	BOOKPLATE ()
	{
	}

	void ct_BODY_pskel::
	BARCODE ()
	{
	}

	void ct_BODY_pskel::
	TABLE ()
	{
	}

	void ct_BODY_pskel::
	LIST ()
	{
	}

	void ct_BODY_pskel::
	post_ct_BODY ()
	{
	}

	// ct_BODY_CONTENT_pskel
	//

	void ct_BODY_CONTENT_pskel::
	TEXTBLOCK ()
	{
	}

	void ct_BODY_CONTENT_pskel::
	PARAGRAPH ()
	{
	}

	void ct_BODY_CONTENT_pskel::
	FORMULA ()
	{
	}

	void ct_BODY_CONTENT_pskel::
	post_ct_BODY_CONTENT ()
	{
	}

	// ct_FORMULA_pskel
	//

	void ct_FORMULA_pskel::
	IMAGE ()
	{
	}

	void ct_FORMULA_pskel::
	post_ct_FORMULA ()
	{
	}

	// ct_PARAGRAPH_pskel
	//

	void ct_PARAGRAPH_pskel::
	TEXT ()
	{
	}

	void ct_PARAGRAPH_pskel::
	MARGINALIA ()
	{
	}

	void ct_PARAGRAPH_pskel::
	post_ct_PARAGRAPH ()
	{
	}

	// ct_FOOTNOTE_PARAGRAPH_pskel
	//

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	TEXT ()
	{
	}

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	post_ct_FOOTNOTE_PARAGRAPH ()
	{
	}

	// ct_FINAL_pskel
	//

	void ct_FINAL_pskel::
	fptr ()
	{
	}

	void ct_FINAL_pskel::
	post_ct_FINAL ()
	{
	}

	// ct_FPTR_pskel
	//

	void ct_FPTR_pskel::
	area ()
	{
	}

	void ct_FPTR_pskel::
	seq ()
	{
	}

	void ct_FPTR_pskel::
	par ()
	{
	}

	void ct_FPTR_pskel::
	post_ct_FPTR ()
	{
	}

	// ct_SEQ_pskel
	//

	void ct_SEQ_pskel::
	area ()
	{
	}

	void ct_SEQ_pskel::
	post_ct_SEQ ()
	{
	}

	// Serial_pskel
	//

	void Serial_pskel::
	VOLUME ()
	{
	}

	void Serial_pskel::
	post_Serial ()
	{
	}

	// CONTENT_pskel
	//

	void CONTENT_pskel::
	TEXTBLOCK ()
	{
	}

	void CONTENT_pskel::
	TABLE ()
	{
	}

	void CONTENT_pskel::
	PUBLISHING_STMT ()
	{
	}

	void CONTENT_pskel::
	PARAGRAPH ()
	{
	}

	void CONTENT_pskel::
	MAP ()
	{
	}

	void CONTENT_pskel::
	ILLUSTRATION ()
	{
	}

	void CONTENT_pskel::
	CHART_DIAGRAM ()
	{
	}

	void CONTENT_pskel::
	BOOKPLATE ()
	{
	}

	void CONTENT_pskel::
	BARCODE ()
	{
	}

	void CONTENT_pskel::
	SUBHEADLINE ()
	{
	}

	void CONTENT_pskel::
	HEADLINE ()
	{
	}

	void CONTENT_pskel::
	FORMULA ()
	{
	}

	void CONTENT_pskel::
	FOOTNOTE ()
	{
	}

	void CONTENT_pskel::
	AUTHOR ()
	{
	}

	void CONTENT_pskel::
	post_CONTENT ()
	{
	}

	// CONTENT1_pskel
	//

	void CONTENT1_pskel::
	TABLE ()
	{
	}

	void CONTENT1_pskel::
	MAP ()
	{
	}

	void CONTENT1_pskel::
	ILLUSTRATION ()
	{
	}

	void CONTENT1_pskel::
	CHART_DIAGRAM ()
	{
	}

	void CONTENT1_pskel::
	BOOKPLATE ()
	{
	}

	void CONTENT1_pskel::
	BARCODE ()
	{
	}

	void CONTENT1_pskel::
	FORMULA ()
	{
	}

	void CONTENT1_pskel::
	post_CONTENT1 ()
	{
	}

	// DATA_pskel
	//

	void DATA_pskel::
	TEXTBLOCK ()
	{
	}

	void DATA_pskel::
	PAGE_NUMBER ()
	{
	}

	void DATA_pskel::
	ITEM_CAPTION ()
	{
	}

	void DATA_pskel::
	AUTHOR ()
	{
	}

	void DATA_pskel::
	post_DATA ()
	{
	}

	// MOTTO_pskel
	//

	void MOTTO_pskel::
	TEXT ()
	{
	}

	void MOTTO_pskel::
	post_MOTTO ()
	{
	}

	// HEADING_TEXT_pskel
	//

	void HEADING_TEXT_pskel::
	TEXT ()
	{
	}

	void HEADING_TEXT_pskel::
	post_HEADING_TEXT ()
	{
	}

	// par_pskel
	//

	void par_pskel::
	area ()
	{
	}

	void par_pskel::
	seq ()
	{
	}

	void par_pskel::
	post_par ()
	{
	}

	#include <cassert>

	// Element validation and dispatch functions for ct_HIERARCHY_pskel.
	//
	bool ct_HIERARCHY_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "FRONT" && ns.empty ())
			s = 0UL;
		  else if (n == "ISSUE" && ns.empty ())
			s = 1UL;
		  else if (n == "BACK" && ns.empty ())
			s = 2UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_HIERARCHY_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_HIERARCHY_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_HIERARCHY_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_HIERARCHY_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_HIERARCHY_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "FRONT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->FRONT_parser_;

			  if (this->FRONT_parser_)
				this->FRONT_parser_->pre ();
			}
			else
			{
			  if (this->FRONT_parser_)
			  {
				this->FRONT_parser_->post_ct_FRONT ();
				this->FRONT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "ISSUE" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ISSUE_parser_;

			  if (this->ISSUE_parser_)
				this->ISSUE_parser_->pre ();
			}
			else
			{
			  if (this->ISSUE_parser_)
			  {
				this->ISSUE_parser_->post_ct_ISSUE ();
				this->ISSUE ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 2UL;
			// Fall through.
		  }
		}
		case 2UL:
		{
		  if (n == "BACK" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->BACK_parser_;

			  if (this->BACK_parser_)
				this->BACK_parser_->pre ();
			}
			else
			{
			  if (this->BACK_parser_)
			  {
				this->BACK_parser_->post_ct_BACK ();
				this->BACK ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_FRONT_pskel.
	//
	bool ct_FRONT_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if ((n == "TITLE_SECTION" && ns.empty ()) ||
			  (n == "STATEMENT_SECTION" && ns.empty ()) ||
			  (n == "PICTURE_SECTION" && ns.empty ()) ||
			  (n == "FRONTISPIECE" && ns.empty ()) ||
			  (n == "COVER_SECTION" && ns.empty ()) ||
			  (n == "BASTARD_TITLE_SECTION" && ns.empty ()) ||
			  (n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
			  (n == "REFERENCE_LIST" && ns.empty ()) ||
			  (n == "LIST_OF_PUBLICATIONS" && ns.empty ()) ||
			  (n == "LIST_OF_FIGURES" && ns.empty ()) ||
			  (n == "INDEX" && ns.empty ()) ||
			  (n == "CORRECTIONS" && ns.empty ()) ||
			  (n == "BIBLIOGRAPHY" && ns.empty ()) ||
			  (n == "ABBREVIATIONS" && ns.empty ()) ||
			  (n == "RIDAS" && ns.empty ()) ||
			  (n == "PRODUCTION_NOTE" && ns.empty ()) ||
			  (n == "PREFACE" && ns.empty ()) ||
			  (n == "NECROLOGY" && ns.empty ()) ||
			  (n == "INTRODUCTION" && ns.empty ()) ||
			  (n == "DEDICATION" && ns.empty ()) ||
			  (n == "CHAPTER" && ns.empty ()) ||
			  (n == "ACKNOWLEDGEMENTS" && ns.empty ()) ||
			  (n == "ABSTRACT" && ns.empty ()))
			s = 0UL;
		  else if (n == "ADVERTISEMENT" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_FRONT_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_FRONT_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_FRONT_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_FRONT_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_FRONT_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  unsigned long s (~0UL);

		  if (n == "TITLE_SECTION" && ns.empty ())
			s = 0UL;
		  else if (n == "STATEMENT_SECTION" && ns.empty ())
			s = 1UL;
		  else if (n == "PICTURE_SECTION" && ns.empty ())
			s = 2UL;
		  else if (n == "FRONTISPIECE" && ns.empty ())
			s = 3UL;
		  else if (n == "COVER_SECTION" && ns.empty ())
			s = 4UL;
		  else if (n == "BASTARD_TITLE_SECTION" && ns.empty ())
			s = 5UL;
		  else if (n == "TABLE_OF_CONTENTS" && ns.empty ())
			s = 6UL;
		  else if (n == "REFERENCE_LIST" && ns.empty ())
			s = 7UL;
		  else if (n == "LIST_OF_PUBLICATIONS" && ns.empty ())
			s = 8UL;
		  else if (n == "LIST_OF_FIGURES" && ns.empty ())
			s = 9UL;
		  else if (n == "INDEX" && ns.empty ())
			s = 10UL;
		  else if (n == "CORRECTIONS" && ns.empty ())
			s = 11UL;
		  else if (n == "BIBLIOGRAPHY" && ns.empty ())
			s = 12UL;
		  else if (n == "ABBREVIATIONS" && ns.empty ())
			s = 13UL;
		  else if (n == "RIDAS" && ns.empty ())
			s = 14UL;
		  else if (n == "PRODUCTION_NOTE" && ns.empty ())
			s = 15UL;
		  else if (n == "PREFACE" && ns.empty ())
			s = 16UL;
		  else if (n == "NECROLOGY" && ns.empty ())
			s = 17UL;
		  else if (n == "INTRODUCTION" && ns.empty ())
			s = 18UL;
		  else if (n == "DEDICATION" && ns.empty ())
			s = 19UL;
		  else if (n == "CHAPTER" && ns.empty ())
			s = 20UL;
		  else if (n == "ACKNOWLEDGEMENTS" && ns.empty ())
			s = 21UL;
		  else if (n == "ABSTRACT" && ns.empty ())
			s = 22UL;

		  if (s != ~0UL)
		  {
			assert (start);
			count++;

			v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
			v_state_descr_& vd = vs.data[vs.size++];

			vd.func = &ct_FRONT_pskel::choice_0;
			vd.state = s;
			vd.count = 0;

			this->choice_0 (vd.state, vd.count, ns, n, t, true);
			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "ADVERTISEMENT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ADVERTISEMENT_parser_;

			  if (this->ADVERTISEMENT_parser_)
				this->ADVERTISEMENT_parser_->pre ();
			}
			else
			{
			  if (this->ADVERTISEMENT_parser_)
			  {
				this->ADVERTISEMENT_parser_->post_ct_FINAL ();
				this->ADVERTISEMENT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	void ct_FRONT_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_SECTION_parser_;

			if (this->TITLE_SECTION_parser_)
			  this->TITLE_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->TITLE_SECTION_parser_)
			{
			  this->TITLE_SECTION_parser_->post_ct_TITLE_SECTION ();
			  this->TITLE_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->STATEMENT_SECTION_parser_;

			if (this->STATEMENT_SECTION_parser_)
			  this->STATEMENT_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->STATEMENT_SECTION_parser_)
			{
			  this->STATEMENT_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->STATEMENT_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PICTURE_SECTION_parser_;

			if (this->PICTURE_SECTION_parser_)
			  this->PICTURE_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->PICTURE_SECTION_parser_)
			{
			  this->PICTURE_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->PICTURE_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FRONTISPIECE_parser_;

			if (this->FRONTISPIECE_parser_)
			  this->FRONTISPIECE_parser_->pre ();
		  }
		  else
		  {
			if (this->FRONTISPIECE_parser_)
			{
			  this->FRONTISPIECE_parser_->post_ct_PAGE_LIKE ();
			  this->FRONTISPIECE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->COVER_SECTION_parser_;

			if (this->COVER_SECTION_parser_)
			  this->COVER_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->COVER_SECTION_parser_)
			{
			  this->COVER_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->COVER_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BASTARD_TITLE_SECTION_parser_;

			if (this->BASTARD_TITLE_SECTION_parser_)
			  this->BASTARD_TITLE_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->BASTARD_TITLE_SECTION_parser_)
			{
			  this->BASTARD_TITLE_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->BASTARD_TITLE_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

			if (this->TABLE_OF_CONTENTS_parser_)
			  this->TABLE_OF_CONTENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_OF_CONTENTS_parser_)
			{
			  this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
			  this->TABLE_OF_CONTENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->REFERENCE_LIST_parser_;

			if (this->REFERENCE_LIST_parser_)
			  this->REFERENCE_LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->REFERENCE_LIST_parser_)
			{
			  this->REFERENCE_LIST_parser_->post_ct_LIST_LIKE ();
			  this->REFERENCE_LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_PUBLICATIONS_parser_;

			if (this->LIST_OF_PUBLICATIONS_parser_)
			  this->LIST_OF_PUBLICATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_PUBLICATIONS_parser_)
			{
			  this->LIST_OF_PUBLICATIONS_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_PUBLICATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 9UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_FIGURES_parser_;

			if (this->LIST_OF_FIGURES_parser_)
			  this->LIST_OF_FIGURES_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_FIGURES_parser_)
			{
			  this->LIST_OF_FIGURES_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_FIGURES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 10UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INDEX_parser_;

			if (this->INDEX_parser_)
			  this->INDEX_parser_->pre ();
		  }
		  else
		  {
			if (this->INDEX_parser_)
			{
			  this->INDEX_parser_->post_ct_LIST_LIKE ();
			  this->INDEX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 11UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CORRECTIONS_parser_;

			if (this->CORRECTIONS_parser_)
			  this->CORRECTIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->CORRECTIONS_parser_)
			{
			  this->CORRECTIONS_parser_->post_ct_LIST_LIKE ();
			  this->CORRECTIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 12UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BIBLIOGRAPHY_parser_;

			if (this->BIBLIOGRAPHY_parser_)
			  this->BIBLIOGRAPHY_parser_->pre ();
		  }
		  else
		  {
			if (this->BIBLIOGRAPHY_parser_)
			{
			  this->BIBLIOGRAPHY_parser_->post_ct_LIST_LIKE ();
			  this->BIBLIOGRAPHY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 13UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABBREVIATIONS_parser_;

			if (this->ABBREVIATIONS_parser_)
			  this->ABBREVIATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->ABBREVIATIONS_parser_)
			{
			  this->ABBREVIATIONS_parser_->post_ct_LIST_LIKE ();
			  this->ABBREVIATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 14UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

			if (this->RIDAS_parser_)
			  this->RIDAS_parser_->pre ();
		  }
		  else
		  {
			if (this->RIDAS_parser_)
			{
			  this->RIDAS_parser_->post_ct_CHAPTER_LIKE ();
			  this->RIDAS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 15UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PRODUCTION_NOTE_parser_;

			if (this->PRODUCTION_NOTE_parser_)
			  this->PRODUCTION_NOTE_parser_->pre ();
		  }
		  else
		  {
			if (this->PRODUCTION_NOTE_parser_)
			{
			  this->PRODUCTION_NOTE_parser_->post_ct_CHAPTER_LIKE ();
			  this->PRODUCTION_NOTE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 16UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PREFACE_parser_;

			if (this->PREFACE_parser_)
			  this->PREFACE_parser_->pre ();
		  }
		  else
		  {
			if (this->PREFACE_parser_)
			{
			  this->PREFACE_parser_->post_ct_CHAPTER_LIKE ();
			  this->PREFACE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 17UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

			if (this->NECROLOGY_parser_)
			  this->NECROLOGY_parser_->pre ();
		  }
		  else
		  {
			if (this->NECROLOGY_parser_)
			{
			  this->NECROLOGY_parser_->post_ct_CHAPTER_LIKE ();
			  this->NECROLOGY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 18UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INTRODUCTION_parser_;

			if (this->INTRODUCTION_parser_)
			  this->INTRODUCTION_parser_->pre ();
		  }
		  else
		  {
			if (this->INTRODUCTION_parser_)
			{
			  this->INTRODUCTION_parser_->post_ct_CHAPTER_LIKE ();
			  this->INTRODUCTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 19UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->DEDICATION_parser_;

			if (this->DEDICATION_parser_)
			  this->DEDICATION_parser_->pre ();
		  }
		  else
		  {
			if (this->DEDICATION_parser_)
			{
			  this->DEDICATION_parser_->post_ct_CHAPTER_LIKE ();
			  this->DEDICATION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 20UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHAPTER_parser_;

			if (this->CHAPTER_parser_)
			  this->CHAPTER_parser_->pre ();
		  }
		  else
		  {
			if (this->CHAPTER_parser_)
			{
			  this->CHAPTER_parser_->post_ct_CHAPTER_LIKE ();
			  this->CHAPTER ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 21UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENTS_parser_;

			if (this->ACKNOWLEDGEMENTS_parser_)
			  this->ACKNOWLEDGEMENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->ACKNOWLEDGEMENTS_parser_)
			{
			  this->ACKNOWLEDGEMENTS_parser_->post_ct_CHAPTER_LIKE ();
			  this->ACKNOWLEDGEMENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 22UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABSTRACT_parser_;

			if (this->ABSTRACT_parser_)
			  this->ABSTRACT_parser_->pre ();
		  }
		  else
		  {
			if (this->ABSTRACT_parser_)
			{
			  this->ABSTRACT_parser_->post_ct_CHAPTER_LIKE ();
			  this->ABSTRACT ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_MAIN_pskel.
	//
	bool ct_MAIN_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if ((n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
			  (n == "REFERENCE_LIST" && ns.empty ()) ||
			  (n == "LIST_OF_PUBLICATIONS" && ns.empty ()) ||
			  (n == "LIST_OF_FIGURES" && ns.empty ()) ||
			  (n == "LIST" && ns.empty ()) ||
			  (n == "INDEX" && ns.empty ()) ||
			  (n == "CORRECTIONS" && ns.empty ()) ||
			  (n == "BIBLIOGRAPHY" && ns.empty ()) ||
			  (n == "ABBREVIATIONS" && ns.empty ()) ||
			  (n == "RIDAS" && ns.empty ()) ||
			  (n == "PRODUCTION_NOTE" && ns.empty ()) ||
			  (n == "PREFACE" && ns.empty ()) ||
			  (n == "POSTFACE" && ns.empty ()) ||
			  (n == "POEM" && ns.empty ()) ||
			  (n == "NOTES" && ns.empty ()) ||
			  (n == "NECROLOGY" && ns.empty ()) ||
			  (n == "INTRODUCTION" && ns.empty ()) ||
			  (n == "GROUP" && ns.empty ()) ||
			  (n == "DEDICATION" && ns.empty ()) ||
			  (n == "DEBATE" && ns.empty ()) ||
			  (n == "CONTRIBUTION" && ns.empty ()) ||
			  (n == "CHAPTER" && ns.empty ()) ||
			  (n == "BOOK_REVIEW" && ns.empty ()) ||
			  (n == "APPENDIX" && ns.empty ()) ||
			  (n == "ACKNOWLEDGEMENTS" && ns.empty ()) ||
			  (n == "ABSTRACT" && ns.empty ()))
			s = 0UL;
		  else if (n == "ADVERTISEMENT" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_MAIN_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_MAIN_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_MAIN_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_MAIN_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_MAIN_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  unsigned long s (~0UL);

		  if (n == "TABLE_OF_CONTENTS" && ns.empty ())
			s = 0UL;
		  else if (n == "REFERENCE_LIST" && ns.empty ())
			s = 1UL;
		  else if (n == "LIST_OF_PUBLICATIONS" && ns.empty ())
			s = 2UL;
		  else if (n == "LIST_OF_FIGURES" && ns.empty ())
			s = 3UL;
		  else if (n == "LIST" && ns.empty ())
			s = 4UL;
		  else if (n == "INDEX" && ns.empty ())
			s = 5UL;
		  else if (n == "CORRECTIONS" && ns.empty ())
			s = 6UL;
		  else if (n == "BIBLIOGRAPHY" && ns.empty ())
			s = 7UL;
		  else if (n == "ABBREVIATIONS" && ns.empty ())
			s = 8UL;
		  else if (n == "RIDAS" && ns.empty ())
			s = 9UL;
		  else if (n == "PRODUCTION_NOTE" && ns.empty ())
			s = 10UL;
		  else if (n == "PREFACE" && ns.empty ())
			s = 11UL;
		  else if (n == "POSTFACE" && ns.empty ())
			s = 12UL;
		  else if (n == "POEM" && ns.empty ())
			s = 13UL;
		  else if (n == "NOTES" && ns.empty ())
			s = 14UL;
		  else if (n == "NECROLOGY" && ns.empty ())
			s = 15UL;
		  else if (n == "INTRODUCTION" && ns.empty ())
			s = 16UL;
		  else if (n == "GROUP" && ns.empty ())
			s = 17UL;
		  else if (n == "DEDICATION" && ns.empty ())
			s = 18UL;
		  else if (n == "DEBATE" && ns.empty ())
			s = 19UL;
		  else if (n == "CONTRIBUTION" && ns.empty ())
			s = 20UL;
		  else if (n == "CHAPTER" && ns.empty ())
			s = 21UL;
		  else if (n == "BOOK_REVIEW" && ns.empty ())
			s = 22UL;
		  else if (n == "APPENDIX" && ns.empty ())
			s = 23UL;
		  else if (n == "ACKNOWLEDGEMENTS" && ns.empty ())
			s = 24UL;
		  else if (n == "ABSTRACT" && ns.empty ())
			s = 25UL;

		  if (s != ~0UL)
		  {
			assert (start);
			count++;

			v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
			v_state_descr_& vd = vs.data[vs.size++];

			vd.func = &ct_MAIN_pskel::choice_0;
			vd.state = s;
			vd.count = 0;

			this->choice_0 (vd.state, vd.count, ns, n, t, true);
			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "ADVERTISEMENT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ADVERTISEMENT_parser_;

			  if (this->ADVERTISEMENT_parser_)
				this->ADVERTISEMENT_parser_->pre ();
			}
			else
			{
			  if (this->ADVERTISEMENT_parser_)
			  {
				this->ADVERTISEMENT_parser_->post_ct_FINAL ();
				this->ADVERTISEMENT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	void ct_MAIN_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

			if (this->TABLE_OF_CONTENTS_parser_)
			  this->TABLE_OF_CONTENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_OF_CONTENTS_parser_)
			{
			  this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
			  this->TABLE_OF_CONTENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->REFERENCE_LIST_parser_;

			if (this->REFERENCE_LIST_parser_)
			  this->REFERENCE_LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->REFERENCE_LIST_parser_)
			{
			  this->REFERENCE_LIST_parser_->post_ct_LIST_LIKE ();
			  this->REFERENCE_LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_PUBLICATIONS_parser_;

			if (this->LIST_OF_PUBLICATIONS_parser_)
			  this->LIST_OF_PUBLICATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_PUBLICATIONS_parser_)
			{
			  this->LIST_OF_PUBLICATIONS_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_PUBLICATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_FIGURES_parser_;

			if (this->LIST_OF_FIGURES_parser_)
			  this->LIST_OF_FIGURES_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_FIGURES_parser_)
			{
			  this->LIST_OF_FIGURES_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_FIGURES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

			if (this->LIST_parser_)
			  this->LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_parser_)
			{
			  this->LIST_parser_->post_ct_LIST_LIKE ();
			  this->LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INDEX_parser_;

			if (this->INDEX_parser_)
			  this->INDEX_parser_->pre ();
		  }
		  else
		  {
			if (this->INDEX_parser_)
			{
			  this->INDEX_parser_->post_ct_LIST_LIKE ();
			  this->INDEX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CORRECTIONS_parser_;

			if (this->CORRECTIONS_parser_)
			  this->CORRECTIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->CORRECTIONS_parser_)
			{
			  this->CORRECTIONS_parser_->post_ct_LIST_LIKE ();
			  this->CORRECTIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BIBLIOGRAPHY_parser_;

			if (this->BIBLIOGRAPHY_parser_)
			  this->BIBLIOGRAPHY_parser_->pre ();
		  }
		  else
		  {
			if (this->BIBLIOGRAPHY_parser_)
			{
			  this->BIBLIOGRAPHY_parser_->post_ct_LIST_LIKE ();
			  this->BIBLIOGRAPHY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABBREVIATIONS_parser_;

			if (this->ABBREVIATIONS_parser_)
			  this->ABBREVIATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->ABBREVIATIONS_parser_)
			{
			  this->ABBREVIATIONS_parser_->post_ct_LIST_LIKE ();
			  this->ABBREVIATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 9UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

			if (this->RIDAS_parser_)
			  this->RIDAS_parser_->pre ();
		  }
		  else
		  {
			if (this->RIDAS_parser_)
			{
			  this->RIDAS_parser_->post_ct_CHAPTER_LIKE ();
			  this->RIDAS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 10UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PRODUCTION_NOTE_parser_;

			if (this->PRODUCTION_NOTE_parser_)
			  this->PRODUCTION_NOTE_parser_->pre ();
		  }
		  else
		  {
			if (this->PRODUCTION_NOTE_parser_)
			{
			  this->PRODUCTION_NOTE_parser_->post_ct_CHAPTER_LIKE ();
			  this->PRODUCTION_NOTE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 11UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PREFACE_parser_;

			if (this->PREFACE_parser_)
			  this->PREFACE_parser_->pre ();
		  }
		  else
		  {
			if (this->PREFACE_parser_)
			{
			  this->PREFACE_parser_->post_ct_CHAPTER_LIKE ();
			  this->PREFACE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 12UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->POSTFACE_parser_;

			if (this->POSTFACE_parser_)
			  this->POSTFACE_parser_->pre ();
		  }
		  else
		  {
			if (this->POSTFACE_parser_)
			{
			  this->POSTFACE_parser_->post_ct_CHAPTER_LIKE ();
			  this->POSTFACE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 13UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->POEM_parser_;

			if (this->POEM_parser_)
			  this->POEM_parser_->pre ();
		  }
		  else
		  {
			if (this->POEM_parser_)
			{
			  this->POEM_parser_->post_ct_CHAPTER_LIKE ();
			  this->POEM ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 14UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->NOTES_parser_;

			if (this->NOTES_parser_)
			  this->NOTES_parser_->pre ();
		  }
		  else
		  {
			if (this->NOTES_parser_)
			{
			  this->NOTES_parser_->post_ct_CHAPTER_LIKE ();
			  this->NOTES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 15UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

			if (this->NECROLOGY_parser_)
			  this->NECROLOGY_parser_->pre ();
		  }
		  else
		  {
			if (this->NECROLOGY_parser_)
			{
			  this->NECROLOGY_parser_->post_ct_CHAPTER_LIKE ();
			  this->NECROLOGY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 16UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INTRODUCTION_parser_;

			if (this->INTRODUCTION_parser_)
			  this->INTRODUCTION_parser_->pre ();
		  }
		  else
		  {
			if (this->INTRODUCTION_parser_)
			{
			  this->INTRODUCTION_parser_->post_ct_CHAPTER_LIKE ();
			  this->INTRODUCTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 17UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->GROUP_parser_;

			if (this->GROUP_parser_)
			  this->GROUP_parser_->pre ();
		  }
		  else
		  {
			if (this->GROUP_parser_)
			{
			  this->GROUP_parser_->post_ct_CHAPTER_LIKE ();
			  this->GROUP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 18UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->DEDICATION_parser_;

			if (this->DEDICATION_parser_)
			  this->DEDICATION_parser_->pre ();
		  }
		  else
		  {
			if (this->DEDICATION_parser_)
			{
			  this->DEDICATION_parser_->post_ct_CHAPTER_LIKE ();
			  this->DEDICATION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 19UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->DEBATE_parser_;

			if (this->DEBATE_parser_)
			  this->DEBATE_parser_->pre ();
		  }
		  else
		  {
			if (this->DEBATE_parser_)
			{
			  this->DEBATE_parser_->post_ct_CHAPTER_LIKE ();
			  this->DEBATE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 20UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTRIBUTION_parser_;

			if (this->CONTRIBUTION_parser_)
			  this->CONTRIBUTION_parser_->pre ();
		  }
		  else
		  {
			if (this->CONTRIBUTION_parser_)
			{
			  this->CONTRIBUTION_parser_->post_ct_CHAPTER_LIKE ();
			  this->CONTRIBUTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 21UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHAPTER_parser_;

			if (this->CHAPTER_parser_)
			  this->CHAPTER_parser_->pre ();
		  }
		  else
		  {
			if (this->CHAPTER_parser_)
			{
			  this->CHAPTER_parser_->post_ct_CHAPTER_LIKE ();
			  this->CHAPTER ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 22UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BOOK_REVIEW_parser_;

			if (this->BOOK_REVIEW_parser_)
			  this->BOOK_REVIEW_parser_->pre ();
		  }
		  else
		  {
			if (this->BOOK_REVIEW_parser_)
			{
			  this->BOOK_REVIEW_parser_->post_ct_CHAPTER_LIKE ();
			  this->BOOK_REVIEW ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 23UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->APPENDIX_parser_;

			if (this->APPENDIX_parser_)
			  this->APPENDIX_parser_->pre ();
		  }
		  else
		  {
			if (this->APPENDIX_parser_)
			{
			  this->APPENDIX_parser_->post_ct_CHAPTER_LIKE ();
			  this->APPENDIX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 24UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENTS_parser_;

			if (this->ACKNOWLEDGEMENTS_parser_)
			  this->ACKNOWLEDGEMENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->ACKNOWLEDGEMENTS_parser_)
			{
			  this->ACKNOWLEDGEMENTS_parser_->post_ct_CHAPTER_LIKE ();
			  this->ACKNOWLEDGEMENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 25UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABSTRACT_parser_;

			if (this->ABSTRACT_parser_)
			  this->ABSTRACT_parser_->pre ();
		  }
		  else
		  {
			if (this->ABSTRACT_parser_)
			{
			  this->ABSTRACT_parser_->post_ct_CHAPTER_LIKE ();
			  this->ABSTRACT ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_BACK_pskel.
	//
	bool ct_BACK_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if ((n == "STATEMENT_SECTION" && ns.empty ()) ||
			  (n == "PICTURE_SECTION" && ns.empty ()) ||
			  (n == "COVER_SECTION" && ns.empty ()) ||
			  (n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
			  (n == "REFERENCE_LIST" && ns.empty ()) ||
			  (n == "LIST_OF_PUBLICATIONS" && ns.empty ()) ||
			  (n == "LIST_OF_FIGURES" && ns.empty ()) ||
			  (n == "LIST" && ns.empty ()) ||
			  (n == "INDEX" && ns.empty ()) ||
			  (n == "CORRECTIONS" && ns.empty ()) ||
			  (n == "BIBLIOGRAPHY" && ns.empty ()) ||
			  (n == "ABBREVIATIONS" && ns.empty ()) ||
			  (n == "RIDAS" && ns.empty ()) ||
			  (n == "POSTFACE" && ns.empty ()) ||
			  (n == "NECROLOGY" && ns.empty ()) ||
			  (n == "CHAPTER" && ns.empty ()) ||
			  (n == "APPENDIX" && ns.empty ()) ||
			  (n == "ACKNOWLEDGEMENTS" && ns.empty ()))
			s = 0UL;
		  else if (n == "ADVERTISEMENT" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_BACK_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_BACK_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_BACK_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_BACK_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_BACK_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  unsigned long s (~0UL);

		  if (n == "STATEMENT_SECTION" && ns.empty ())
			s = 0UL;
		  else if (n == "PICTURE_SECTION" && ns.empty ())
			s = 1UL;
		  else if (n == "COVER_SECTION" && ns.empty ())
			s = 2UL;
		  else if (n == "TABLE_OF_CONTENTS" && ns.empty ())
			s = 3UL;
		  else if (n == "REFERENCE_LIST" && ns.empty ())
			s = 4UL;
		  else if (n == "LIST_OF_PUBLICATIONS" && ns.empty ())
			s = 5UL;
		  else if (n == "LIST_OF_FIGURES" && ns.empty ())
			s = 6UL;
		  else if (n == "LIST" && ns.empty ())
			s = 7UL;
		  else if (n == "INDEX" && ns.empty ())
			s = 8UL;
		  else if (n == "CORRECTIONS" && ns.empty ())
			s = 9UL;
		  else if (n == "BIBLIOGRAPHY" && ns.empty ())
			s = 10UL;
		  else if (n == "ABBREVIATIONS" && ns.empty ())
			s = 11UL;
		  else if (n == "RIDAS" && ns.empty ())
			s = 12UL;
		  else if (n == "POSTFACE" && ns.empty ())
			s = 13UL;
		  else if (n == "NECROLOGY" && ns.empty ())
			s = 14UL;
		  else if (n == "CHAPTER" && ns.empty ())
			s = 15UL;
		  else if (n == "APPENDIX" && ns.empty ())
			s = 16UL;
		  else if (n == "ACKNOWLEDGEMENTS" && ns.empty ())
			s = 17UL;

		  if (s != ~0UL)
		  {
			assert (start);
			count++;

			v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
			v_state_descr_& vd = vs.data[vs.size++];

			vd.func = &ct_BACK_pskel::choice_0;
			vd.state = s;
			vd.count = 0;

			this->choice_0 (vd.state, vd.count, ns, n, t, true);
			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "ADVERTISEMENT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ADVERTISEMENT_parser_;

			  if (this->ADVERTISEMENT_parser_)
				this->ADVERTISEMENT_parser_->pre ();
			}
			else
			{
			  if (this->ADVERTISEMENT_parser_)
			  {
				this->ADVERTISEMENT_parser_->post_ct_FINAL ();
				this->ADVERTISEMENT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	void ct_BACK_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->STATEMENT_SECTION_parser_;

			if (this->STATEMENT_SECTION_parser_)
			  this->STATEMENT_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->STATEMENT_SECTION_parser_)
			{
			  this->STATEMENT_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->STATEMENT_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PICTURE_SECTION_parser_;

			if (this->PICTURE_SECTION_parser_)
			  this->PICTURE_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->PICTURE_SECTION_parser_)
			{
			  this->PICTURE_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->PICTURE_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->COVER_SECTION_parser_;

			if (this->COVER_SECTION_parser_)
			  this->COVER_SECTION_parser_->pre ();
		  }
		  else
		  {
			if (this->COVER_SECTION_parser_)
			{
			  this->COVER_SECTION_parser_->post_ct_PAGE_LIKE ();
			  this->COVER_SECTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

			if (this->TABLE_OF_CONTENTS_parser_)
			  this->TABLE_OF_CONTENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_OF_CONTENTS_parser_)
			{
			  this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
			  this->TABLE_OF_CONTENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->REFERENCE_LIST_parser_;

			if (this->REFERENCE_LIST_parser_)
			  this->REFERENCE_LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->REFERENCE_LIST_parser_)
			{
			  this->REFERENCE_LIST_parser_->post_ct_LIST_LIKE ();
			  this->REFERENCE_LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_PUBLICATIONS_parser_;

			if (this->LIST_OF_PUBLICATIONS_parser_)
			  this->LIST_OF_PUBLICATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_PUBLICATIONS_parser_)
			{
			  this->LIST_OF_PUBLICATIONS_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_PUBLICATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_FIGURES_parser_;

			if (this->LIST_OF_FIGURES_parser_)
			  this->LIST_OF_FIGURES_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_FIGURES_parser_)
			{
			  this->LIST_OF_FIGURES_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_FIGURES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

			if (this->LIST_parser_)
			  this->LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_parser_)
			{
			  this->LIST_parser_->post_ct_LIST_LIKE ();
			  this->LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INDEX_parser_;

			if (this->INDEX_parser_)
			  this->INDEX_parser_->pre ();
		  }
		  else
		  {
			if (this->INDEX_parser_)
			{
			  this->INDEX_parser_->post_ct_LIST_LIKE ();
			  this->INDEX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 9UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CORRECTIONS_parser_;

			if (this->CORRECTIONS_parser_)
			  this->CORRECTIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->CORRECTIONS_parser_)
			{
			  this->CORRECTIONS_parser_->post_ct_LIST_LIKE ();
			  this->CORRECTIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 10UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BIBLIOGRAPHY_parser_;

			if (this->BIBLIOGRAPHY_parser_)
			  this->BIBLIOGRAPHY_parser_->pre ();
		  }
		  else
		  {
			if (this->BIBLIOGRAPHY_parser_)
			{
			  this->BIBLIOGRAPHY_parser_->post_ct_LIST_LIKE ();
			  this->BIBLIOGRAPHY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 11UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABBREVIATIONS_parser_;

			if (this->ABBREVIATIONS_parser_)
			  this->ABBREVIATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->ABBREVIATIONS_parser_)
			{
			  this->ABBREVIATIONS_parser_->post_ct_LIST_LIKE ();
			  this->ABBREVIATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 12UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

			if (this->RIDAS_parser_)
			  this->RIDAS_parser_->pre ();
		  }
		  else
		  {
			if (this->RIDAS_parser_)
			{
			  this->RIDAS_parser_->post_ct_CHAPTER_LIKE ();
			  this->RIDAS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 13UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->POSTFACE_parser_;

			if (this->POSTFACE_parser_)
			  this->POSTFACE_parser_->pre ();
		  }
		  else
		  {
			if (this->POSTFACE_parser_)
			{
			  this->POSTFACE_parser_->post_ct_CHAPTER_LIKE ();
			  this->POSTFACE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 14UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

			if (this->NECROLOGY_parser_)
			  this->NECROLOGY_parser_->pre ();
		  }
		  else
		  {
			if (this->NECROLOGY_parser_)
			{
			  this->NECROLOGY_parser_->post_ct_CHAPTER_LIKE ();
			  this->NECROLOGY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 15UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHAPTER_parser_;

			if (this->CHAPTER_parser_)
			  this->CHAPTER_parser_->pre ();
		  }
		  else
		  {
			if (this->CHAPTER_parser_)
			{
			  this->CHAPTER_parser_->post_ct_CHAPTER_LIKE ();
			  this->CHAPTER ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 16UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->APPENDIX_parser_;

			if (this->APPENDIX_parser_)
			  this->APPENDIX_parser_->pre ();
		  }
		  else
		  {
			if (this->APPENDIX_parser_)
			{
			  this->APPENDIX_parser_->post_ct_CHAPTER_LIKE ();
			  this->APPENDIX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 17UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENTS_parser_;

			if (this->ACKNOWLEDGEMENTS_parser_)
			  this->ACKNOWLEDGEMENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->ACKNOWLEDGEMENTS_parser_)
			{
			  this->ACKNOWLEDGEMENTS_parser_->post_ct_CHAPTER_LIKE ();
			  this->ACKNOWLEDGEMENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_ISSUE_pskel.
	//
	bool ct_ISSUE_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "MAIN" && ns.empty ())
			s = 0UL;
		  else if (n == "FRONT" && ns.empty ())
			s = 1UL;
		  else if (n == "BACK" && ns.empty ())
			s = 2UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_ISSUE_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_ISSUE_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_ISSUE_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_ISSUE_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_ISSUE_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->MAIN_parser_;

			if (this->MAIN_parser_)
			  this->MAIN_parser_->pre ();
		  }
		  else
		  {
			if (this->MAIN_parser_)
			{
			  this->MAIN_parser_->post_ct_MAIN ();
			  this->MAIN ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FRONT_parser_;

			if (this->FRONT_parser_)
			  this->FRONT_parser_->pre ();
		  }
		  else
		  {
			if (this->FRONT_parser_)
			{
			  this->FRONT_parser_->post_ct_FRONT ();
			  this->FRONT ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BACK_parser_;

			if (this->BACK_parser_)
			  this->BACK_parser_->pre ();
		  }
		  else
		  {
			if (this->BACK_parser_)
			{
			  this->BACK_parser_->post_ct_BACK ();
			  this->BACK ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_PAGE_LIKE_pskel.
	//
	bool ct_PAGE_LIKE_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "CONTENT" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_PAGE_LIKE_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_PAGE_LIKE_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_PAGE_LIKE_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_PAGE_LIKE_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_PAGE_LIKE_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "CONTENT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTENT_parser_;

			  if (this->CONTENT_parser_)
				this->CONTENT_parser_->pre ();
			}
			else
			{
			  if (this->CONTENT_parser_)
			  {
				this->CONTENT_parser_->post_CONTENT ();
				this->CONTENT ();
			  }

			  count = 0;
			  state = ~0UL;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_TITLE_SECTION_pskel.
	//
	bool ct_TITLE_SECTION_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TITLE_OF_WORK" && ns.empty ())
			s = 0UL;
		  else if (n == "CREATOR_OF_WORK" && ns.empty ())
			s = 1UL;
		  else if (n == "PUBLISHING_STMT" && ns.empty ())
			s = 2UL;
		  else if (n == "STATEMENT" && ns.empty ())
			s = 3UL;
		  else if (n == "CONTENT" && ns.empty ())
			s = 4UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_TITLE_SECTION_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_TITLE_SECTION_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_TITLE_SECTION_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_TITLE_SECTION_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_TITLE_SECTION_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TITLE_OF_WORK" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_OF_WORK_parser_;

			  if (this->TITLE_OF_WORK_parser_)
				this->TITLE_OF_WORK_parser_->pre ();
			}
			else
			{
			  if (this->TITLE_OF_WORK_parser_)
			  {
				this->TITLE_OF_WORK_parser_->post_ct_FINAL ();
				this->TITLE_OF_WORK ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "CREATOR_OF_WORK" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->CREATOR_OF_WORK_parser_;

			  if (this->CREATOR_OF_WORK_parser_)
				this->CREATOR_OF_WORK_parser_->pre ();
			}
			else
			{
			  if (this->CREATOR_OF_WORK_parser_)
			  {
				this->CREATOR_OF_WORK_parser_->post_ct_FINAL ();
				this->CREATOR_OF_WORK ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 2UL;
			// Fall through.
		  }
		}
		case 2UL:
		{
		  if (n == "PUBLISHING_STMT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

			  if (this->PUBLISHING_STMT_parser_)
				this->PUBLISHING_STMT_parser_->pre ();
			}
			else
			{
			  if (this->PUBLISHING_STMT_parser_)
			  {
				this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
				this->PUBLISHING_STMT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 3UL;
			// Fall through.
		  }
		}
		case 3UL:
		{
		  if (n == "STATEMENT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->STATEMENT_parser_;

			  if (this->STATEMENT_parser_)
				this->STATEMENT_parser_->pre ();
			}
			else
			{
			  if (this->STATEMENT_parser_)
			  {
				this->STATEMENT_parser_->post_ct_FINAL ();
				this->STATEMENT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 4UL;
			// Fall through.
		  }
		}
		case 4UL:
		{
		  if (n == "CONTENT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTENT_parser_;

			  if (this->CONTENT_parser_)
				this->CONTENT_parser_->pre ();
			}
			else
			{
			  if (this->CONTENT_parser_)
			  {
				this->CONTENT_parser_->post_CONTENT1 ();
				this->CONTENT ();
			  }

			  count = 0;
			  state = ~0UL;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_LIST_LIKE_pskel.
	//
	bool ct_LIST_LIKE_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "CAPTION" && ns.empty ())
			s = 0UL;
		  else if (n == "DATA" && ns.empty ())
			s = 1UL;
		  else if ((n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
				   (n == "REFERENCE_LIST" && ns.empty ()) ||
				   (n == "LIST_OF_PUBLICATIONS" && ns.empty ()) ||
				   (n == "LIST_OF_FIGURES" && ns.empty ()) ||
				   (n == "LIST" && ns.empty ()) ||
				   (n == "INDEX" && ns.empty ()) ||
				   (n == "CORRECTIONS" && ns.empty ()) ||
				   (n == "BIBLIOGRAPHY" && ns.empty ()) ||
				   (n == "ABBREVIATIONS" && ns.empty ()) ||
				   (n == "ITEM" && ns.empty ()))
			s = 2UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_LIST_LIKE_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_LIST_LIKE_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_LIST_LIKE_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_LIST_LIKE_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_LIST_LIKE_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "CAPTION" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->CAPTION_parser_;

			  if (this->CAPTION_parser_)
				this->CAPTION_parser_->pre ();
			}
			else
			{
			  if (this->CAPTION_parser_)
			  {
				this->CAPTION_parser_->post_ct_FINAL ();
				this->CAPTION ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "DATA" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->DATA_parser_;

			  if (this->DATA_parser_)
				this->DATA_parser_->pre ();
			}
			else
			{
			  if (this->DATA_parser_)
			  {
				this->DATA_parser_->post_DATA ();
				this->DATA ();
			  }

			  count = 0;
			  state = 2UL;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 2UL;
			// Fall through.
		  }
		}
		case 2UL:
		{
		  unsigned long s (~0UL);

		  if (n == "TABLE_OF_CONTENTS" && ns.empty ())
			s = 0UL;
		  else if (n == "REFERENCE_LIST" && ns.empty ())
			s = 1UL;
		  else if (n == "LIST_OF_PUBLICATIONS" && ns.empty ())
			s = 2UL;
		  else if (n == "LIST_OF_FIGURES" && ns.empty ())
			s = 3UL;
		  else if (n == "LIST" && ns.empty ())
			s = 4UL;
		  else if (n == "INDEX" && ns.empty ())
			s = 5UL;
		  else if (n == "CORRECTIONS" && ns.empty ())
			s = 6UL;
		  else if (n == "BIBLIOGRAPHY" && ns.empty ())
			s = 7UL;
		  else if (n == "ABBREVIATIONS" && ns.empty ())
			s = 8UL;
		  else if (n == "ITEM" && ns.empty ())
			s = 9UL;

		  if (s != ~0UL)
		  {
			assert (start);
			count++;

			v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
			v_state_descr_& vd = vs.data[vs.size++];

			vd.func = &ct_LIST_LIKE_pskel::choice_0;
			vd.state = s;
			vd.count = 0;

			this->choice_0 (vd.state, vd.count, ns, n, t, true);
			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	void ct_LIST_LIKE_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

			if (this->TABLE_OF_CONTENTS_parser_)
			  this->TABLE_OF_CONTENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_OF_CONTENTS_parser_)
			{
			  this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
			  this->TABLE_OF_CONTENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->REFERENCE_LIST_parser_;

			if (this->REFERENCE_LIST_parser_)
			  this->REFERENCE_LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->REFERENCE_LIST_parser_)
			{
			  this->REFERENCE_LIST_parser_->post_ct_LIST_LIKE ();
			  this->REFERENCE_LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_PUBLICATIONS_parser_;

			if (this->LIST_OF_PUBLICATIONS_parser_)
			  this->LIST_OF_PUBLICATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_PUBLICATIONS_parser_)
			{
			  this->LIST_OF_PUBLICATIONS_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_PUBLICATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_FIGURES_parser_;

			if (this->LIST_OF_FIGURES_parser_)
			  this->LIST_OF_FIGURES_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_FIGURES_parser_)
			{
			  this->LIST_OF_FIGURES_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_FIGURES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

			if (this->LIST_parser_)
			  this->LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_parser_)
			{
			  this->LIST_parser_->post_ct_LIST_LIKE ();
			  this->LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INDEX_parser_;

			if (this->INDEX_parser_)
			  this->INDEX_parser_->pre ();
		  }
		  else
		  {
			if (this->INDEX_parser_)
			{
			  this->INDEX_parser_->post_ct_LIST_LIKE ();
			  this->INDEX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CORRECTIONS_parser_;

			if (this->CORRECTIONS_parser_)
			  this->CORRECTIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->CORRECTIONS_parser_)
			{
			  this->CORRECTIONS_parser_->post_ct_LIST_LIKE ();
			  this->CORRECTIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BIBLIOGRAPHY_parser_;

			if (this->BIBLIOGRAPHY_parser_)
			  this->BIBLIOGRAPHY_parser_->pre ();
		  }
		  else
		  {
			if (this->BIBLIOGRAPHY_parser_)
			{
			  this->BIBLIOGRAPHY_parser_->post_ct_LIST_LIKE ();
			  this->BIBLIOGRAPHY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABBREVIATIONS_parser_;

			if (this->ABBREVIATIONS_parser_)
			  this->ABBREVIATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->ABBREVIATIONS_parser_)
			{
			  this->ABBREVIATIONS_parser_->post_ct_LIST_LIKE ();
			  this->ABBREVIATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 9UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_parser_;

			if (this->ITEM_parser_)
			  this->ITEM_parser_->pre ();
		  }
		  else
		  {
			if (this->ITEM_parser_)
			{
			  this->ITEM_parser_->post_ct_ITEM ();
			  this->ITEM ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_ITEM_pskel.
	//
	bool ct_ITEM_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if ((n == "TEXTBLOCK" && ns.empty ()) ||
			  (n == "PAGE_NUMBER" && ns.empty ()) ||
			  (n == "ITEM_CAPTION" && ns.empty ()) ||
			  (n == "SUBHEADLINE" && ns.empty ()) ||
			  (n == "HEADLINE" && ns.empty ()) ||
			  (n == "AUTHOR" && ns.empty ()))
			s = 0UL;
		  else if (n == "ITEM" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_ITEM_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_ITEM_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_ITEM_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_ITEM_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_ITEM_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  unsigned long s (~0UL);

		  if (n == "TEXTBLOCK" && ns.empty ())
			s = 0UL;
		  else if (n == "PAGE_NUMBER" && ns.empty ())
			s = 1UL;
		  else if (n == "ITEM_CAPTION" && ns.empty ())
			s = 2UL;
		  else if (n == "SUBHEADLINE" && ns.empty ())
			s = 3UL;
		  else if (n == "HEADLINE" && ns.empty ())
			s = 4UL;
		  else if (n == "AUTHOR" && ns.empty ())
			s = 5UL;

		  if (s != ~0UL)
		  {
			assert (start);
			count++;

			v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
			v_state_descr_& vd = vs.data[vs.size++];

			vd.func = &ct_ITEM_pskel::choice_0;
			vd.state = s;
			vd.count = 0;

			this->choice_0 (vd.state, vd.count, ns, n, t, true);
			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "ITEM" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_parser_;

			  if (this->ITEM_parser_)
				this->ITEM_parser_->pre ();
			}
			else
			{
			  if (this->ITEM_parser_)
			  {
				this->ITEM_parser_->post_ct_ITEM ();
				this->ITEM ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	void ct_ITEM_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

			if (this->TEXTBLOCK_parser_)
			  this->TEXTBLOCK_parser_->pre ();
		  }
		  else
		  {
			if (this->TEXTBLOCK_parser_)
			{
			  this->TEXTBLOCK_parser_->post_ct_FINAL ();
			  this->TEXTBLOCK ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PAGE_NUMBER_parser_;

			if (this->PAGE_NUMBER_parser_)
			  this->PAGE_NUMBER_parser_->pre ();
		  }
		  else
		  {
			if (this->PAGE_NUMBER_parser_)
			{
			  this->PAGE_NUMBER_parser_->post_ct_FINAL ();
			  this->PAGE_NUMBER ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_CAPTION_parser_;

			if (this->ITEM_CAPTION_parser_)
			  this->ITEM_CAPTION_parser_->pre ();
		  }
		  else
		  {
			if (this->ITEM_CAPTION_parser_)
			{
			  this->ITEM_CAPTION_parser_->post_ct_FINAL ();
			  this->ITEM_CAPTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBHEADLINE_parser_;

			if (this->SUBHEADLINE_parser_)
			  this->SUBHEADLINE_parser_->pre ();
		  }
		  else
		  {
			if (this->SUBHEADLINE_parser_)
			{
			  this->SUBHEADLINE_parser_->post_ct_FINAL ();
			  this->SUBHEADLINE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADLINE_parser_;

			if (this->HEADLINE_parser_)
			  this->HEADLINE_parser_->pre ();
		  }
		  else
		  {
			if (this->HEADLINE_parser_)
			{
			  this->HEADLINE_parser_->post_ct_FINAL ();
			  this->HEADLINE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

			if (this->AUTHOR_parser_)
			  this->AUTHOR_parser_->pre ();
		  }
		  else
		  {
			if (this->AUTHOR_parser_)
			{
			  this->AUTHOR_parser_->post_ct_FINAL ();
			  this->AUTHOR ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_HEADING_pskel.
	//
	bool ct_HEADING_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TITLE" && ns.empty ())
			s = 0UL;
		  else if (n == "SUBTITLE" && ns.empty ())
			s = 1UL;
		  else if (n == "AUTHOR" && ns.empty ())
			s = 2UL;
		  else if (n == "MOTTO" && ns.empty ())
			s = 3UL;
		  else if (n == "HEADING_TEXT" && ns.empty ())
			s = 4UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_HEADING_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_HEADING_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_HEADING_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_HEADING_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_HEADING_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TITLE" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TITLE_parser_;

			  if (this->TITLE_parser_)
				this->TITLE_parser_->pre ();
			}
			else
			{
			  if (this->TITLE_parser_)
			  {
				this->TITLE_parser_->post_ct_FINAL ();
				this->TITLE ();
			  }

			  count++;
			}
		  }
		  else
		  {
			assert (start);
			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (n == "SUBTITLE" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBTITLE_parser_;

			  if (this->SUBTITLE_parser_)
				this->SUBTITLE_parser_->pre ();
			}
			else
			{
			  if (this->SUBTITLE_parser_)
			  {
				this->SUBTITLE_parser_->post_ct_FINAL ();
				this->SUBTITLE ();
			  }

			  count++;
			}
		  }
		  else
		  {
			assert (start);
			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (n == "AUTHOR" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

			  if (this->AUTHOR_parser_)
				this->AUTHOR_parser_->pre ();
			}
			else
			{
			  if (this->AUTHOR_parser_)
			  {
				this->AUTHOR_parser_->post_ct_FINAL ();
				this->AUTHOR ();
			  }

			  count++;
			}
		  }
		  else
		  {
			assert (start);
			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->MOTTO_parser_;

			if (this->MOTTO_parser_)
			  this->MOTTO_parser_->pre ();
		  }
		  else
		  {
			if (this->MOTTO_parser_)
			{
			  this->MOTTO_parser_->post_MOTTO ();
			  this->MOTTO ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (n == "HEADING_TEXT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADING_TEXT_parser_;

			  if (this->HEADING_TEXT_parser_)
				this->HEADING_TEXT_parser_->pre ();
			}
			else
			{
			  if (this->HEADING_TEXT_parser_)
			  {
				this->HEADING_TEXT_parser_->post_HEADING_TEXT ();
				this->HEADING_TEXT ();
			  }

			  count++;
			}
		  }
		  else
		  {
			assert (start);
			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_CHAPTER_LIKE_pskel.
	//
	bool ct_CHAPTER_LIKE_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "HEADING" && ns.empty ())
			s = 0UL;
		  else if (n == "ABSTRACT" && ns.empty ())
			s = 1UL;
		  else if (n == "BODY" && ns.empty ())
			s = 2UL;
		  else if ((n == "TABLE_OF_CONTENTS" && ns.empty ()) ||
				   (n == "REFERENCE_LIST" && ns.empty ()) ||
				   (n == "LIST_OF_PUBLICATIONS" && ns.empty ()) ||
				   (n == "LIST_OF_FIGURES" && ns.empty ()) ||
				   (n == "INDEX" && ns.empty ()) ||
				   (n == "CORRECTIONS" && ns.empty ()) ||
				   (n == "BIBLIOGRAPHY" && ns.empty ()) ||
				   (n == "ABBREVIATIONS" && ns.empty ()) ||
				   (n == "RIDAS" && ns.empty ()) ||
				   (n == "PRODUCTION_NOTE" && ns.empty ()) ||
				   (n == "PREFACE" && ns.empty ()) ||
				   (n == "POSTFACE" && ns.empty ()) ||
				   (n == "POEM" && ns.empty ()) ||
				   (n == "NOTES" && ns.empty ()) ||
				   (n == "NECROLOGY" && ns.empty ()) ||
				   (n == "INTRODUCTION" && ns.empty ()) ||
				   (n == "GROUP" && ns.empty ()) ||
				   (n == "DEDICATION" && ns.empty ()) ||
				   (n == "DEBATE" && ns.empty ()) ||
				   (n == "CONTRIBUTION" && ns.empty ()) ||
				   (n == "CHAPTER" && ns.empty ()) ||
				   (n == "BOOK_REVIEW" && ns.empty ()) ||
				   (n == "APPENDIX" && ns.empty ()) ||
				   (n == "ACKNOWLEDGEMENTS" && ns.empty ()) ||
				   (n == "MAP_GROUP" && ns.empty ()) ||
				   (n == "ILLUSTRATION_GROUP" && ns.empty ()) ||
				   (n == "CHART_DIAGRAM_GROUP" && ns.empty ()) ||
				   (n == "TABLE_GROUP" && ns.empty ()))
			s = 3UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_CHAPTER_LIKE_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_CHAPTER_LIKE_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_CHAPTER_LIKE_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_CHAPTER_LIKE_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_CHAPTER_LIKE_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "HEADING" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADING_parser_;

			  if (this->HEADING_parser_)
				this->HEADING_parser_->pre ();
			}
			else
			{
			  if (this->HEADING_parser_)
			  {
				this->HEADING_parser_->post_ct_HEADING ();
				this->HEADING ();
			  }

			  count = 0;
			  state = 1UL;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "ABSTRACT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ABSTRACT_parser_;

			  if (this->ABSTRACT_parser_)
				this->ABSTRACT_parser_->pre ();
			}
			else
			{
			  if (this->ABSTRACT_parser_)
			  {
				this->ABSTRACT_parser_->post_ct_CHAPTER_LIKE ();
				this->ABSTRACT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 2UL;
			// Fall through.
		  }
		}
		case 2UL:
		{
		  if (n == "BODY" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_parser_;

			  if (this->BODY_parser_)
				this->BODY_parser_->pre ();
			}
			else
			{
			  if (this->BODY_parser_)
			  {
				this->BODY_parser_->post_ct_BODY ();
				this->BODY ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 3UL;
			// Fall through.
		  }
		}
		case 3UL:
		{
		  unsigned long s (~0UL);

		  if (n == "TABLE_OF_CONTENTS" && ns.empty ())
			s = 0UL;
		  else if (n == "REFERENCE_LIST" && ns.empty ())
			s = 1UL;
		  else if (n == "LIST_OF_PUBLICATIONS" && ns.empty ())
			s = 2UL;
		  else if (n == "LIST_OF_FIGURES" && ns.empty ())
			s = 3UL;
		  else if (n == "INDEX" && ns.empty ())
			s = 4UL;
		  else if (n == "CORRECTIONS" && ns.empty ())
			s = 5UL;
		  else if (n == "BIBLIOGRAPHY" && ns.empty ())
			s = 6UL;
		  else if (n == "ABBREVIATIONS" && ns.empty ())
			s = 7UL;
		  else if (n == "RIDAS" && ns.empty ())
			s = 8UL;
		  else if (n == "PRODUCTION_NOTE" && ns.empty ())
			s = 9UL;
		  else if (n == "PREFACE" && ns.empty ())
			s = 10UL;
		  else if (n == "POSTFACE" && ns.empty ())
			s = 11UL;
		  else if (n == "POEM" && ns.empty ())
			s = 12UL;
		  else if (n == "NOTES" && ns.empty ())
			s = 13UL;
		  else if (n == "NECROLOGY" && ns.empty ())
			s = 14UL;
		  else if (n == "INTRODUCTION" && ns.empty ())
			s = 15UL;
		  else if (n == "GROUP" && ns.empty ())
			s = 16UL;
		  else if (n == "DEDICATION" && ns.empty ())
			s = 17UL;
		  else if (n == "DEBATE" && ns.empty ())
			s = 18UL;
		  else if (n == "CONTRIBUTION" && ns.empty ())
			s = 19UL;
		  else if (n == "CHAPTER" && ns.empty ())
			s = 20UL;
		  else if (n == "BOOK_REVIEW" && ns.empty ())
			s = 21UL;
		  else if (n == "APPENDIX" && ns.empty ())
			s = 22UL;
		  else if (n == "ACKNOWLEDGEMENTS" && ns.empty ())
			s = 23UL;
		  else if (n == "MAP_GROUP" && ns.empty ())
			s = 24UL;
		  else if (n == "ILLUSTRATION_GROUP" && ns.empty ())
			s = 25UL;
		  else if (n == "CHART_DIAGRAM_GROUP" && ns.empty ())
			s = 26UL;
		  else if (n == "TABLE_GROUP" && ns.empty ())
			s = 27UL;

		  if (s != ~0UL)
		  {
			assert (start);
			count++;

			v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
			v_state_descr_& vd = vs.data[vs.size++];

			vd.func = &ct_CHAPTER_LIKE_pskel::choice_0;
			vd.state = s;
			vd.count = 0;

			this->choice_0 (vd.state, vd.count, ns, n, t, true);
			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	void ct_CHAPTER_LIKE_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_OF_CONTENTS_parser_;

			if (this->TABLE_OF_CONTENTS_parser_)
			  this->TABLE_OF_CONTENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_OF_CONTENTS_parser_)
			{
			  this->TABLE_OF_CONTENTS_parser_->post_ct_LIST_LIKE ();
			  this->TABLE_OF_CONTENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->REFERENCE_LIST_parser_;

			if (this->REFERENCE_LIST_parser_)
			  this->REFERENCE_LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->REFERENCE_LIST_parser_)
			{
			  this->REFERENCE_LIST_parser_->post_ct_LIST_LIKE ();
			  this->REFERENCE_LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_PUBLICATIONS_parser_;

			if (this->LIST_OF_PUBLICATIONS_parser_)
			  this->LIST_OF_PUBLICATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_PUBLICATIONS_parser_)
			{
			  this->LIST_OF_PUBLICATIONS_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_PUBLICATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_OF_FIGURES_parser_;

			if (this->LIST_OF_FIGURES_parser_)
			  this->LIST_OF_FIGURES_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_OF_FIGURES_parser_)
			{
			  this->LIST_OF_FIGURES_parser_->post_ct_LIST_LIKE ();
			  this->LIST_OF_FIGURES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INDEX_parser_;

			if (this->INDEX_parser_)
			  this->INDEX_parser_->pre ();
		  }
		  else
		  {
			if (this->INDEX_parser_)
			{
			  this->INDEX_parser_->post_ct_LIST_LIKE ();
			  this->INDEX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CORRECTIONS_parser_;

			if (this->CORRECTIONS_parser_)
			  this->CORRECTIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->CORRECTIONS_parser_)
			{
			  this->CORRECTIONS_parser_->post_ct_LIST_LIKE ();
			  this->CORRECTIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BIBLIOGRAPHY_parser_;

			if (this->BIBLIOGRAPHY_parser_)
			  this->BIBLIOGRAPHY_parser_->pre ();
		  }
		  else
		  {
			if (this->BIBLIOGRAPHY_parser_)
			{
			  this->BIBLIOGRAPHY_parser_->post_ct_LIST_LIKE ();
			  this->BIBLIOGRAPHY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ABBREVIATIONS_parser_;

			if (this->ABBREVIATIONS_parser_)
			  this->ABBREVIATIONS_parser_->pre ();
		  }
		  else
		  {
			if (this->ABBREVIATIONS_parser_)
			{
			  this->ABBREVIATIONS_parser_->post_ct_LIST_LIKE ();
			  this->ABBREVIATIONS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->RIDAS_parser_;

			if (this->RIDAS_parser_)
			  this->RIDAS_parser_->pre ();
		  }
		  else
		  {
			if (this->RIDAS_parser_)
			{
			  this->RIDAS_parser_->post_ct_CHAPTER_LIKE ();
			  this->RIDAS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 9UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PRODUCTION_NOTE_parser_;

			if (this->PRODUCTION_NOTE_parser_)
			  this->PRODUCTION_NOTE_parser_->pre ();
		  }
		  else
		  {
			if (this->PRODUCTION_NOTE_parser_)
			{
			  this->PRODUCTION_NOTE_parser_->post_ct_CHAPTER_LIKE ();
			  this->PRODUCTION_NOTE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 10UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PREFACE_parser_;

			if (this->PREFACE_parser_)
			  this->PREFACE_parser_->pre ();
		  }
		  else
		  {
			if (this->PREFACE_parser_)
			{
			  this->PREFACE_parser_->post_ct_CHAPTER_LIKE ();
			  this->PREFACE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 11UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->POSTFACE_parser_;

			if (this->POSTFACE_parser_)
			  this->POSTFACE_parser_->pre ();
		  }
		  else
		  {
			if (this->POSTFACE_parser_)
			{
			  this->POSTFACE_parser_->post_ct_CHAPTER_LIKE ();
			  this->POSTFACE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 12UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->POEM_parser_;

			if (this->POEM_parser_)
			  this->POEM_parser_->pre ();
		  }
		  else
		  {
			if (this->POEM_parser_)
			{
			  this->POEM_parser_->post_ct_CHAPTER_LIKE ();
			  this->POEM ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 13UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->NOTES_parser_;

			if (this->NOTES_parser_)
			  this->NOTES_parser_->pre ();
		  }
		  else
		  {
			if (this->NOTES_parser_)
			{
			  this->NOTES_parser_->post_ct_CHAPTER_LIKE ();
			  this->NOTES ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 14UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->NECROLOGY_parser_;

			if (this->NECROLOGY_parser_)
			  this->NECROLOGY_parser_->pre ();
		  }
		  else
		  {
			if (this->NECROLOGY_parser_)
			{
			  this->NECROLOGY_parser_->post_ct_CHAPTER_LIKE ();
			  this->NECROLOGY ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 15UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->INTRODUCTION_parser_;

			if (this->INTRODUCTION_parser_)
			  this->INTRODUCTION_parser_->pre ();
		  }
		  else
		  {
			if (this->INTRODUCTION_parser_)
			{
			  this->INTRODUCTION_parser_->post_ct_CHAPTER_LIKE ();
			  this->INTRODUCTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 16UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->GROUP_parser_;

			if (this->GROUP_parser_)
			  this->GROUP_parser_->pre ();
		  }
		  else
		  {
			if (this->GROUP_parser_)
			{
			  this->GROUP_parser_->post_ct_CHAPTER_LIKE ();
			  this->GROUP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 17UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->DEDICATION_parser_;

			if (this->DEDICATION_parser_)
			  this->DEDICATION_parser_->pre ();
		  }
		  else
		  {
			if (this->DEDICATION_parser_)
			{
			  this->DEDICATION_parser_->post_ct_CHAPTER_LIKE ();
			  this->DEDICATION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 18UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->DEBATE_parser_;

			if (this->DEBATE_parser_)
			  this->DEBATE_parser_->pre ();
		  }
		  else
		  {
			if (this->DEBATE_parser_)
			{
			  this->DEBATE_parser_->post_ct_CHAPTER_LIKE ();
			  this->DEBATE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 19UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CONTRIBUTION_parser_;

			if (this->CONTRIBUTION_parser_)
			  this->CONTRIBUTION_parser_->pre ();
		  }
		  else
		  {
			if (this->CONTRIBUTION_parser_)
			{
			  this->CONTRIBUTION_parser_->post_ct_CHAPTER_LIKE ();
			  this->CONTRIBUTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 20UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHAPTER_parser_;

			if (this->CHAPTER_parser_)
			  this->CHAPTER_parser_->pre ();
		  }
		  else
		  {
			if (this->CHAPTER_parser_)
			{
			  this->CHAPTER_parser_->post_ct_CHAPTER_LIKE ();
			  this->CHAPTER ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 21UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BOOK_REVIEW_parser_;

			if (this->BOOK_REVIEW_parser_)
			  this->BOOK_REVIEW_parser_->pre ();
		  }
		  else
		  {
			if (this->BOOK_REVIEW_parser_)
			{
			  this->BOOK_REVIEW_parser_->post_ct_CHAPTER_LIKE ();
			  this->BOOK_REVIEW ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 22UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->APPENDIX_parser_;

			if (this->APPENDIX_parser_)
			  this->APPENDIX_parser_->pre ();
		  }
		  else
		  {
			if (this->APPENDIX_parser_)
			{
			  this->APPENDIX_parser_->post_ct_CHAPTER_LIKE ();
			  this->APPENDIX ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 23UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ACKNOWLEDGEMENTS_parser_;

			if (this->ACKNOWLEDGEMENTS_parser_)
			  this->ACKNOWLEDGEMENTS_parser_->pre ();
		  }
		  else
		  {
			if (this->ACKNOWLEDGEMENTS_parser_)
			{
			  this->ACKNOWLEDGEMENTS_parser_->post_ct_CHAPTER_LIKE ();
			  this->ACKNOWLEDGEMENTS ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 24UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->MAP_GROUP_parser_;

			if (this->MAP_GROUP_parser_)
			  this->MAP_GROUP_parser_->pre ();
		  }
		  else
		  {
			if (this->MAP_GROUP_parser_)
			{
			  this->MAP_GROUP_parser_->post_ct_MAP_GROUP ();
			  this->MAP_GROUP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 25UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_GROUP_parser_;

			if (this->ILLUSTRATION_GROUP_parser_)
			  this->ILLUSTRATION_GROUP_parser_->pre ();
		  }
		  else
		  {
			if (this->ILLUSTRATION_GROUP_parser_)
			{
			  this->ILLUSTRATION_GROUP_parser_->post_ct_ILLUSTRATION_GROUP ();
			  this->ILLUSTRATION_GROUP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 26UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHART_DIAGRAM_GROUP_parser_;

			if (this->CHART_DIAGRAM_GROUP_parser_)
			  this->CHART_DIAGRAM_GROUP_parser_->pre ();
		  }
		  else
		  {
			if (this->CHART_DIAGRAM_GROUP_parser_)
			{
			  this->CHART_DIAGRAM_GROUP_parser_->post_ct_CHART_DIAGRAM_GROUP ();
			  this->CHART_DIAGRAM_GROUP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 27UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_GROUP_parser_;

			if (this->TABLE_GROUP_parser_)
			  this->TABLE_GROUP_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_GROUP_parser_)
			{
			  this->TABLE_GROUP_parser_->post_ct_TABLE_GROUP ();
			  this->TABLE_GROUP ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_MAP_GROUP_pskel.
	//
	bool ct_MAP_GROUP_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "MAP" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_MAP_GROUP_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_MAP_GROUP_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_MAP_GROUP_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_MAP_GROUP_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_MAP_GROUP_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "MAP" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->MAP_parser_;

			  if (this->MAP_parser_)
				this->MAP_parser_->pre ();
			}
			else
			{
			  if (this->MAP_parser_)
			  {
				this->MAP_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
				this->MAP ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_ILLUSTRATION_GROUP_pskel.
	//
	bool ct_ILLUSTRATION_GROUP_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "ILLUSTRATION" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_ILLUSTRATION_GROUP_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_ILLUSTRATION_GROUP_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_ILLUSTRATION_GROUP_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_ILLUSTRATION_GROUP_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_ILLUSTRATION_GROUP_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "ILLUSTRATION" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

			  if (this->ILLUSTRATION_parser_)
				this->ILLUSTRATION_parser_->pre ();
			}
			else
			{
			  if (this->ILLUSTRATION_parser_)
			  {
				this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
				this->ILLUSTRATION ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_CHART_DIAGRAM_GROUP_pskel.
	//
	bool ct_CHART_DIAGRAM_GROUP_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "CHART_DIAGRAM" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_CHART_DIAGRAM_GROUP_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_CHART_DIAGRAM_GROUP_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_CHART_DIAGRAM_GROUP_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_CHART_DIAGRAM_GROUP_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_CHART_DIAGRAM_GROUP_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "CHART_DIAGRAM" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->CHART_DIAGRAM_parser_;

			  if (this->CHART_DIAGRAM_parser_)
				this->CHART_DIAGRAM_parser_->pre ();
			}
			else
			{
			  if (this->CHART_DIAGRAM_parser_)
			  {
				this->CHART_DIAGRAM_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
				this->CHART_DIAGRAM ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_TABLE_GROUP_pskel.
	//
	bool ct_TABLE_GROUP_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TABLE" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_TABLE_GROUP_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_TABLE_GROUP_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_TABLE_GROUP_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_TABLE_GROUP_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_TABLE_GROUP_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TABLE" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

			  if (this->TABLE_parser_)
				this->TABLE_parser_->pre ();
			}
			else
			{
			  if (this->TABLE_parser_)
			  {
				this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
				this->TABLE ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_ILLUSTRATION_LIKE_STRUCT_pskel.
	//
	bool ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "IMAGE" && ns.empty ())
			s = 0UL;
		  else if (n == "CAPTION" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_ILLUSTRATION_LIKE_STRUCT_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_ILLUSTRATION_LIKE_STRUCT_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->IMAGE_parser_;

			if (this->IMAGE_parser_)
			  this->IMAGE_parser_->pre ();
		  }
		  else
		  {
			if (this->IMAGE_parser_)
			{
			  this->IMAGE_parser_->post_ct_FINAL ();
			  this->IMAGE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CAPTION_parser_;

			if (this->CAPTION_parser_)
			  this->CAPTION_parser_->pre ();
		  }
		  else
		  {
			if (this->CAPTION_parser_)
			{
			  this->CAPTION_parser_->post_ct_FINAL ();
			  this->CAPTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_TABLE_LIKE_STRUCT_pskel.
	//
	bool ct_TABLE_LIKE_STRUCT_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "IMAGE" && ns.empty ())
			s = 0UL;
		  else if (n == "CAPTION" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_TABLE_LIKE_STRUCT_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_TABLE_LIKE_STRUCT_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_TABLE_LIKE_STRUCT_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->IMAGE_parser_;

			if (this->IMAGE_parser_)
			  this->IMAGE_parser_->pre ();
		  }
		  else
		  {
			if (this->IMAGE_parser_)
			{
			  this->IMAGE_parser_->post_ct_FINAL ();
			  this->IMAGE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CAPTION_parser_;

			if (this->CAPTION_parser_)
			  this->CAPTION_parser_->pre ();
		  }
		  else
		  {
			if (this->CAPTION_parser_)
			{
			  this->CAPTION_parser_->post_ct_FINAL ();
			  this->CAPTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_BODY_pskel.
	//
	bool ct_BODY_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "BODY_CONTENT" && ns.empty ())
			s = 0UL;
		  else if (n == "FOOTNOTE" && ns.empty ())
			s = 1UL;
		  else if (n == "MAP" && ns.empty ())
			s = 2UL;
		  else if (n == "ILLUSTRATION" && ns.empty ())
			s = 3UL;
		  else if (n == "CHART_DIAGRAM" && ns.empty ())
			s = 4UL;
		  else if (n == "BOOKPLATE" && ns.empty ())
			s = 5UL;
		  else if (n == "BARCODE" && ns.empty ())
			s = 6UL;
		  else if (n == "TABLE" && ns.empty ())
			s = 7UL;
		  else if (n == "LIST" && ns.empty ())
			s = 8UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_BODY_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_BODY_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_BODY_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_BODY_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_BODY_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BODY_CONTENT_parser_;

			if (this->BODY_CONTENT_parser_)
			  this->BODY_CONTENT_parser_->pre ();
		  }
		  else
		  {
			if (this->BODY_CONTENT_parser_)
			{
			  this->BODY_CONTENT_parser_->post_ct_BODY_CONTENT ();
			  this->BODY_CONTENT ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FOOTNOTE_parser_;

			if (this->FOOTNOTE_parser_)
			  this->FOOTNOTE_parser_->pre ();
		  }
		  else
		  {
			if (this->FOOTNOTE_parser_)
			{
			  this->FOOTNOTE_parser_->post_ct_FOOTNOTE_PARAGRAPH ();
			  this->FOOTNOTE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->MAP_parser_;

			if (this->MAP_parser_)
			  this->MAP_parser_->pre ();
		  }
		  else
		  {
			if (this->MAP_parser_)
			{
			  this->MAP_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->MAP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

			if (this->ILLUSTRATION_parser_)
			  this->ILLUSTRATION_parser_->pre ();
		  }
		  else
		  {
			if (this->ILLUSTRATION_parser_)
			{
			  this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->ILLUSTRATION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHART_DIAGRAM_parser_;

			if (this->CHART_DIAGRAM_parser_)
			  this->CHART_DIAGRAM_parser_->pre ();
		  }
		  else
		  {
			if (this->CHART_DIAGRAM_parser_)
			{
			  this->CHART_DIAGRAM_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->CHART_DIAGRAM ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BOOKPLATE_parser_;

			if (this->BOOKPLATE_parser_)
			  this->BOOKPLATE_parser_->pre ();
		  }
		  else
		  {
			if (this->BOOKPLATE_parser_)
			{
			  this->BOOKPLATE_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->BOOKPLATE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BARCODE_parser_;

			if (this->BARCODE_parser_)
			  this->BARCODE_parser_->pre ();
		  }
		  else
		  {
			if (this->BARCODE_parser_)
			{
			  this->BARCODE_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->BARCODE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

			if (this->TABLE_parser_)
			  this->TABLE_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_parser_)
			{
			  this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
			  this->TABLE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->LIST_parser_;

			if (this->LIST_parser_)
			  this->LIST_parser_->pre ();
		  }
		  else
		  {
			if (this->LIST_parser_)
			{
			  this->LIST_parser_->post_ct_LIST_LIKE ();
			  this->LIST ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_BODY_CONTENT_pskel.
	//
	bool ct_BODY_CONTENT_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXTBLOCK" && ns.empty ())
			s = 0UL;
		  else if (n == "PARAGRAPH" && ns.empty ())
			s = 1UL;
		  else if (n == "FORMULA" && ns.empty ())
			s = 2UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_BODY_CONTENT_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_BODY_CONTENT_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_BODY_CONTENT_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_BODY_CONTENT_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_BODY_CONTENT_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

			if (this->TEXTBLOCK_parser_)
			  this->TEXTBLOCK_parser_->pre ();
		  }
		  else
		  {
			if (this->TEXTBLOCK_parser_)
			{
			  this->TEXTBLOCK_parser_->post_ct_FINAL ();
			  this->TEXTBLOCK ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

			if (this->PARAGRAPH_parser_)
			  this->PARAGRAPH_parser_->pre ();
		  }
		  else
		  {
			if (this->PARAGRAPH_parser_)
			{
			  this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
			  this->PARAGRAPH ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FORMULA_parser_;

			if (this->FORMULA_parser_)
			  this->FORMULA_parser_->pre ();
		  }
		  else
		  {
			if (this->FORMULA_parser_)
			{
			  this->FORMULA_parser_->post_ct_FORMULA ();
			  this->FORMULA ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_FORMULA_pskel.
	//
	bool ct_FORMULA_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "IMAGE" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_FORMULA_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_FORMULA_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_FORMULA_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_FORMULA_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_FORMULA_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "IMAGE" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->IMAGE_parser_;

			  if (this->IMAGE_parser_)
				this->IMAGE_parser_->pre ();
			}
			else
			{
			  if (this->IMAGE_parser_)
			  {
				this->IMAGE_parser_->post_ct_FINAL ();
				this->IMAGE ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_PARAGRAPH_pskel.
	//
	bool ct_PARAGRAPH_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXT" && ns.empty ())
			s = 0UL;
		  else if (n == "MARGINALIA" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_PARAGRAPH_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_PARAGRAPH_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_PARAGRAPH_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_PARAGRAPH_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_PARAGRAPH_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TEXT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

			  if (this->TEXT_parser_)
				this->TEXT_parser_->pre ();
			}
			else
			{
			  if (this->TEXT_parser_)
			  {
				this->TEXT_parser_->post_ct_FINAL ();
				this->TEXT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = 1UL;
			// Fall through.
		  }
		}
		case 1UL:
		{
		  if (n == "MARGINALIA" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->MARGINALIA_parser_;

			  if (this->MARGINALIA_parser_)
				this->MARGINALIA_parser_->pre ();
			}
			else
			{
			  if (this->MARGINALIA_parser_)
			  {
				this->MARGINALIA_parser_->post_ct_FINAL ();
				this->MARGINALIA ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_FOOTNOTE_PARAGRAPH_pskel.
	//
	bool ct_FOOTNOTE_PARAGRAPH_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXT" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_FOOTNOTE_PARAGRAPH_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_FOOTNOTE_PARAGRAPH_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void ct_FOOTNOTE_PARAGRAPH_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TEXT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

			  if (this->TEXT_parser_)
				this->TEXT_parser_->pre ();
			}
			else
			{
			  if (this->TEXT_parser_)
			  {
				this->TEXT_parser_->post_ct_FINAL ();
				this->TEXT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_FINAL_pskel.
	//
	bool ct_FINAL_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "fptr" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_FINAL_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			if (vd->count < 1UL)
			  this->_expected_element (
				"", "fptr",
				ns, n);
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_FINAL_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_FINAL_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_FINAL_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }

	  if (vd->count < 1UL)
		this->_expected_element (
		  "", "fptr");

	  this->v_state_stack_.pop ();
	}

	void ct_FINAL_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "fptr" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->fptr_parser_;

			  if (this->fptr_parser_)
				this->fptr_parser_->pre ();
			}
			else
			{
			  if (this->fptr_parser_)
			  {
				this->fptr_parser_->post_ct_FPTR ();
				this->fptr ();
			  }

			  count = 0;
			  state = ~0UL;
			}

			break;
		  }
		  else
		  {
			assert (start);
			if (count < 1UL)
			  this->_expected_element (
				"", "fptr",
				ns, n);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for ct_FPTR_pskel.
	//
	bool ct_FPTR_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "area" && ns.empty ())
			s = 0UL;
		  else if (n == "seq" && ns.empty ())
			s = 1UL;
		  else if (n == "par" && ns.empty ())
			s = 2UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &ct_FPTR_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			if (vd->count < 1UL)
			  this->_expected_element (
				"", "area",
				ns, n);
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_FPTR_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_FPTR_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_FPTR_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }

	  if (vd->count < 1UL)
		this->_expected_element (
		  "", "area");

	  this->v_state_stack_.pop ();
	}

	void ct_FPTR_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

			if (this->area_parser_)
			  this->area_parser_->pre ();
		  }
		  else
		  {
			if (this->area_parser_)
			{
			  this->area_parser_->post_any_type ();
			  this->area ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->seq_parser_;

			if (this->seq_parser_)
			  this->seq_parser_->pre ();
		  }
		  else
		  {
			if (this->seq_parser_)
			{
			  this->seq_parser_->post_ct_SEQ ();
			  this->seq ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->par_parser_;

			if (this->par_parser_)
			  this->par_parser_->pre ();
		  }
		  else
		  {
			if (this->par_parser_)
			{
			  this->par_parser_->post_par ();
			  this->par ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for ct_SEQ_pskel.
	//
	bool ct_SEQ_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "area" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &ct_SEQ_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			if (vd->count < 1UL)
			  this->_expected_element (
				"", "area",
				ns, n);
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool ct_SEQ_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void ct_SEQ_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void ct_SEQ_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }

	  if (vd->count < 1UL)
		this->_expected_element (
		  "", "area");

	  this->v_state_stack_.pop ();
	}

	void ct_SEQ_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

			if (this->area_parser_)
			  this->area_parser_->pre ();
		  }
		  else
		  {
			if (this->area_parser_)
			{
			  this->area_parser_->post_any_type ();
			  this->area ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for Serial_pskel.
	//
	bool Serial_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "VOLUME" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &Serial_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			if (vd->count < 1UL)
			  this->_expected_element (
				"", "VOLUME",
				ns, n);
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool Serial_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void Serial_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void Serial_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }

	  if (vd->count < 1UL)
		this->_expected_element (
		  "", "VOLUME");

	  this->v_state_stack_.pop ();
	}

	void Serial_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "VOLUME" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->VOLUME_parser_;

			  if (this->VOLUME_parser_)
				this->VOLUME_parser_->pre ();
			}
			else
			{
			  if (this->VOLUME_parser_)
			  {
				this->VOLUME_parser_->post_ct_HIERARCHY ();
				this->VOLUME ();
			  }

			  count = 0;
			  state = ~0UL;
			}

			break;
		  }
		  else
		  {
			assert (start);
			if (count < 1UL)
			  this->_expected_element (
				"", "VOLUME",
				ns, n);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for CONTENT_pskel.
	//
	bool CONTENT_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXTBLOCK" && ns.empty ())
			s = 0UL;
		  else if (n == "TABLE" && ns.empty ())
			s = 1UL;
		  else if (n == "PUBLISHING_STMT" && ns.empty ())
			s = 2UL;
		  else if (n == "PARAGRAPH" && ns.empty ())
			s = 3UL;
		  else if (n == "MAP" && ns.empty ())
			s = 4UL;
		  else if (n == "ILLUSTRATION" && ns.empty ())
			s = 5UL;
		  else if (n == "CHART_DIAGRAM" && ns.empty ())
			s = 6UL;
		  else if (n == "BOOKPLATE" && ns.empty ())
			s = 7UL;
		  else if (n == "BARCODE" && ns.empty ())
			s = 8UL;
		  else if (n == "SUBHEADLINE" && ns.empty ())
			s = 9UL;
		  else if (n == "HEADLINE" && ns.empty ())
			s = 10UL;
		  else if (n == "FORMULA" && ns.empty ())
			s = 11UL;
		  else if (n == "FOOTNOTE" && ns.empty ())
			s = 12UL;
		  else if (n == "AUTHOR" && ns.empty ())
			s = 13UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &CONTENT_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool CONTENT_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void CONTENT_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void CONTENT_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void CONTENT_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

			if (this->TEXTBLOCK_parser_)
			  this->TEXTBLOCK_parser_->pre ();
		  }
		  else
		  {
			if (this->TEXTBLOCK_parser_)
			{
			  this->TEXTBLOCK_parser_->post_ct_FINAL ();
			  this->TEXTBLOCK ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

			if (this->TABLE_parser_)
			  this->TABLE_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_parser_)
			{
			  this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
			  this->TABLE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PUBLISHING_STMT_parser_;

			if (this->PUBLISHING_STMT_parser_)
			  this->PUBLISHING_STMT_parser_->pre ();
		  }
		  else
		  {
			if (this->PUBLISHING_STMT_parser_)
			{
			  this->PUBLISHING_STMT_parser_->post_ct_FINAL ();
			  this->PUBLISHING_STMT ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PARAGRAPH_parser_;

			if (this->PARAGRAPH_parser_)
			  this->PARAGRAPH_parser_->pre ();
		  }
		  else
		  {
			if (this->PARAGRAPH_parser_)
			{
			  this->PARAGRAPH_parser_->post_ct_PARAGRAPH ();
			  this->PARAGRAPH ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->MAP_parser_;

			if (this->MAP_parser_)
			  this->MAP_parser_->pre ();
		  }
		  else
		  {
			if (this->MAP_parser_)
			{
			  this->MAP_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->MAP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

			if (this->ILLUSTRATION_parser_)
			  this->ILLUSTRATION_parser_->pre ();
		  }
		  else
		  {
			if (this->ILLUSTRATION_parser_)
			{
			  this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->ILLUSTRATION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHART_DIAGRAM_parser_;

			if (this->CHART_DIAGRAM_parser_)
			  this->CHART_DIAGRAM_parser_->pre ();
		  }
		  else
		  {
			if (this->CHART_DIAGRAM_parser_)
			{
			  this->CHART_DIAGRAM_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->CHART_DIAGRAM ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 7UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BOOKPLATE_parser_;

			if (this->BOOKPLATE_parser_)
			  this->BOOKPLATE_parser_->pre ();
		  }
		  else
		  {
			if (this->BOOKPLATE_parser_)
			{
			  this->BOOKPLATE_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->BOOKPLATE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 8UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BARCODE_parser_;

			if (this->BARCODE_parser_)
			  this->BARCODE_parser_->pre ();
		  }
		  else
		  {
			if (this->BARCODE_parser_)
			{
			  this->BARCODE_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->BARCODE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 9UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->SUBHEADLINE_parser_;

			if (this->SUBHEADLINE_parser_)
			  this->SUBHEADLINE_parser_->pre ();
		  }
		  else
		  {
			if (this->SUBHEADLINE_parser_)
			{
			  this->SUBHEADLINE_parser_->post_ct_FINAL ();
			  this->SUBHEADLINE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 10UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->HEADLINE_parser_;

			if (this->HEADLINE_parser_)
			  this->HEADLINE_parser_->pre ();
		  }
		  else
		  {
			if (this->HEADLINE_parser_)
			{
			  this->HEADLINE_parser_->post_ct_FINAL ();
			  this->HEADLINE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 11UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FORMULA_parser_;

			if (this->FORMULA_parser_)
			  this->FORMULA_parser_->pre ();
		  }
		  else
		  {
			if (this->FORMULA_parser_)
			{
			  this->FORMULA_parser_->post_ct_FORMULA ();
			  this->FORMULA ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 12UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FOOTNOTE_parser_;

			if (this->FOOTNOTE_parser_)
			  this->FOOTNOTE_parser_->pre ();
		  }
		  else
		  {
			if (this->FOOTNOTE_parser_)
			{
			  this->FOOTNOTE_parser_->post_ct_FOOTNOTE_PARAGRAPH ();
			  this->FOOTNOTE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 13UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

			if (this->AUTHOR_parser_)
			  this->AUTHOR_parser_->pre ();
		  }
		  else
		  {
			if (this->AUTHOR_parser_)
			{
			  this->AUTHOR_parser_->post_ct_FINAL ();
			  this->AUTHOR ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for CONTENT1_pskel.
	//
	bool CONTENT1_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TABLE" && ns.empty ())
			s = 0UL;
		  else if (n == "MAP" && ns.empty ())
			s = 1UL;
		  else if (n == "ILLUSTRATION" && ns.empty ())
			s = 2UL;
		  else if (n == "CHART_DIAGRAM" && ns.empty ())
			s = 3UL;
		  else if (n == "BOOKPLATE" && ns.empty ())
			s = 4UL;
		  else if (n == "BARCODE" && ns.empty ())
			s = 5UL;
		  else if (n == "FORMULA" && ns.empty ())
			s = 6UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &CONTENT1_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool CONTENT1_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void CONTENT1_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void CONTENT1_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void CONTENT1_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TABLE_parser_;

			if (this->TABLE_parser_)
			  this->TABLE_parser_->pre ();
		  }
		  else
		  {
			if (this->TABLE_parser_)
			{
			  this->TABLE_parser_->post_ct_TABLE_LIKE_STRUCT ();
			  this->TABLE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->MAP_parser_;

			if (this->MAP_parser_)
			  this->MAP_parser_->pre ();
		  }
		  else
		  {
			if (this->MAP_parser_)
			{
			  this->MAP_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->MAP ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ILLUSTRATION_parser_;

			if (this->ILLUSTRATION_parser_)
			  this->ILLUSTRATION_parser_->pre ();
		  }
		  else
		  {
			if (this->ILLUSTRATION_parser_)
			{
			  this->ILLUSTRATION_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->ILLUSTRATION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->CHART_DIAGRAM_parser_;

			if (this->CHART_DIAGRAM_parser_)
			  this->CHART_DIAGRAM_parser_->pre ();
		  }
		  else
		  {
			if (this->CHART_DIAGRAM_parser_)
			{
			  this->CHART_DIAGRAM_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->CHART_DIAGRAM ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 4UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BOOKPLATE_parser_;

			if (this->BOOKPLATE_parser_)
			  this->BOOKPLATE_parser_->pre ();
		  }
		  else
		  {
			if (this->BOOKPLATE_parser_)
			{
			  this->BOOKPLATE_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->BOOKPLATE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 5UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->BARCODE_parser_;

			if (this->BARCODE_parser_)
			  this->BARCODE_parser_->pre ();
		  }
		  else
		  {
			if (this->BARCODE_parser_)
			{
			  this->BARCODE_parser_->post_ct_ILLUSTRATION_LIKE_STRUCT ();
			  this->BARCODE ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 6UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->FORMULA_parser_;

			if (this->FORMULA_parser_)
			  this->FORMULA_parser_->pre ();
		  }
		  else
		  {
			if (this->FORMULA_parser_)
			{
			  this->FORMULA_parser_->post_ct_FORMULA ();
			  this->FORMULA ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for DATA_pskel.
	//
	bool DATA_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXTBLOCK" && ns.empty ())
			s = 0UL;
		  else if (n == "PAGE_NUMBER" && ns.empty ())
			s = 1UL;
		  else if (n == "ITEM_CAPTION" && ns.empty ())
			s = 2UL;
		  else if (n == "AUTHOR" && ns.empty ())
			s = 3UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &DATA_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool DATA_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void DATA_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void DATA_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void DATA_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXTBLOCK_parser_;

			if (this->TEXTBLOCK_parser_)
			  this->TEXTBLOCK_parser_->pre ();
		  }
		  else
		  {
			if (this->TEXTBLOCK_parser_)
			{
			  this->TEXTBLOCK_parser_->post_ct_FINAL ();
			  this->TEXTBLOCK ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->PAGE_NUMBER_parser_;

			if (this->PAGE_NUMBER_parser_)
			  this->PAGE_NUMBER_parser_->pre ();
		  }
		  else
		  {
			if (this->PAGE_NUMBER_parser_)
			{
			  this->PAGE_NUMBER_parser_->post_ct_FINAL ();
			  this->PAGE_NUMBER ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 2UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->ITEM_CAPTION_parser_;

			if (this->ITEM_CAPTION_parser_)
			  this->ITEM_CAPTION_parser_->pre ();
		  }
		  else
		  {
			if (this->ITEM_CAPTION_parser_)
			{
			  this->ITEM_CAPTION_parser_->post_ct_FINAL ();
			  this->ITEM_CAPTION ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 3UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->AUTHOR_parser_;

			if (this->AUTHOR_parser_)
			  this->AUTHOR_parser_->pre ();
		  }
		  else
		  {
			if (this->AUTHOR_parser_)
			{
			  this->AUTHOR_parser_->post_ct_FINAL ();
			  this->AUTHOR ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Element validation and dispatch functions for MOTTO_pskel.
	//
	bool MOTTO_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXT" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &MOTTO_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool MOTTO_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void MOTTO_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void MOTTO_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void MOTTO_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TEXT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

			  if (this->TEXT_parser_)
				this->TEXT_parser_->pre ();
			}
			else
			{
			  if (this->TEXT_parser_)
			  {
				this->TEXT_parser_->post_ct_FINAL ();
				this->TEXT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for HEADING_TEXT_pskel.
	//
	bool HEADING_TEXT_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "TEXT" && ns.empty ())
			s = 0UL;

		  if (s != ~0UL)
		  {
			vd->count++;
			vd->state = ~0UL;

			vd = vs.data + vs.size++;
			vd->func = &HEADING_TEXT_pskel::sequence_0;
			vd->state = s;
			vd->count = 0;

			this->sequence_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool HEADING_TEXT_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void HEADING_TEXT_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void HEADING_TEXT_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }


	  this->v_state_stack_.pop ();
	}

	void HEADING_TEXT_pskel::
	sequence_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start)
	{
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (n == "TEXT" && ns.empty ())
		  {
			if (start)
			{
			  this->::xml_schema::complex_content::context_.top ().parser_ = this->TEXT_parser_;

			  if (this->TEXT_parser_)
				this->TEXT_parser_->pre ();
			}
			else
			{
			  if (this->TEXT_parser_)
			  {
				this->TEXT_parser_->post_ct_FINAL ();
				this->TEXT ();
			  }

			  count++;
			}

			break;
		  }
		  else
		  {
			assert (start);
			count = 0;
			state = ~0UL;
			// Fall through.
		  }
		}
		case ~0UL:
		  break;
	  }
	}

	// Element validation and dispatch functions for par_pskel.
	//
	bool par_pskel::
	_start_element_impl (const ::xml_schema::ro_string& ns,
						 const ::xml_schema::ro_string& n,
						 const ::xml_schema::ro_string* t)
	{
	  XSD_UNUSED (t);

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  if (vd->func == 0 && vd->state == 0)
	  {
		if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
		  return true;
		else
		  vd->state = 1;
	  }

	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, ns, n, t, true);

		vd = vs.data + (vs.size - 1);

		if (vd->state == ~0UL)
		  vd = vs.data + (--vs.size - 1);
		else
		  break;
	  }

	  if (vd->func == 0)
	  {
		if (vd->state != ~0UL)
		{
		  unsigned long s = ~0UL;

		  if (n == "area" && ns.empty ())
			s = 0UL;
		  else if (n == "seq" && ns.empty ())
			s = 1UL;

		  if (s != ~0UL)
		  {
			vd->count++;

			vd = vs.data + vs.size++;
			vd->func = &par_pskel::choice_0;
			vd->state = s;
			vd->count = 0;

			this->choice_0 (vd->state, vd->count, ns, n, t, true);
		  }
		  else
		  {
			if (vd->count < 2UL)
			  this->_expected_element (
				"", "area",
				ns, n);
			return false;
		  }
		}
		else
		  return false;
	  }

	  return true;
	}

	bool par_pskel::
	_end_element_impl (const ::xml_schema::ro_string& ns,
					   const ::xml_schema::ro_string& n)
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size - 1];

	  if (vd.func == 0 && vd.state == 0)
	  {
		if (!::xml_schema::complex_content::_end_element_impl (ns, n))
		  assert (false);
		return true;
	  }

	  assert (vd.func != 0);
	  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

	  if (vd.state == ~0UL)
		vs.size--;

	  return true;
	}

	void par_pskel::
	_pre_e_validate ()
	{
	  this->v_state_stack_.push ();
	  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_& vd = vs.data[vs.size++];

	  vd.func = 0;
	  vd.state = 0;
	  vd.count = 0;
	}

	void par_pskel::
	_post_e_validate ()
	{
	  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
	  v_state_descr_* vd = vs.data + (vs.size - 1);

	  ::xml_schema::ro_string empty;
	  while (vd->func != 0)
	  {
		(this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
		assert (vd->state == ~0UL);
		vd = vs.data + (--vs.size - 1);
	  }

	  if (vd->count < 2UL)
		this->_expected_element (
		  "", "area");

	  this->v_state_stack_.pop ();
	}

	void par_pskel::
	choice_0 (unsigned long& state,
			  unsigned long& count,
			  const ::xml_schema::ro_string& ns,
			  const ::xml_schema::ro_string& n,
			  const ::xml_schema::ro_string* t,
			  bool start)
	{
	  XSD_UNUSED (count);
	  XSD_UNUSED (ns);
	  XSD_UNUSED (n);
	  XSD_UNUSED (t);

	  switch (state)
	  {
		case 0UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

			if (this->area_parser_)
			  this->area_parser_->pre ();
		  }
		  else
		  {
			if (this->area_parser_)
			{
			  this->area_parser_->post_any_type ();
			  this->area ();
			}

			state = ~0UL;
		  }

		  break;
		}
		case 1UL:
		{
		  if (start)
		  {
			this->::xml_schema::complex_content::context_.top ().parser_ = this->seq_parser_;

			if (this->seq_parser_)
			  this->seq_parser_->pre ();
		  }
		  else
		  {
			if (this->seq_parser_)
			{
			  this->seq_parser_->post_ct_SEQ ();
			  this->seq ();
			}

			state = ~0UL;
		  }

		  break;
		}
	  }
	}

	// Begin epilogue.
	//
	//
	// End epilogue.

}