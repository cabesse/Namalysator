// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___BNL_SERIAL_V1_0_PSKEL_HXX
#define CXX___BNL_SERIAL_V1_0_PSKEL_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

namespace bnl_serial_v1_0
{
	// Forward declarations
	//
	class ct_HIERARCHY_pskel;
	class ct_FRONT_pskel;
	class ct_MAIN_pskel;
	class ct_BACK_pskel;
	class ct_ISSUE_pskel;
	class ct_PAGE_LIKE_pskel;
	class ct_TITLE_SECTION_pskel;
	class ct_LIST_LIKE_pskel;
	class ct_ITEM_pskel;
	class ct_HEADING_pskel;
	class ct_CHAPTER_LIKE_pskel;
	class ct_MAP_GROUP_pskel;
	class ct_ILLUSTRATION_GROUP_pskel;
	class ct_CHART_DIAGRAM_GROUP_pskel;
	class ct_TABLE_GROUP_pskel;
	class ct_ILLUSTRATION_LIKE_STRUCT_pskel;
	class ct_TABLE_LIKE_STRUCT_pskel;
	class ct_BODY_pskel;
	class ct_BODY_CONTENT_pskel;
	class ct_FORMULA_pskel;
	class ct_PARAGRAPH_pskel;
	class ct_FOOTNOTE_PARAGRAPH_pskel;
	class ct_FINAL_pskel;
	class ct_FPTR_pskel;
	class ct_SEQ_pskel;
	class Serial_pskel;
	class CONTENT_pskel;
	class CONTENT1_pskel;
	class DATA_pskel;
	class MOTTO_pskel;
	class HEADING_TEXT_pskel;
	class par_pskel;
}

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_PARSER_USE_CHAR
#define XSD_CXX_PARSER_USE_CHAR
#endif

#include <xsd/cxx/xml/error-handler.hxx>
#include <xsd/cxx/parser/exceptions.hxx>
#include <xsd/cxx/parser/elements.hxx>
#include <xsd/cxx/parser/xml-schema.hxx>
#include <xsd/cxx/parser/validating/parser.hxx>
#include <xsd/cxx/parser/validating/exceptions.hxx>
#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
#include <xsd/cxx/parser/expat/elements.hxx>

namespace xml_schema
{
  // Built-in XML Schema types mapping.
  //
  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
  typedef ::xsd::cxx::parser::qname< char > qname;
  typedef ::xsd::cxx::parser::buffer buffer;
  typedef ::xsd::cxx::parser::time_zone time_zone;
  typedef ::xsd::cxx::parser::gday gday;
  typedef ::xsd::cxx::parser::gmonth gmonth;
  typedef ::xsd::cxx::parser::gyear gyear;
  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
  typedef ::xsd::cxx::parser::gyear_month gyear_month;
  typedef ::xsd::cxx::parser::date date;
  typedef ::xsd::cxx::parser::time time;
  typedef ::xsd::cxx::parser::date_time date_time;
  typedef ::xsd::cxx::parser::duration duration;

  // Base parser skeletons.
  //
  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;

  // Parser skeletons and implementations for the XML Schema
  // built-in types.
  //
  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;

  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;

  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;

  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;

  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;

  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;

  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;

  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;

  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;

  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;

  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;

  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;

  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;

  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;

  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;

  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;

  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;

  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;

  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;

  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;

  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;

  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;

  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;

  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;

  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;

  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;

  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;

  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;

  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;

  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;

  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;

  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;

  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;

  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;

  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;

  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
  //
  typedef ::xsd::cxx::parser::exception< char > exception;

  // Parsing diagnostics.
  //
  typedef ::xsd::cxx::parser::severity severity;
  typedef ::xsd::cxx::parser::error< char > error;
  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
  typedef ::xsd::cxx::parser::parsing< char > parsing;

  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // Read-only string.
  //
  typedef ::xsd::cxx::ro_string< char > ro_string;

  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
  // for details.
  //
  typedef ::xsd::cxx::parser::expat::document< char > document;
}

namespace bnl_serial_v1_0
{
	class ct_HIERARCHY_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  FRONT ();

	  virtual void
	  ISSUE ();

	  virtual void
	  BACK ();

	  virtual void
	  post_ct_HIERARCHY ();

	  // Parser construction API.
	  //
	  void
		  FRONT_parser (::bnl_serial_v1_0::ct_FRONT_pskel&);

	  void
	  ISSUE_parser (::bnl_serial_v1_0::ct_ISSUE_pskel&);

	  void
	  BACK_parser (::bnl_serial_v1_0::ct_BACK_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FRONT_pskel& /* FRONT */,
			   ::bnl_serial_v1_0::ct_ISSUE_pskel& /* ISSUE */,
			   ::bnl_serial_v1_0::ct_BACK_pskel& /* BACK */);

	  // Constructor.
	  //
	  ct_HIERARCHY_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FRONT_pskel* FRONT_parser_;
	  ::bnl_serial_v1_0::ct_ISSUE_pskel* ISSUE_parser_;
	  ::bnl_serial_v1_0::ct_BACK_pskel* BACK_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_HIERARCHY_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_FRONT_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TITLE_SECTION ();

	  virtual void
	  STATEMENT_SECTION ();

	  virtual void
	  PICTURE_SECTION ();

	  virtual void
	  FRONTISPIECE ();

	  virtual void
	  COVER_SECTION ();

	  virtual void
	  BASTARD_TITLE_SECTION ();

	  virtual void
	  TABLE_OF_CONTENTS ();

	  virtual void
	  REFERENCE_LIST ();

	  virtual void
	  LIST_OF_PUBLICATIONS ();

	  virtual void
	  LIST_OF_FIGURES ();

	  virtual void
	  INDEX ();

	  virtual void
	  CORRECTIONS ();

	  virtual void
	  BIBLIOGRAPHY ();

	  virtual void
	  ABBREVIATIONS ();

	  virtual void
	  RIDAS ();

	  virtual void
	  PRODUCTION_NOTE ();

	  virtual void
	  PREFACE ();

	  virtual void
	  NECROLOGY ();

	  virtual void
	  INTRODUCTION ();

	  virtual void
	  DEDICATION ();

	  virtual void
	  CHAPTER ();

	  virtual void
	  ACKNOWLEDGEMENTS ();

	  virtual void
	  ABSTRACT ();

	  virtual void
	  ADVERTISEMENT ();

	  virtual void
	  post_ct_FRONT ();

	  // Parser construction API.
	  //
	  void
	  TITLE_SECTION_parser (::bnl_serial_v1_0::ct_TITLE_SECTION_pskel&);

	  void
	  STATEMENT_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  PICTURE_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  FRONTISPIECE_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  COVER_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  BASTARD_TITLE_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  PRODUCTION_NOTE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  PREFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  INTRODUCTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  DEDICATION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ABSTRACT_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ADVERTISEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_TITLE_SECTION_pskel& /* TITLE_SECTION */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* STATEMENT_SECTION */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* PICTURE_SECTION */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* FRONTISPIECE */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* COVER_SECTION */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* BASTARD_TITLE_SECTION */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* REFERENCE_LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_PUBLICATIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_FIGURES */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* INDEX */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* CORRECTIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* BIBLIOGRAPHY */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* ABBREVIATIONS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* RIDAS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* PRODUCTION_NOTE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* PREFACE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* NECROLOGY */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* INTRODUCTION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* DEDICATION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* CHAPTER */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ACKNOWLEDGEMENTS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ABSTRACT */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* ADVERTISEMENT */);

	  // Constructor.
	  //
	  ct_FRONT_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_TITLE_SECTION_pskel* TITLE_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* STATEMENT_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* PICTURE_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* FRONTISPIECE_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* COVER_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* BASTARD_TITLE_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* REFERENCE_LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_PUBLICATIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_FIGURES_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* INDEX_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* CORRECTIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* BIBLIOGRAPHY_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* ABBREVIATIONS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* RIDAS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* PRODUCTION_NOTE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* PREFACE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* NECROLOGY_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* INTRODUCTION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* DEDICATION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* CHAPTER_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ACKNOWLEDGEMENTS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ABSTRACT_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* ADVERTISEMENT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_FRONT_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[3UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_MAIN_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TABLE_OF_CONTENTS ();

	  virtual void
	  REFERENCE_LIST ();

	  virtual void
	  LIST_OF_PUBLICATIONS ();

	  virtual void
	  LIST_OF_FIGURES ();

	  virtual void
	  LIST ();

	  virtual void
	  INDEX ();

	  virtual void
	  CORRECTIONS ();

	  virtual void
	  BIBLIOGRAPHY ();

	  virtual void
	  ABBREVIATIONS ();

	  virtual void
	  RIDAS ();

	  virtual void
	  PRODUCTION_NOTE ();

	  virtual void
	  PREFACE ();

	  virtual void
	  POSTFACE ();

	  virtual void
	  POEM ();

	  virtual void
	  NOTES ();

	  virtual void
	  NECROLOGY ();

	  virtual void
	  INTRODUCTION ();

	  virtual void
	  GROUP ();

	  virtual void
	  DEDICATION ();

	  virtual void
	  DEBATE ();

	  virtual void
	  CONTRIBUTION ();

	  virtual void
	  CHAPTER ();

	  virtual void
	  BOOK_REVIEW ();

	  virtual void
	  APPENDIX ();

	  virtual void
	  ACKNOWLEDGEMENTS ();

	  virtual void
	  ABSTRACT ();

	  virtual void
	  ADVERTISEMENT ();

	  virtual void
	  post_ct_MAIN ();

	  // Parser construction API.
	  //
	  void
	  TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  PRODUCTION_NOTE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  PREFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  POSTFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  POEM_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  NOTES_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  INTRODUCTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  GROUP_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  DEDICATION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  DEBATE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  CONTRIBUTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  BOOK_REVIEW_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  APPENDIX_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ABSTRACT_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ADVERTISEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* REFERENCE_LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_PUBLICATIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_FIGURES */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* INDEX */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* CORRECTIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* BIBLIOGRAPHY */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* ABBREVIATIONS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* RIDAS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* PRODUCTION_NOTE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* PREFACE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* POSTFACE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* POEM */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* NOTES */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* NECROLOGY */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* INTRODUCTION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* GROUP */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* DEDICATION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* DEBATE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* CONTRIBUTION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* CHAPTER */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* BOOK_REVIEW */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* APPENDIX */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ACKNOWLEDGEMENTS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ABSTRACT */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* ADVERTISEMENT */);

	  // Constructor.
	  //
	  ct_MAIN_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* REFERENCE_LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_PUBLICATIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_FIGURES_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* INDEX_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* CORRECTIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* BIBLIOGRAPHY_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* ABBREVIATIONS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* RIDAS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* PRODUCTION_NOTE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* PREFACE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* POSTFACE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* POEM_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* NOTES_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* NECROLOGY_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* INTRODUCTION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* GROUP_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* DEDICATION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* DEBATE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* CONTRIBUTION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* CHAPTER_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* BOOK_REVIEW_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* APPENDIX_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ACKNOWLEDGEMENTS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ABSTRACT_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* ADVERTISEMENT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_MAIN_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[3UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_BACK_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  STATEMENT_SECTION ();

	  virtual void
	  PICTURE_SECTION ();

	  virtual void
	  COVER_SECTION ();

	  virtual void
	  TABLE_OF_CONTENTS ();

	  virtual void
	  REFERENCE_LIST ();

	  virtual void
	  LIST_OF_PUBLICATIONS ();

	  virtual void
	  LIST_OF_FIGURES ();

	  virtual void
	  LIST ();

	  virtual void
	  INDEX ();

	  virtual void
	  CORRECTIONS ();

	  virtual void
	  BIBLIOGRAPHY ();

	  virtual void
	  ABBREVIATIONS ();

	  virtual void
	  RIDAS ();

	  virtual void
	  POSTFACE ();

	  virtual void
	  NECROLOGY ();

	  virtual void
	  CHAPTER ();

	  virtual void
	  APPENDIX ();

	  virtual void
	  ACKNOWLEDGEMENTS ();

	  virtual void
	  ADVERTISEMENT ();

	  virtual void
	  post_ct_BACK ();

	  // Parser construction API.
	  //
	  void
	  STATEMENT_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  PICTURE_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  COVER_SECTION_parser (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel&);

	  void
	  TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  POSTFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  APPENDIX_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ADVERTISEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* STATEMENT_SECTION */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* PICTURE_SECTION */,
			   ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel& /* COVER_SECTION */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* REFERENCE_LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_PUBLICATIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_FIGURES */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* INDEX */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* CORRECTIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* BIBLIOGRAPHY */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* ABBREVIATIONS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* RIDAS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* POSTFACE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* NECROLOGY */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* CHAPTER */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* APPENDIX */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ACKNOWLEDGEMENTS */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* ADVERTISEMENT */);

	  // Constructor.
	  //
	  ct_BACK_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* STATEMENT_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* PICTURE_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_PAGE_LIKE_pskel* COVER_SECTION_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* REFERENCE_LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_PUBLICATIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_FIGURES_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* INDEX_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* CORRECTIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* BIBLIOGRAPHY_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* ABBREVIATIONS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* RIDAS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* POSTFACE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* NECROLOGY_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* CHAPTER_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* APPENDIX_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ACKNOWLEDGEMENTS_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* ADVERTISEMENT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_BACK_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[3UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_ISSUE_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  MAIN ();

	  virtual void
	  FRONT ();

	  virtual void
	  BACK ();

	  virtual void
	  post_ct_ISSUE ();

	  // Parser construction API.
	  //
	  void
	  MAIN_parser (::bnl_serial_v1_0::ct_MAIN_pskel&);

	  void
	  FRONT_parser (::bnl_serial_v1_0::ct_FRONT_pskel&);

	  void
	  BACK_parser (::bnl_serial_v1_0::ct_BACK_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_MAIN_pskel& /* MAIN */,
			   ::bnl_serial_v1_0::ct_FRONT_pskel& /* FRONT */,
			   ::bnl_serial_v1_0::ct_BACK_pskel& /* BACK */);

	  // Constructor.
	  //
	  ct_ISSUE_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_MAIN_pskel* MAIN_parser_;
	  ::bnl_serial_v1_0::ct_FRONT_pskel* FRONT_parser_;
	  ::bnl_serial_v1_0::ct_BACK_pskel* BACK_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_ISSUE_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_PAGE_LIKE_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  CONTENT ();

	  virtual void
	  post_ct_PAGE_LIKE ();

	  // Parser construction API.
	  //
	  void
	  CONTENT_parser (::bnl_serial_v1_0::CONTENT_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::CONTENT_pskel& /* CONTENT */);

	  // Constructor.
	  //
	  ct_PAGE_LIKE_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::CONTENT_pskel* CONTENT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_PAGE_LIKE_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_TITLE_SECTION_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TITLE_OF_WORK ();

	  virtual void
	  CREATOR_OF_WORK ();

	  virtual void
	  PUBLISHING_STMT ();

	  virtual void
	  STATEMENT ();

	  virtual void
	  CONTENT ();

	  virtual void
	  post_ct_TITLE_SECTION ();

	  // Parser construction API.
	  //
	  void
	  TITLE_OF_WORK_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  CREATOR_OF_WORK_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  PUBLISHING_STMT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  STATEMENT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  CONTENT_parser (::bnl_serial_v1_0::CONTENT1_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TITLE_OF_WORK */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* CREATOR_OF_WORK */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* PUBLISHING_STMT */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* STATEMENT */,
			   ::bnl_serial_v1_0::CONTENT1_pskel& /* CONTENT */);

	  // Constructor.
	  //
	  ct_TITLE_SECTION_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TITLE_OF_WORK_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* CREATOR_OF_WORK_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* STATEMENT_parser_;
	  ::bnl_serial_v1_0::CONTENT1_pskel* CONTENT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_TITLE_SECTION_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_LIST_LIKE_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  CAPTION ();

	  virtual void
	  DATA ();

	  virtual void
	  TABLE_OF_CONTENTS ();

	  virtual void
	  REFERENCE_LIST ();

	  virtual void
	  LIST_OF_PUBLICATIONS ();

	  virtual void
	  LIST_OF_FIGURES ();

	  virtual void
	  LIST ();

	  virtual void
	  INDEX ();

	  virtual void
	  CORRECTIONS ();

	  virtual void
	  BIBLIOGRAPHY ();

	  virtual void
	  ABBREVIATIONS ();

	  virtual void
	  ITEM ();

	  virtual void
	  post_ct_LIST_LIKE ();

	  // Parser construction API.
	  //
	  void
	  CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  DATA_parser (::bnl_serial_v1_0::DATA_pskel&);

	  void
	  TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  ITEM_parser (::bnl_serial_v1_0::ct_ITEM_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* CAPTION */,
			   ::bnl_serial_v1_0::DATA_pskel& /* DATA */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* REFERENCE_LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_PUBLICATIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_FIGURES */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* INDEX */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* CORRECTIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* BIBLIOGRAPHY */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* ABBREVIATIONS */,
			   ::bnl_serial_v1_0::ct_ITEM_pskel& /* ITEM */);

	  // Constructor.
	  //
	  ct_LIST_LIKE_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* CAPTION_parser_;
	  ::bnl_serial_v1_0::DATA_pskel* DATA_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* REFERENCE_LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_PUBLICATIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_FIGURES_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* INDEX_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* CORRECTIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* BIBLIOGRAPHY_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* ABBREVIATIONS_parser_;
	  ::bnl_serial_v1_0::ct_ITEM_pskel* ITEM_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_LIST_LIKE_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[3UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_ITEM_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXTBLOCK ();

	  virtual void
	  PAGE_NUMBER ();

	  virtual void
	  ITEM_CAPTION ();

	  virtual void
	  SUBHEADLINE ();

	  virtual void
	  HEADLINE ();

	  virtual void
	  AUTHOR ();

	  virtual void
	  ITEM ();

	  virtual void
	  post_ct_ITEM ();

	  // Parser construction API.
	  //
	  void
	  TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  PAGE_NUMBER_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  ITEM_CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  SUBHEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  HEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  ITEM_parser (::bnl_serial_v1_0::ct_ITEM_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXTBLOCK */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* PAGE_NUMBER */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* ITEM_CAPTION */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* SUBHEADLINE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* HEADLINE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* AUTHOR */,
			   ::bnl_serial_v1_0::ct_ITEM_pskel& /* ITEM */);

	  // Constructor.
	  //
	  ct_ITEM_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXTBLOCK_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* PAGE_NUMBER_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* ITEM_CAPTION_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* SUBHEADLINE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* HEADLINE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* AUTHOR_parser_;
	  ::bnl_serial_v1_0::ct_ITEM_pskel* ITEM_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_ITEM_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[3UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_HEADING_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TITLE ();

	  virtual void
	  SUBTITLE ();

	  virtual void
	  AUTHOR ();

	  virtual void
	  MOTTO ();

	  virtual void
	  HEADING_TEXT ();

	  virtual void
	  post_ct_HEADING ();

	  // Parser construction API.
	  //
	  void
	  TITLE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  SUBTITLE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  MOTTO_parser (::bnl_serial_v1_0::MOTTO_pskel&);

	  void
	  HEADING_TEXT_parser (::bnl_serial_v1_0::HEADING_TEXT_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TITLE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* SUBTITLE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* AUTHOR */,
			   ::bnl_serial_v1_0::MOTTO_pskel& /* MOTTO */,
			   ::bnl_serial_v1_0::HEADING_TEXT_pskel& /* HEADING_TEXT */);

	  // Constructor.
	  //
	  ct_HEADING_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TITLE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* SUBTITLE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* AUTHOR_parser_;
	  ::bnl_serial_v1_0::MOTTO_pskel* MOTTO_parser_;
	  ::bnl_serial_v1_0::HEADING_TEXT_pskel* HEADING_TEXT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_HEADING_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_CHAPTER_LIKE_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  HEADING ();

	  virtual void
	  ABSTRACT ();

	  virtual void
	  BODY ();

	  virtual void
	  TABLE_OF_CONTENTS ();

	  virtual void
	  REFERENCE_LIST ();

	  virtual void
	  LIST_OF_PUBLICATIONS ();

	  virtual void
	  LIST_OF_FIGURES ();

	  virtual void
	  INDEX ();

	  virtual void
	  CORRECTIONS ();

	  virtual void
	  BIBLIOGRAPHY ();

	  virtual void
	  ABBREVIATIONS ();

	  virtual void
	  RIDAS ();

	  virtual void
	  PRODUCTION_NOTE ();

	  virtual void
	  PREFACE ();

	  virtual void
	  POSTFACE ();

	  virtual void
	  POEM ();

	  virtual void
	  NOTES ();

	  virtual void
	  NECROLOGY ();

	  virtual void
	  INTRODUCTION ();

	  virtual void
	  GROUP ();

	  virtual void
	  DEDICATION ();

	  virtual void
	  DEBATE ();

	  virtual void
	  CONTRIBUTION ();

	  virtual void
	  CHAPTER ();

	  virtual void
	  BOOK_REVIEW ();

	  virtual void
	  APPENDIX ();

	  virtual void
	  ACKNOWLEDGEMENTS ();

	  virtual void
	  MAP_GROUP ();

	  virtual void
	  ILLUSTRATION_GROUP ();

	  virtual void
	  CHART_DIAGRAM_GROUP ();

	  virtual void
	  TABLE_GROUP ();

	  virtual void
	  post_ct_CHAPTER_LIKE ();

	  // Parser construction API.
	  //
	  void
	  HEADING_parser (::bnl_serial_v1_0::ct_HEADING_pskel&);

	  void
	  ABSTRACT_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  BODY_parser (::bnl_serial_v1_0::ct_BODY_pskel&);

	  void
	  TABLE_OF_CONTENTS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  REFERENCE_LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_PUBLICATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  LIST_OF_FIGURES_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  INDEX_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  CORRECTIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  BIBLIOGRAPHY_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  ABBREVIATIONS_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  RIDAS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  PRODUCTION_NOTE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  PREFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  POSTFACE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  POEM_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  NOTES_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  NECROLOGY_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  INTRODUCTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  GROUP_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  DEDICATION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  DEBATE_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  CONTRIBUTION_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  CHAPTER_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  BOOK_REVIEW_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  APPENDIX_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  ACKNOWLEDGEMENTS_parser (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel&);

	  void
	  MAP_GROUP_parser (::bnl_serial_v1_0::ct_MAP_GROUP_pskel&);

	  void
	  ILLUSTRATION_GROUP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_GROUP_pskel&);

	  void
	  CHART_DIAGRAM_GROUP_parser (::bnl_serial_v1_0::ct_CHART_DIAGRAM_GROUP_pskel&);

	  void
	  TABLE_GROUP_parser (::bnl_serial_v1_0::ct_TABLE_GROUP_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_HEADING_pskel& /* HEADING */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ABSTRACT */,
			   ::bnl_serial_v1_0::ct_BODY_pskel& /* BODY */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* REFERENCE_LIST */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_PUBLICATIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST_OF_FIGURES */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* INDEX */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* CORRECTIONS */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* BIBLIOGRAPHY */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* ABBREVIATIONS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* RIDAS */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* PRODUCTION_NOTE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* PREFACE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* POSTFACE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* POEM */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* NOTES */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* NECROLOGY */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* INTRODUCTION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* GROUP */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* DEDICATION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* DEBATE */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* CONTRIBUTION */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* CHAPTER */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* BOOK_REVIEW */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* APPENDIX */,
			   ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel& /* ACKNOWLEDGEMENTS */,
			   ::bnl_serial_v1_0::ct_MAP_GROUP_pskel& /* MAP_GROUP */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_GROUP_pskel& /* ILLUSTRATION_GROUP */,
			   ::bnl_serial_v1_0::ct_CHART_DIAGRAM_GROUP_pskel& /* CHART_DIAGRAM_GROUP */,
			   ::bnl_serial_v1_0::ct_TABLE_GROUP_pskel& /* TABLE_GROUP */);

	  // Constructor.
	  //
	  ct_CHAPTER_LIKE_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_HEADING_pskel* HEADING_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ABSTRACT_parser_;
	  ::bnl_serial_v1_0::ct_BODY_pskel* BODY_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* REFERENCE_LIST_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_PUBLICATIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_OF_FIGURES_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* INDEX_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* CORRECTIONS_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* BIBLIOGRAPHY_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* ABBREVIATIONS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* RIDAS_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* PRODUCTION_NOTE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* PREFACE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* POSTFACE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* POEM_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* NOTES_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* NECROLOGY_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* INTRODUCTION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* GROUP_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* DEDICATION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* DEBATE_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* CONTRIBUTION_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* CHAPTER_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* BOOK_REVIEW_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* APPENDIX_parser_;
	  ::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel* ACKNOWLEDGEMENTS_parser_;
	  ::bnl_serial_v1_0::ct_MAP_GROUP_pskel* MAP_GROUP_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_GROUP_pskel* ILLUSTRATION_GROUP_parser_;
	  ::bnl_serial_v1_0::ct_CHART_DIAGRAM_GROUP_pskel* CHART_DIAGRAM_GROUP_parser_;
	  ::bnl_serial_v1_0::ct_TABLE_GROUP_pskel* TABLE_GROUP_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_CHAPTER_LIKE_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[3UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_MAP_GROUP_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  MAP ();

	  virtual void
	  post_ct_MAP_GROUP ();

	  // Parser construction API.
	  //
	  void
	  MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* MAP */);

	  // Constructor.
	  //
	  ct_MAP_GROUP_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* MAP_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_MAP_GROUP_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_ILLUSTRATION_GROUP_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  ILLUSTRATION ();

	  virtual void
	  post_ct_ILLUSTRATION_GROUP ();

	  // Parser construction API.
	  //
	  void
	  ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */);

	  // Constructor.
	  //
	  ct_ILLUSTRATION_GROUP_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_ILLUSTRATION_GROUP_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_CHART_DIAGRAM_GROUP_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  CHART_DIAGRAM ();

	  virtual void
	  post_ct_CHART_DIAGRAM_GROUP ();

	  // Parser construction API.
	  //
	  void
	  CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* CHART_DIAGRAM */);

	  // Constructor.
	  //
	  ct_CHART_DIAGRAM_GROUP_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* CHART_DIAGRAM_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_CHART_DIAGRAM_GROUP_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_TABLE_GROUP_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TABLE ();

	  virtual void
	  post_ct_TABLE_GROUP ();

	  // Parser construction API.
	  //
	  void
	  TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */);

	  // Constructor.
	  //
	  ct_TABLE_GROUP_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_TABLE_GROUP_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_ILLUSTRATION_LIKE_STRUCT_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  IMAGE ();

	  virtual void
	  CAPTION ();

	  virtual void
	  post_ct_ILLUSTRATION_LIKE_STRUCT ();

	  // Parser construction API.
	  //
	  void
	  IMAGE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* IMAGE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* CAPTION */);

	  // Constructor.
	  //
	  ct_ILLUSTRATION_LIKE_STRUCT_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* IMAGE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* CAPTION_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_TABLE_LIKE_STRUCT_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  IMAGE ();

	  virtual void
	  CAPTION ();

	  virtual void
	  post_ct_TABLE_LIKE_STRUCT ();

	  // Parser construction API.
	  //
	  void
	  IMAGE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* IMAGE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* CAPTION */);

	  // Constructor.
	  //
	  ct_TABLE_LIKE_STRUCT_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* IMAGE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* CAPTION_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_BODY_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  BODY_CONTENT ();

	  virtual void
	  FOOTNOTE ();

	  virtual void
	  MAP ();

	  virtual void
	  ILLUSTRATION ();

	  virtual void
	  CHART_DIAGRAM ();

	  virtual void
	  BOOKPLATE ();

	  virtual void
	  BARCODE ();

	  virtual void
	  TABLE ();

	  virtual void
	  LIST ();

	  virtual void
	  post_ct_BODY ();

	  // Parser construction API.
	  //
	  void
	  BODY_CONTENT_parser (::bnl_serial_v1_0::ct_BODY_CONTENT_pskel&);

	  void
	  FOOTNOTE_parser (::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel&);

	  void
	  MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  BOOKPLATE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  BARCODE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel&);

	  void
	  LIST_parser (::bnl_serial_v1_0::ct_LIST_LIKE_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_BODY_CONTENT_pskel& /* BODY_CONTENT */,
			   ::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel& /* FOOTNOTE */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* MAP */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* CHART_DIAGRAM */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* BOOKPLATE */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* BARCODE */,
			   ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */,
			   ::bnl_serial_v1_0::ct_LIST_LIKE_pskel& /* LIST */);

	  // Constructor.
	  //
	  ct_BODY_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_BODY_CONTENT_pskel* BODY_CONTENT_parser_;
	  ::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel* FOOTNOTE_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* MAP_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* CHART_DIAGRAM_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* BOOKPLATE_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* BARCODE_parser_;
	  ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;
	  ::bnl_serial_v1_0::ct_LIST_LIKE_pskel* LIST_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_BODY_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_BODY_CONTENT_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXTBLOCK ();

	  virtual void
	  PARAGRAPH ();

	  virtual void
	  FORMULA ();

	  virtual void
	  post_ct_BODY_CONTENT ();

	  // Parser construction API.
	  //
	  void
	  TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  PARAGRAPH_parser (::bnl_serial_v1_0::ct_PARAGRAPH_pskel&);

	  void
	  FORMULA_parser (::bnl_serial_v1_0::ct_FORMULA_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXTBLOCK */,
			   ::bnl_serial_v1_0::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
			   ::bnl_serial_v1_0::ct_FORMULA_pskel& /* FORMULA */);

	  // Constructor.
	  //
	  ct_BODY_CONTENT_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXTBLOCK_parser_;
	  ::bnl_serial_v1_0::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
	  ::bnl_serial_v1_0::ct_FORMULA_pskel* FORMULA_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_BODY_CONTENT_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_FORMULA_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  IMAGE ();

	  virtual void
	  post_ct_FORMULA ();

	  // Parser construction API.
	  //
	  void
	  IMAGE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* IMAGE */);

	  // Constructor.
	  //
	  ct_FORMULA_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* IMAGE_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_FORMULA_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_PARAGRAPH_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXT ();

	  virtual void
	  MARGINALIA ();

	  virtual void
	  post_ct_PARAGRAPH ();

	  // Parser construction API.
	  //
	  void
	  TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  MARGINALIA_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXT */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* MARGINALIA */);

	  // Constructor.
	  //
	  ct_PARAGRAPH_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXT_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* MARGINALIA_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_PARAGRAPH_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_FOOTNOTE_PARAGRAPH_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXT ();

	  virtual void
	  post_ct_FOOTNOTE_PARAGRAPH ();

	  // Parser construction API.
	  //
	  void
	  TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXT */);

	  // Constructor.
	  //
	  ct_FOOTNOTE_PARAGRAPH_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_FINAL_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  fptr ();

	  virtual void
	  post_ct_FINAL ();

	  // Parser construction API.
	  //
	  void
	  fptr_parser (::bnl_serial_v1_0::ct_FPTR_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FPTR_pskel& /* fptr */);

	  // Constructor.
	  //
	  ct_FINAL_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FPTR_pskel* fptr_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_FINAL_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class ct_FPTR_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  area ();

	  virtual void
	  seq ();

	  virtual void
	  par ();

	  virtual void
	  post_ct_FPTR ();

	  // Parser construction API.
	  //
	  void
	  area_parser (::xml_schema::any_type_pskel&);

	  void
	  seq_parser (::bnl_serial_v1_0::ct_SEQ_pskel&);

	  void
	  par_parser (::bnl_serial_v1_0::par_pskel&);

	  void
	  parsers (::xml_schema::any_type_pskel& /* area */,
			   ::bnl_serial_v1_0::ct_SEQ_pskel& /* seq */,
			   ::bnl_serial_v1_0::par_pskel& /* par */);

	  // Constructor.
	  //
	  ct_FPTR_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::xml_schema::any_type_pskel* area_parser_;
	  ::bnl_serial_v1_0::ct_SEQ_pskel* seq_parser_;
	  ::bnl_serial_v1_0::par_pskel* par_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_FPTR_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class ct_SEQ_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  area ();

	  virtual void
	  post_ct_SEQ ();

	  // Parser construction API.
	  //
	  void
	  area_parser (::xml_schema::any_type_pskel&);

	  void
	  parsers (::xml_schema::any_type_pskel& /* area */);

	  // Constructor.
	  //
	  ct_SEQ_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::xml_schema::any_type_pskel* area_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::ct_SEQ_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class Serial_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  VOLUME ();

	  virtual void
	  post_Serial ();

	  // Parser construction API.
	  //
	  void
	  VOLUME_parser (::bnl_serial_v1_0::ct_HIERARCHY_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_HIERARCHY_pskel& /* VOLUME */);

	  // Constructor.
	  //
	  Serial_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_HIERARCHY_pskel* VOLUME_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::Serial_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class CONTENT_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXTBLOCK ();

	  virtual void
	  TABLE ();

	  virtual void
	  PUBLISHING_STMT ();

	  virtual void
	  PARAGRAPH ();

	  virtual void
	  MAP ();

	  virtual void
	  ILLUSTRATION ();

	  virtual void
	  CHART_DIAGRAM ();

	  virtual void
	  BOOKPLATE ();

	  virtual void
	  BARCODE ();

	  virtual void
	  SUBHEADLINE ();

	  virtual void
	  HEADLINE ();

	  virtual void
	  FORMULA ();

	  virtual void
	  FOOTNOTE ();

	  virtual void
	  AUTHOR ();

	  virtual void
	  post_CONTENT ();

	  // Parser construction API.
	  //
	  void
	  TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel&);

	  void
	  PUBLISHING_STMT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  PARAGRAPH_parser (::bnl_serial_v1_0::ct_PARAGRAPH_pskel&);

	  void
	  MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  BOOKPLATE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  BARCODE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  SUBHEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  HEADLINE_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  FORMULA_parser (::bnl_serial_v1_0::ct_FORMULA_pskel&);

	  void
	  FOOTNOTE_parser (::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel&);

	  void
	  AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXTBLOCK */,
			   ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* PUBLISHING_STMT */,
			   ::bnl_serial_v1_0::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* MAP */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* CHART_DIAGRAM */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* BOOKPLATE */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* BARCODE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* SUBHEADLINE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* HEADLINE */,
			   ::bnl_serial_v1_0::ct_FORMULA_pskel& /* FORMULA */,
			   ::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel& /* FOOTNOTE */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* AUTHOR */);

	  // Constructor.
	  //
	  CONTENT_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXTBLOCK_parser_;
	  ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
	  ::bnl_serial_v1_0::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* MAP_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* CHART_DIAGRAM_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* BOOKPLATE_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* BARCODE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* SUBHEADLINE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* HEADLINE_parser_;
	  ::bnl_serial_v1_0::ct_FORMULA_pskel* FORMULA_parser_;
	  ::bnl_serial_v1_0::ct_FOOTNOTE_PARAGRAPH_pskel* FOOTNOTE_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* AUTHOR_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::CONTENT_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class CONTENT1_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TABLE ();

	  virtual void
	  MAP ();

	  virtual void
	  ILLUSTRATION ();

	  virtual void
	  CHART_DIAGRAM ();

	  virtual void
	  BOOKPLATE ();

	  virtual void
	  BARCODE ();

	  virtual void
	  FORMULA ();

	  virtual void
	  post_CONTENT1 ();

	  // Parser construction API.
	  //
	  void
	  TABLE_parser (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel&);

	  void
	  MAP_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  ILLUSTRATION_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  CHART_DIAGRAM_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  BOOKPLATE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  BARCODE_parser (::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

	  void
	  FORMULA_parser (::bnl_serial_v1_0::ct_FORMULA_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* MAP */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* CHART_DIAGRAM */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* BOOKPLATE */,
			   ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* BARCODE */,
			   ::bnl_serial_v1_0::ct_FORMULA_pskel& /* FORMULA */);

	  // Constructor.
	  //
	  CONTENT1_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* MAP_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* CHART_DIAGRAM_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* BOOKPLATE_parser_;
	  ::bnl_serial_v1_0::ct_ILLUSTRATION_LIKE_STRUCT_pskel* BARCODE_parser_;
	  ::bnl_serial_v1_0::ct_FORMULA_pskel* FORMULA_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::CONTENT1_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class DATA_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXTBLOCK ();

	  virtual void
	  PAGE_NUMBER ();

	  virtual void
	  ITEM_CAPTION ();

	  virtual void
	  AUTHOR ();

	  virtual void
	  post_DATA ();

	  // Parser construction API.
	  //
	  void
	  TEXTBLOCK_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  PAGE_NUMBER_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  ITEM_CAPTION_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  AUTHOR_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXTBLOCK */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* PAGE_NUMBER */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* ITEM_CAPTION */,
			   ::bnl_serial_v1_0::ct_FINAL_pskel& /* AUTHOR */);

	  // Constructor.
	  //
	  DATA_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXTBLOCK_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* PAGE_NUMBER_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* ITEM_CAPTION_parser_;
	  ::bnl_serial_v1_0::ct_FINAL_pskel* AUTHOR_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::DATA_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};

	class MOTTO_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXT ();

	  virtual void
	  post_MOTTO ();

	  // Parser construction API.
	  //
	  void
	  TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXT */);

	  // Constructor.
	  //
	  MOTTO_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::MOTTO_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class HEADING_TEXT_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  TEXT ();

	  virtual void
	  post_HEADING_TEXT ();

	  // Parser construction API.
	  //
	  void
	  TEXT_parser (::bnl_serial_v1_0::ct_FINAL_pskel&);

	  void
	  parsers (::bnl_serial_v1_0::ct_FINAL_pskel& /* TEXT */);

	  // Constructor.
	  //
	  HEADING_TEXT_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::bnl_serial_v1_0::ct_FINAL_pskel* TEXT_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::HEADING_TEXT_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  sequence_0 (unsigned long& state,
				  unsigned long& count,
				  const ::xml_schema::ro_string& ns,
				  const ::xml_schema::ro_string& n,
				  const ::xml_schema::ro_string* t,
				  bool start);
	};

	class par_pskel: public ::xml_schema::complex_content
	{
	  public:
	  // Parser callbacks. Override them in your implementation.
	  //
	  // virtual void
	  // pre ();

	  virtual void
	  area ();

	  virtual void
	  seq ();

	  virtual void
	  post_par ();

	  // Parser construction API.
	  //
	  void
	  area_parser (::xml_schema::any_type_pskel&);

	  void
	  seq_parser (::bnl_serial_v1_0::ct_SEQ_pskel&);

	  void
	  parsers (::xml_schema::any_type_pskel& /* area */,
			   ::bnl_serial_v1_0::ct_SEQ_pskel& /* seq */);

	  // Constructor.
	  //
	  par_pskel ();

	  // Implementation.
	  //
	  protected:
	  virtual bool
	  _start_element_impl (const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string&,
						   const ::xml_schema::ro_string*);

	  virtual bool
	  _end_element_impl (const ::xml_schema::ro_string&,
						 const ::xml_schema::ro_string&);

	  protected:
	  ::xml_schema::any_type_pskel* area_parser_;
	  ::bnl_serial_v1_0::ct_SEQ_pskel* seq_parser_;

	  protected:
	  struct v_state_descr_
	  {
		void (::bnl_serial_v1_0::par_pskel::*func) (
		  unsigned long&,
		  unsigned long&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string&,
		  const ::xml_schema::ro_string*,
		  bool);
		unsigned long state;
		unsigned long count;
	  };

	  struct v_state_
	  {
		v_state_descr_ data[2UL];
		unsigned long size;
	  };

	  v_state_ v_state_first_;
	  ::xsd::cxx::parser::pod_stack v_state_stack_;

	  virtual void
	  _pre_e_validate ();

	  virtual void
	  _post_e_validate ();

	  void
	  choice_0 (unsigned long& state,
				unsigned long& count,
				const ::xml_schema::ro_string& ns,
				const ::xml_schema::ro_string& n,
				const ::xml_schema::ro_string* t,
				bool start);
	};
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___BNL_SERIAL_V1_0_PSKEL_HXX
