// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "alto-1-2-pskel.hxx"

namespace ALTO
{
  // BlockType_pskel
  //

  void BlockType_pskel::
  Shape ()
  {
  }

  void BlockType_pskel::
  ID (const ::std::string&)
  {
  }

  void BlockType_pskel::
  STYLEREFS (const ::xml_schema::string_sequence&)
  {
  }

  void BlockType_pskel::
  HEIGHT (int)
  {
  }

  void BlockType_pskel::
  WIDTH (int)
  {
  }

  void BlockType_pskel::
  HPOS (int)
  {
  }

  void BlockType_pskel::
  VPOS (int)
  {
  }

  void BlockType_pskel::
  ROTATION (float)
  {
  }

  void BlockType_pskel::
  IDNEXT (const ::std::string&)
  {
  }

  void BlockType_pskel::
  type (const ::std::string&)
  {
  }

  void BlockType_pskel::
  href (const ::std::string&)
  {
  }

  void BlockType_pskel::
  role (const ::std::string&)
  {
  }

  void BlockType_pskel::
  arcrole (const ::std::string&)
  {
  }

  void BlockType_pskel::
  title (const ::std::string&)
  {
  }

  void BlockType_pskel::
  show ()
  {
  }

  void BlockType_pskel::
  actuate ()
  {
  }

  void BlockType_pskel::
  post_BlockType ()
  {
  }

  // StringType_pskel
  //

  void StringType_pskel::
  ALTERNATIVE ()
  {
  }

  void StringType_pskel::
  ID (const ::std::string&)
  {
  }

  void StringType_pskel::
  STYLEREFS (const ::xml_schema::string_sequence&)
  {
  }

  void StringType_pskel::
  HEIGHT (float)
  {
  }

  void StringType_pskel::
  WIDTH (float)
  {
  }

  void StringType_pskel::
  HPOS (float)
  {
  }

  void StringType_pskel::
  VPOS (float)
  {
  }

  void StringType_pskel::
  CONTENT ()
  {
  }

  void StringType_pskel::
  STYLE ()
  {
  }

  void StringType_pskel::
  SUBS_TYPE ()
  {
  }

  void StringType_pskel::
  SUBS_CONTENT (const ::std::string&)
  {
  }

  void StringType_pskel::
  WC ()
  {
  }

  void StringType_pskel::
  CC (const ::std::string&)
  {
  }

  void StringType_pskel::
  post_StringType ()
  {
  }

  // PageSpaceType_pskel
  //

  void PageSpaceType_pskel::
  TextBlock ()
  {
  }

  void PageSpaceType_pskel::
  Illustration ()
  {
  }

  void PageSpaceType_pskel::
  GraphicalElement ()
  {
  }

  void PageSpaceType_pskel::
  ComposedBlock ()
  {
  }

  void PageSpaceType_pskel::
  ID (const ::std::string&)
  {
  }

  void PageSpaceType_pskel::
  STYLEREFS (const ::xml_schema::string_sequence&)
  {
  }

  void PageSpaceType_pskel::
  HEIGHT (float)
  {
  }

  void PageSpaceType_pskel::
  WIDTH (float)
  {
  }

  void PageSpaceType_pskel::
  HPOS (float)
  {
  }

  void PageSpaceType_pskel::
  VPOS (float)
  {
  }

  void PageSpaceType_pskel::
  PC ()
  {
  }

  void PageSpaceType_pskel::
  post_PageSpaceType ()
  {
  }

  // PointsType_pskel
  //

  void PointsType_pskel::
  post_PointsType ()
  {
  }

  // ShapeType_pskel
  //

  void ShapeType_pskel::
  Polygon ()
  {
  }

  void ShapeType_pskel::
  Ellipse ()
  {
  }

  void ShapeType_pskel::
  Circle ()
  {
  }

  void ShapeType_pskel::
  post_ShapeType ()
  {
  }

  // PolygonType_pskel
  //

  void PolygonType_pskel::
  POINTS ()
  {
  }

  void PolygonType_pskel::
  post_PolygonType ()
  {
  }

  // EllipseType_pskel
  //

  void EllipseType_pskel::
  HPOS ()
  {
  }

  void EllipseType_pskel::
  VPOS ()
  {
  }

  void EllipseType_pskel::
  HLENGTH ()
  {
  }

  void EllipseType_pskel::
  VLENGTH ()
  {
  }

  void EllipseType_pskel::
  post_EllipseType ()
  {
  }

  // CircleType_pskel
  //

  void CircleType_pskel::
  HPOS ()
  {
  }

  void CircleType_pskel::
  VPOS ()
  {
  }

  void CircleType_pskel::
  RADIUS ()
  {
  }

  void CircleType_pskel::
  post_CircleType ()
  {
  }

  // fontTypeType_pskel
  //

  void fontTypeType_pskel::
  post_fontTypeType ()
  {
  }

  // fontWidthType_pskel
  //

  void fontWidthType_pskel::
  post_fontWidthType ()
  {
  }

  // sourceImageInformationType_pskel
  //

  void sourceImageInformationType_pskel::
  fileName (const ::std::string&)
  {
  }

  void sourceImageInformationType_pskel::
  fileIdentifier ()
  {
  }

  void sourceImageInformationType_pskel::
  post_sourceImageInformationType ()
  {
  }

  // fileIdentifierType_pskel
  //

  void fileIdentifierType_pskel::
  fileIdentifierLocation ()
  {
  }

  void fileIdentifierType_pskel::
  post_fileIdentifierType ()
  {
  }

  // ocrProcessingType_pskel
  //

  void ocrProcessingType_pskel::
  preProcessingStep ()
  {
  }

  void ocrProcessingType_pskel::
  ocrProcessingStep ()
  {
  }

  void ocrProcessingType_pskel::
  postProcessingStep ()
  {
  }

  void ocrProcessingType_pskel::
  post_ocrProcessingType ()
  {
  }

  // processingStepType_pskel
  //

  void processingStepType_pskel::
  processingDateTime ()
  {
  }

  void processingStepType_pskel::
  processingAgency (const ::std::string&)
  {
  }

  void processingStepType_pskel::
  processingStepDescription (const ::std::string&)
  {
  }

  void processingStepType_pskel::
  processingStepSettings (const ::std::string&)
  {
  }

  void processingStepType_pskel::
  processingSoftware ()
  {
  }

  void processingStepType_pskel::
  post_processingStepType ()
  {
  }

  // processingSoftwareType_pskel
  //

  void processingSoftwareType_pskel::
  softwareCreator (const ::std::string&)
  {
  }

  void processingSoftwareType_pskel::
  softwareName (const ::std::string&)
  {
  }

  void processingSoftwareType_pskel::
  softwareVersion (const ::std::string&)
  {
  }

  void processingSoftwareType_pskel::
  applicationDescription (const ::std::string&)
  {
  }

  void processingSoftwareType_pskel::
  post_processingSoftwareType ()
  {
  }

  // dateTimeType_pskel
  //

  void dateTimeType_pskel::
  post_dateTimeType ()
  {
  }

  // fontStylesType_base_pskel
  //

  void fontStylesType_base_pskel::
  item ()
  {
  }

  void fontStylesType_base_pskel::
  post_fontStylesType_base ()
  {
  }

  void fontStylesType_base_pskel::
  _xsd_parse_item (const ::xml_schema::ro_string& v)
  {
    if (this->_xsd_item_)
    {
      this->_xsd_item_->pre ();
      this->_xsd_item_->_pre_impl ();
      this->_xsd_item_->_characters (v);
      this->_xsd_item_->_post_impl ();
      this->_xsd_item_->post_fontStylesType_base_item ();
      this->item ();
    }
  }

  // fontStylesType_pskel
  //

  void fontStylesType_pskel::
  post_fontStylesType ()
  {
    post_fontStylesType_base ();
  }

  // ComposedBlockType_pskel
  //

  void ComposedBlockType_pskel::
  TextBlock ()
  {
  }

  void ComposedBlockType_pskel::
  Illustration ()
  {
  }

  void ComposedBlockType_pskel::
  GraphicalElement ()
  {
  }

  void ComposedBlockType_pskel::
  ComposedBlock ()
  {
  }

  void ComposedBlockType_pskel::
  TYPE (const ::std::string&)
  {
  }

  void ComposedBlockType_pskel::
  FILEID (const ::std::string&)
  {
  }

  void ComposedBlockType_pskel::
  post_ComposedBlockType ()
  {
    post_BlockType ();
  }

  // IllustrationType_pskel
  //

  void IllustrationType_pskel::
  TYPE (const ::std::string&)
  {
  }

  void IllustrationType_pskel::
  FILEID (const ::std::string&)
  {
  }

  void IllustrationType_pskel::
  post_IllustrationType ()
  {
    post_BlockType ();
  }

  // GraphicalElementType_pskel
  //

  void GraphicalElementType_pskel::
  post_GraphicalElementType ()
  {
    post_BlockType ();
  }

  // TextBlockType_pskel
  //

  void TextBlockType_pskel::
  TextLine ()
  {
  }

  void TextBlockType_pskel::
  language (const ::std::string&)
  {
  }

  void TextBlockType_pskel::
  post_TextBlockType ()
  {
    post_BlockType ();
  }

  // alto_pskel
  //

  void alto_pskel::
  Description ()
  {
  }

  void alto_pskel::
  Styles ()
  {
  }

  void alto_pskel::
  Layout ()
  {
  }

  void alto_pskel::
  post_alto ()
  {
  }

  // ALTERNATIVE_pskel
  //

  void ALTERNATIVE_pskel::
  PURPOSE (const ::std::string&)
  {
  }

  void ALTERNATIVE_pskel::
  post_ALTERNATIVE ()
  {
  }

  // CONTENT_pskel
  //

  void CONTENT_pskel::
  post_CONTENT ()
  {
  }

  // SUBS_TYPE_pskel
  //

  void SUBS_TYPE_pskel::
  post_SUBS_TYPE ()
  {
  }

  // WC_pskel
  //

  void WC_pskel::
  post_WC ()
  {
  }

  // PC_pskel
  //

  void PC_pskel::
  post_PC ()
  {
  }

  // TextLine_pskel
  //

  void TextLine_pskel::
  String ()
  {
  }

  void TextLine_pskel::
  SP ()
  {
  }

  void TextLine_pskel::
  HYP ()
  {
  }

  void TextLine_pskel::
  ID (const ::std::string&)
  {
  }

  void TextLine_pskel::
  STYLEREFS (const ::xml_schema::string_sequence&)
  {
  }

  void TextLine_pskel::
  HEIGHT (float)
  {
  }

  void TextLine_pskel::
  WIDTH (float)
  {
  }

  void TextLine_pskel::
  HPOS (float)
  {
  }

  void TextLine_pskel::
  VPOS (float)
  {
  }

  void TextLine_pskel::
  BASELINE (float)
  {
  }

  void TextLine_pskel::
  CS (bool)
  {
  }

  void TextLine_pskel::
  post_TextLine ()
  {
  }

  // Description_pskel
  //

  void Description_pskel::
  MeasurementUnit ()
  {
  }

  void Description_pskel::
  sourceImageInformation ()
  {
  }

  void Description_pskel::
  OCRProcessing ()
  {
  }

  void Description_pskel::
  post_Description ()
  {
  }

  // Styles_pskel
  //

  void Styles_pskel::
  TextStyle ()
  {
  }

  void Styles_pskel::
  ParagraphStyle ()
  {
  }

  void Styles_pskel::
  post_Styles ()
  {
  }

  // Layout_pskel
  //

  void Layout_pskel::
  Page ()
  {
  }

  void Layout_pskel::
  STYLEREFS (const ::xml_schema::string_sequence&)
  {
  }

  void Layout_pskel::
  post_Layout ()
  {
  }

  // fontStylesType_base_item_pskel
  //

  void fontStylesType_base_item_pskel::
  post_fontStylesType_base_item ()
  {
  }

  // SP_pskel
  //

  void SP_pskel::
  ID (const ::std::string&)
  {
  }

  void SP_pskel::
  WIDTH (float)
  {
  }

  void SP_pskel::
  HPOS (float)
  {
  }

  void SP_pskel::
  VPOS (float)
  {
  }

  void SP_pskel::
  post_SP ()
  {
  }

  // HYP_pskel
  //

  void HYP_pskel::
  WIDTH (float)
  {
  }

  void HYP_pskel::
  HPOS (float)
  {
  }

  void HYP_pskel::
  VPOS (float)
  {
  }

  void HYP_pskel::
  CONTENT ()
  {
  }

  void HYP_pskel::
  post_HYP ()
  {
  }

  // MeasurementUnit_pskel
  //

  void MeasurementUnit_pskel::
  post_MeasurementUnit ()
  {
  }

  // OCRProcessing_pskel
  //

  void OCRProcessing_pskel::
  ID (const ::std::string&)
  {
  }

  void OCRProcessing_pskel::
  post_OCRProcessing ()
  {
    post_ocrProcessingType ();
  }

  // TextStyle_pskel
  //

  void TextStyle_pskel::
  ID (const ::std::string&)
  {
  }

  void TextStyle_pskel::
  FONTFAMILY (const ::std::string&)
  {
  }

  void TextStyle_pskel::
  FONTTYPE ()
  {
  }

  void TextStyle_pskel::
  FONTWIDTH ()
  {
  }

  void TextStyle_pskel::
  FONTSIZE (float)
  {
  }

  void TextStyle_pskel::
  FONTCOLOR (::std::auto_ptr< ::xml_schema::buffer >)
  {
  }

  void TextStyle_pskel::
  FONTSTYLE ()
  {
  }

  void TextStyle_pskel::
  post_TextStyle ()
  {
  }

  // ParagraphStyle_pskel
  //

  void ParagraphStyle_pskel::
  ID (const ::std::string&)
  {
  }

  void ParagraphStyle_pskel::
  ALIGN ()
  {
  }

  void ParagraphStyle_pskel::
  LEFT (float)
  {
  }

  void ParagraphStyle_pskel::
  RIGHT (float)
  {
  }

  void ParagraphStyle_pskel::
  LINESPACE (float)
  {
  }

  void ParagraphStyle_pskel::
  FIRSTLINE (float)
  {
  }

  void ParagraphStyle_pskel::
  post_ParagraphStyle ()
  {
  }

  // Page_pskel
  //

  void Page_pskel::
  TopMargin ()
  {
  }

  void Page_pskel::
  LeftMargin ()
  {
  }

  void Page_pskel::
  RightMargin ()
  {
  }

  void Page_pskel::
  BottomMargin ()
  {
  }

  void Page_pskel::
  PrintSpace ()
  {
  }

  void Page_pskel::
  ID (const ::std::string&)
  {
  }

  void Page_pskel::
  PAGECLASS (const ::std::string&)
  {
  }

  void Page_pskel::
  STYLEREFS (const ::xml_schema::string_sequence&)
  {
  }

  void Page_pskel::
  HEIGHT (int)
  {
  }

  void Page_pskel::
  WIDTH (int)
  {
  }

  void Page_pskel::
  PHYSICAL_IMG_NR (int)
  {
  }

  void Page_pskel::
  PRINTED_IMG_NR (const ::std::string&)
  {
  }

  void Page_pskel::
  QUALITY ()
  {
  }

  void Page_pskel::
  POSITION ()
  {
  }

  void Page_pskel::
  PROCESSING (const ::std::string&)
  {
  }

  void Page_pskel::
  ACCURACY (float)
  {
  }

  void Page_pskel::
  PC ()
  {
  }

  void Page_pskel::
  post_Page ()
  {
  }

  // ALIGN_pskel
  //

  void ALIGN_pskel::
  post_ALIGN ()
  {
  }

  // QUALITY_pskel
  //

  void QUALITY_pskel::
  post_QUALITY ()
  {
  }

  // POSITION_pskel
  //

  void POSITION_pskel::
  post_POSITION ()
  {
  }

  // PC1_pskel
  //

  void PC1_pskel::
  post_PC1 ()
  {
  }
}

#include <cassert>

namespace ALTO
{
  // Element validation and dispatch functions for BlockType_pskel.
  //
  bool BlockType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Shape" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &BlockType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool BlockType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void BlockType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void BlockType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void BlockType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Shape" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Shape_parser_;

            if (this->Shape_parser_)
              this->Shape_parser_->pre ();
          }
          else
          {
            if (this->Shape_parser_)
            {
              this->Shape_parser_->post_ShapeType ();
              this->Shape ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "Shape",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for StringType_pskel.
  //
  bool StringType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ALTERNATIVE" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &StringType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool StringType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void StringType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void StringType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void StringType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ALTERNATIVE" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ALTERNATIVE_parser_;

            if (this->ALTERNATIVE_parser_)
              this->ALTERNATIVE_parser_->pre ();
          }
          else
          {
            if (this->ALTERNATIVE_parser_)
            {
              this->ALTERNATIVE_parser_->post_ALTERNATIVE ();
              this->ALTERNATIVE ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "ALTERNATIVE",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PageSpaceType_pskel.
  //
  bool PageSpaceType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "TextBlock" &&
             ns == "http://schema.ccs-gmbh.com/ALTO") ||
            (n == "Illustration" &&
             ns == "http://schema.ccs-gmbh.com/ALTO") ||
            (n == "GraphicalElement" &&
             ns == "http://schema.ccs-gmbh.com/ALTO") ||
            (n == "ComposedBlock" &&
             ns == "http://schema.ccs-gmbh.com/ALTO"))
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &PageSpaceType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PageSpaceType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PageSpaceType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void PageSpaceType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PageSpaceType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s (~0UL);

        if (n == "TextBlock" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "Illustration" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "GraphicalElement" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;
        else if (n == "ComposedBlock" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          count = 0;
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &PageSpaceType_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice_0 (vd.state, vd.count, ns, n, t, true);
          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "TextBlock",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  void PageSpaceType_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TextBlock_parser_;

          if (this->TextBlock_parser_)
            this->TextBlock_parser_->pre ();
        }
        else
        {
          if (this->TextBlock_parser_)
          {
            this->TextBlock_parser_->post_TextBlockType ();
            this->TextBlock ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->Illustration_parser_;

          if (this->Illustration_parser_)
            this->Illustration_parser_->pre ();
        }
        else
        {
          if (this->Illustration_parser_)
          {
            this->Illustration_parser_->post_IllustrationType ();
            this->Illustration ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->GraphicalElement_parser_;

          if (this->GraphicalElement_parser_)
            this->GraphicalElement_parser_->pre ();
        }
        else
        {
          if (this->GraphicalElement_parser_)
          {
            this->GraphicalElement_parser_->post_GraphicalElementType ();
            this->GraphicalElement ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ComposedBlock_parser_;

          if (this->ComposedBlock_parser_)
            this->ComposedBlock_parser_->pre ();
        }
        else
        {
          if (this->ComposedBlock_parser_)
          {
            this->ComposedBlock_parser_->post_ComposedBlockType ();
            this->ComposedBlock ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for ShapeType_pskel.
  //
  bool ShapeType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Polygon" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "Ellipse" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "Circle" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ShapeType_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "Polygon",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ShapeType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ShapeType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ShapeType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://schema.ccs-gmbh.com/ALTO", "Polygon");

    this->v_state_stack_.pop ();
  }

  void ShapeType_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->Polygon_parser_;

          if (this->Polygon_parser_)
            this->Polygon_parser_->pre ();
        }
        else
        {
          if (this->Polygon_parser_)
          {
            this->Polygon_parser_->post_PolygonType ();
            this->Polygon ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->Ellipse_parser_;

          if (this->Ellipse_parser_)
            this->Ellipse_parser_->pre ();
        }
        else
        {
          if (this->Ellipse_parser_)
          {
            this->Ellipse_parser_->post_EllipseType ();
            this->Ellipse ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->Circle_parser_;

          if (this->Circle_parser_)
            this->Circle_parser_->pre ();
        }
        else
        {
          if (this->Circle_parser_)
          {
            this->Circle_parser_->post_CircleType ();
            this->Circle ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for sourceImageInformationType_pskel.
  //
  bool sourceImageInformationType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "fileName" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "fileIdentifier" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &sourceImageInformationType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool sourceImageInformationType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void sourceImageInformationType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void sourceImageInformationType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void sourceImageInformationType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "fileName" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->fileName_parser_;

            if (this->fileName_parser_)
              this->fileName_parser_->pre ();
          }
          else
          {
            if (this->fileName_parser_)
            {
              const ::std::string& tmp (this->fileName_parser_->post_string ());
              this->fileName (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "fileIdentifier" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->fileIdentifier_parser_;

            if (this->fileIdentifier_parser_)
              this->fileIdentifier_parser_->pre ();
          }
          else
          {
            if (this->fileIdentifier_parser_)
            {
              this->fileIdentifier_parser_->post_fileIdentifierType ();
              this->fileIdentifier ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ocrProcessingType_pskel.
  //
  bool ocrProcessingType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "preProcessingStep" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "ocrProcessingStep" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ocrProcessingType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "preProcessingStep",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ocrProcessingType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ocrProcessingType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ocrProcessingType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://schema.ccs-gmbh.com/ALTO", "preProcessingStep");

    this->v_state_stack_.pop ();
  }

  void ocrProcessingType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "preProcessingStep" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->preProcessingStep_parser_;

            if (this->preProcessingStep_parser_)
              this->preProcessingStep_parser_->pre ();
          }
          else
          {
            if (this->preProcessingStep_parser_)
            {
              this->preProcessingStep_parser_->post_processingStepType ();
              this->preProcessingStep ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ocrProcessingStep" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ocrProcessingStep_parser_;

            if (this->ocrProcessingStep_parser_)
              this->ocrProcessingStep_parser_->pre ();
          }
          else
          {
            if (this->ocrProcessingStep_parser_)
            {
              this->ocrProcessingStep_parser_->post_processingStepType ();
              this->ocrProcessingStep ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "ocrProcessingStep",
              ns, n);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "postProcessingStep" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->postProcessingStep_parser_;

            if (this->postProcessingStep_parser_)
              this->postProcessingStep_parser_->pre ();
          }
          else
          {
            if (this->postProcessingStep_parser_)
            {
              this->postProcessingStep_parser_->post_processingStepType ();
              this->postProcessingStep ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for processingStepType_pskel.
  //
  bool processingStepType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "processingDateTime" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "processingAgency" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "processingStepDescription" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;
        else if (n == "processingStepSettings" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 3UL;
        else if (n == "processingSoftware" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &processingStepType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool processingStepType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void processingStepType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void processingStepType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void processingStepType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "processingDateTime" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->processingDateTime_parser_;

            if (this->processingDateTime_parser_)
              this->processingDateTime_parser_->pre ();
          }
          else
          {
            if (this->processingDateTime_parser_)
            {
              this->processingDateTime_parser_->post_dateTimeType ();
              this->processingDateTime ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "processingAgency" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->processingAgency_parser_;

            if (this->processingAgency_parser_)
              this->processingAgency_parser_->pre ();
          }
          else
          {
            if (this->processingAgency_parser_)
            {
              const ::std::string& tmp (this->processingAgency_parser_->post_string ());
              this->processingAgency (tmp);
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "processingStepDescription" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->processingStepDescription_parser_;

            if (this->processingStepDescription_parser_)
              this->processingStepDescription_parser_->pre ();
          }
          else
          {
            if (this->processingStepDescription_parser_)
            {
              const ::std::string& tmp (this->processingStepDescription_parser_->post_string ());
              this->processingStepDescription (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "processingStepSettings" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->processingStepSettings_parser_;

            if (this->processingStepSettings_parser_)
              this->processingStepSettings_parser_->pre ();
          }
          else
          {
            if (this->processingStepSettings_parser_)
            {
              const ::std::string& tmp (this->processingStepSettings_parser_->post_string ());
              this->processingStepSettings (tmp);
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "processingSoftware" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->processingSoftware_parser_;

            if (this->processingSoftware_parser_)
              this->processingSoftware_parser_->pre ();
          }
          else
          {
            if (this->processingSoftware_parser_)
            {
              this->processingSoftware_parser_->post_processingSoftwareType ();
              this->processingSoftware ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for processingSoftwareType_pskel.
  //
  bool processingSoftwareType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "softwareCreator" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "softwareName" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "softwareVersion" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;
        else if (n == "applicationDescription" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &processingSoftwareType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool processingSoftwareType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void processingSoftwareType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void processingSoftwareType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void processingSoftwareType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "softwareCreator" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->softwareCreator_parser_;

            if (this->softwareCreator_parser_)
              this->softwareCreator_parser_->pre ();
          }
          else
          {
            if (this->softwareCreator_parser_)
            {
              const ::std::string& tmp (this->softwareCreator_parser_->post_string ());
              this->softwareCreator (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "softwareName" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->softwareName_parser_;

            if (this->softwareName_parser_)
              this->softwareName_parser_->pre ();
          }
          else
          {
            if (this->softwareName_parser_)
            {
              const ::std::string& tmp (this->softwareName_parser_->post_string ());
              this->softwareName (tmp);
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "softwareVersion" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->softwareVersion_parser_;

            if (this->softwareVersion_parser_)
              this->softwareVersion_parser_->pre ();
          }
          else
          {
            if (this->softwareVersion_parser_)
            {
              const ::std::string& tmp (this->softwareVersion_parser_->post_string ());
              this->softwareVersion (tmp);
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "applicationDescription" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->applicationDescription_parser_;

            if (this->applicationDescription_parser_)
              this->applicationDescription_parser_->pre ();
          }
          else
          {
            if (this->applicationDescription_parser_)
            {
              const ::std::string& tmp (this->applicationDescription_parser_->post_string ());
              this->applicationDescription (tmp);
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ComposedBlockType_pskel.
  //
  bool ComposedBlockType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::ALTO::BlockType_pskel::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "TextBlock" &&
             ns == "http://schema.ccs-gmbh.com/ALTO") ||
            (n == "Illustration" &&
             ns == "http://schema.ccs-gmbh.com/ALTO") ||
            (n == "GraphicalElement" &&
             ns == "http://schema.ccs-gmbh.com/ALTO") ||
            (n == "ComposedBlock" &&
             ns == "http://schema.ccs-gmbh.com/ALTO"))
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &ComposedBlockType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ComposedBlockType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::ALTO::BlockType_pskel::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ComposedBlockType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;

    ::ALTO::BlockType_pskel::_pre_e_validate ();
  }

  void ComposedBlockType_pskel::
  _post_e_validate ()
  {
    ::ALTO::BlockType_pskel::_post_e_validate ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ComposedBlockType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s (~0UL);

        if (n == "TextBlock" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "Illustration" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "GraphicalElement" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;
        else if (n == "ComposedBlock" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          count = 0;
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &ComposedBlockType_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice_0 (vd.state, vd.count, ns, n, t, true);
          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "TextBlock",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  void ComposedBlockType_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->TextBlock_parser_;

          if (this->TextBlock_parser_)
            this->TextBlock_parser_->pre ();
        }
        else
        {
          if (this->TextBlock_parser_)
          {
            this->TextBlock_parser_->post_TextBlockType ();
            this->TextBlock ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->Illustration_parser_;

          if (this->Illustration_parser_)
            this->Illustration_parser_->pre ();
        }
        else
        {
          if (this->Illustration_parser_)
          {
            this->Illustration_parser_->post_IllustrationType ();
            this->Illustration ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->GraphicalElement_parser_;

          if (this->GraphicalElement_parser_)
            this->GraphicalElement_parser_->pre ();
        }
        else
        {
          if (this->GraphicalElement_parser_)
          {
            this->GraphicalElement_parser_->post_GraphicalElementType ();
            this->GraphicalElement ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ComposedBlock_parser_;

          if (this->ComposedBlock_parser_)
            this->ComposedBlock_parser_->pre ();
        }
        else
        {
          if (this->ComposedBlock_parser_)
          {
            this->ComposedBlock_parser_->post_ComposedBlockType ();
            this->ComposedBlock ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for TextBlockType_pskel.
  //
  bool TextBlockType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::ALTO::BlockType_pskel::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "TextLine" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TextBlockType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TextBlockType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::ALTO::BlockType_pskel::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TextBlockType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;

    ::ALTO::BlockType_pskel::_pre_e_validate ();
  }

  void TextBlockType_pskel::
  _post_e_validate ()
  {
    ::ALTO::BlockType_pskel::_post_e_validate ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void TextBlockType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "TextLine" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TextLine_parser_;

            if (this->TextLine_parser_)
              this->TextLine_parser_->pre ();
          }
          else
          {
            if (this->TextLine_parser_)
            {
              this->TextLine_parser_->post_TextLine ();
              this->TextLine ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "TextLine",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for alto_pskel.
  //
  bool alto_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Description" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "Styles" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "Layout" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &alto_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "Description",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool alto_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void alto_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void alto_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://schema.ccs-gmbh.com/ALTO", "Description");

    this->v_state_stack_.pop ();
  }

  void alto_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Description" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Description_parser_;

            if (this->Description_parser_)
              this->Description_parser_->pre ();
          }
          else
          {
            if (this->Description_parser_)
            {
              this->Description_parser_->post_Description ();
              this->Description ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "Styles" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Styles_parser_;

            if (this->Styles_parser_)
              this->Styles_parser_->pre ();
          }
          else
          {
            if (this->Styles_parser_)
            {
              this->Styles_parser_->post_Styles ();
              this->Styles ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "Layout" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Layout_parser_;

            if (this->Layout_parser_)
              this->Layout_parser_->pre ();
          }
          else
          {
            if (this->Layout_parser_)
            {
              this->Layout_parser_->post_Layout ();
              this->Layout ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "Layout",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TextLine_pskel.
  //
  bool TextLine_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "String" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TextLine_pskel::sequence_1;
          vd->state = s;
          vd->count = 0;

          this->sequence_1 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "String",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TextLine_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TextLine_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void TextLine_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://schema.ccs-gmbh.com/ALTO", "String");

    this->v_state_stack_.pop ();
  }

  void TextLine_pskel::
  sequence_1 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s (~0UL);

        if (n == "String" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;

        if (s != ~0UL)
        {
          assert (start);
          count++;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &TextLine_pskel::sequence_0;
          vd.state = s;
          vd.count = 0;

          this->sequence_0 (vd.state, vd.count, ns, n, t, true);
          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "String",
              ns, n);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "HYP" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->HYP_parser_;

            if (this->HYP_parser_)
              this->HYP_parser_->pre ();
          }
          else
          {
            if (this->HYP_parser_)
            {
              this->HYP_parser_->post_HYP ();
              this->HYP ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  void TextLine_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "String" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->String_parser_;

            if (this->String_parser_)
              this->String_parser_->pre ();
          }
          else
          {
            if (this->String_parser_)
            {
              this->String_parser_->post_StringType ();
              this->String ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "String",
              ns, n);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "SP" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SP_parser_;

            if (this->SP_parser_)
              this->SP_parser_->pre ();
          }
          else
          {
            if (this->SP_parser_)
            {
              this->SP_parser_->post_SP ();
              this->SP ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Description_pskel.
  //
  bool Description_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "MeasurementUnit" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "sourceImageInformation" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "OCRProcessing" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Description_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Description_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Description_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Description_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Description_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "MeasurementUnit" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->MeasurementUnit_parser_;

            if (this->MeasurementUnit_parser_)
              this->MeasurementUnit_parser_->pre ();
          }
          else
          {
            if (this->MeasurementUnit_parser_)
            {
              this->MeasurementUnit_parser_->post_MeasurementUnit ();
              this->MeasurementUnit ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "sourceImageInformation" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->sourceImageInformation_parser_;

            if (this->sourceImageInformation_parser_)
              this->sourceImageInformation_parser_->pre ();
          }
          else
          {
            if (this->sourceImageInformation_parser_)
            {
              this->sourceImageInformation_parser_->post_sourceImageInformationType ();
              this->sourceImageInformation ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "OCRProcessing" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->OCRProcessing_parser_;

            if (this->OCRProcessing_parser_)
              this->OCRProcessing_parser_->pre ();
          }
          else
          {
            if (this->OCRProcessing_parser_)
            {
              this->OCRProcessing_parser_->post_OCRProcessing ();
              this->OCRProcessing ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Styles_pskel.
  //
  bool Styles_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "TextStyle" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "ParagraphStyle" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Styles_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Styles_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Styles_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Styles_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Styles_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "TextStyle" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TextStyle_parser_;

            if (this->TextStyle_parser_)
              this->TextStyle_parser_->pre ();
          }
          else
          {
            if (this->TextStyle_parser_)
            {
              this->TextStyle_parser_->post_TextStyle ();
              this->TextStyle ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ParagraphStyle" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ParagraphStyle_parser_;

            if (this->ParagraphStyle_parser_)
              this->ParagraphStyle_parser_->pre ();
          }
          else
          {
            if (this->ParagraphStyle_parser_)
            {
              this->ParagraphStyle_parser_->post_ParagraphStyle ();
              this->ParagraphStyle ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Layout_pskel.
  //
  bool Layout_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Page" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Layout_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "Page",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Layout_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Layout_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Layout_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://schema.ccs-gmbh.com/ALTO", "Page");

    this->v_state_stack_.pop ();
  }

  void Layout_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Page" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Page_parser_;

            if (this->Page_parser_)
              this->Page_parser_->pre ();
          }
          else
          {
            if (this->Page_parser_)
            {
              this->Page_parser_->post_Page ();
              this->Page ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://schema.ccs-gmbh.com/ALTO", "Page",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Page_pskel.
  //
  bool Page_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "TopMargin" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 0UL;
        else if (n == "LeftMargin" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 1UL;
        else if (n == "RightMargin" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 2UL;
        else if (n == "BottomMargin" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 3UL;
        else if (n == "PrintSpace" &&
                 ns == "http://schema.ccs-gmbh.com/ALTO")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Page_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Page_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Page_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Page_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Page_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "TopMargin" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TopMargin_parser_;

            if (this->TopMargin_parser_)
              this->TopMargin_parser_->pre ();
          }
          else
          {
            if (this->TopMargin_parser_)
            {
              this->TopMargin_parser_->post_PageSpaceType ();
              this->TopMargin ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "LeftMargin" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->LeftMargin_parser_;

            if (this->LeftMargin_parser_)
              this->LeftMargin_parser_->pre ();
          }
          else
          {
            if (this->LeftMargin_parser_)
            {
              this->LeftMargin_parser_->post_PageSpaceType ();
              this->LeftMargin ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "RightMargin" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->RightMargin_parser_;

            if (this->RightMargin_parser_)
              this->RightMargin_parser_->pre ();
          }
          else
          {
            if (this->RightMargin_parser_)
            {
              this->RightMargin_parser_->post_PageSpaceType ();
              this->RightMargin ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "BottomMargin" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->BottomMargin_parser_;

            if (this->BottomMargin_parser_)
              this->BottomMargin_parser_->pre ();
          }
          else
          {
            if (this->BottomMargin_parser_)
            {
              this->BottomMargin_parser_->post_PageSpaceType ();
              this->BottomMargin ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "PrintSpace" &&
            ns == "http://schema.ccs-gmbh.com/ALTO")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrintSpace_parser_;

            if (this->PrintSpace_parser_)
              this->PrintSpace_parser_->pre ();
          }
          else
          {
            if (this->PrintSpace_parser_)
            {
              this->PrintSpace_parser_->post_PageSpaceType ();
              this->PrintSpace ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace ALTO
{
  // Attribute validation and dispatch functions for BlockType_pskel.
  //
  bool BlockType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    if (n == "STYLEREFS" && ns.empty ())
    {
      if (this->STYLEREFS_parser_)
      {
        this->STYLEREFS_parser_->pre ();
        this->STYLEREFS_parser_->_pre_impl ();
        this->STYLEREFS_parser_->_characters (s);
        this->STYLEREFS_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STYLEREFS_parser_->post_idrefs ());
        this->STYLEREFS (tmp);
      }

      return true;
    }

    if (n == "HEIGHT" && ns.empty ())
    {
      if (this->HEIGHT_parser_)
      {
        this->HEIGHT_parser_->pre ();
        this->HEIGHT_parser_->_pre_impl ();
        this->HEIGHT_parser_->_characters (s);
        this->HEIGHT_parser_->_post_impl ();
        int tmp (this->HEIGHT_parser_->post_int ());
        this->HEIGHT (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->HEIGHT = true;
      return true;
    }

    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        int tmp (this->WIDTH_parser_->post_int ());
        this->WIDTH (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->WIDTH = true;
      return true;
    }

    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        int tmp (this->HPOS_parser_->post_int ());
        this->HPOS (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->HPOS = true;
      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        int tmp (this->VPOS_parser_->post_int ());
        this->VPOS (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->VPOS = true;
      return true;
    }

    if (n == "ROTATION" && ns.empty ())
    {
      if (this->ROTATION_parser_)
      {
        this->ROTATION_parser_->pre ();
        this->ROTATION_parser_->_pre_impl ();
        this->ROTATION_parser_->_characters (s);
        this->ROTATION_parser_->_post_impl ();
        float tmp (this->ROTATION_parser_->post_float ());
        this->ROTATION (tmp);
      }

      return true;
    }

    if (n == "IDNEXT" && ns.empty ())
    {
      if (this->IDNEXT_parser_)
      {
        this->IDNEXT_parser_->pre ();
        this->IDNEXT_parser_->_pre_impl ();
        this->IDNEXT_parser_->_characters (s);
        this->IDNEXT_parser_->_post_impl ();
        const ::std::string& tmp (this->IDNEXT_parser_->post_idref ());
        this->IDNEXT (tmp);
      }

      return true;
    }

    if (n == "type" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_string ());
        this->type (tmp);
      }

      return true;
    }

    if (n == "href" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();
        this->href_parser_->_pre_impl ();
        this->href_parser_->_characters (s);
        this->href_parser_->_post_impl ();
        const ::std::string& tmp (this->href_parser_->post_uri ());
        this->href (tmp);
      }

      return true;
    }

    if (n == "role" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->role_parser_)
      {
        this->role_parser_->pre ();
        this->role_parser_->_pre_impl ();
        this->role_parser_->_characters (s);
        this->role_parser_->_post_impl ();
        const ::std::string& tmp (this->role_parser_->post_string ());
        this->role (tmp);
      }

      return true;
    }

    if (n == "arcrole" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->arcrole_parser_)
      {
        this->arcrole_parser_->pre ();
        this->arcrole_parser_->_pre_impl ();
        this->arcrole_parser_->_characters (s);
        this->arcrole_parser_->_post_impl ();
        const ::std::string& tmp (this->arcrole_parser_->post_string ());
        this->arcrole (tmp);
      }

      return true;
    }

    if (n == "title" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "show" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->show_parser_)
      {
        this->show_parser_->pre ();
        this->show_parser_->_pre_impl ();
        this->show_parser_->_characters (s);
        this->show_parser_->_post_impl ();
        this->show_parser_->post_show ();
        this->show ();
      }

      return true;
    }

    if (n == "actuate" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->actuate_parser_)
      {
        this->actuate_parser_->pre ();
        this->actuate_parser_->_pre_impl ();
        this->actuate_parser_->_characters (s);
        this->actuate_parser_->_post_impl ();
        this->actuate_parser_->post_actuate ();
        this->actuate ();
      }

      return true;
    }

    return false;
  }

  void BlockType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
    as.HEIGHT = false;
    as.WIDTH = false;
    as.HPOS = false;
    as.VPOS = false;
  }

  void BlockType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");
    if (!as.HEIGHT)
      this->_expected_attribute (
        "", "HEIGHT");
    if (!as.WIDTH)
      this->_expected_attribute (
        "", "WIDTH");
    if (!as.HPOS)
      this->_expected_attribute (
        "", "HPOS");
    if (!as.VPOS)
      this->_expected_attribute (
        "", "VPOS");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for StringType_pskel.
  //
  bool StringType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "STYLEREFS" && ns.empty ())
    {
      if (this->STYLEREFS_parser_)
      {
        this->STYLEREFS_parser_->pre ();
        this->STYLEREFS_parser_->_pre_impl ();
        this->STYLEREFS_parser_->_characters (s);
        this->STYLEREFS_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STYLEREFS_parser_->post_idrefs ());
        this->STYLEREFS (tmp);
      }

      return true;
    }

    if (n == "HEIGHT" && ns.empty ())
    {
      if (this->HEIGHT_parser_)
      {
        this->HEIGHT_parser_->pre ();
        this->HEIGHT_parser_->_pre_impl ();
        this->HEIGHT_parser_->_characters (s);
        this->HEIGHT_parser_->_post_impl ();
        float tmp (this->HEIGHT_parser_->post_float ());
        this->HEIGHT (tmp);
      }

      return true;
    }

    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        float tmp (this->WIDTH_parser_->post_float ());
        this->WIDTH (tmp);
      }

      return true;
    }

    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        float tmp (this->HPOS_parser_->post_float ());
        this->HPOS (tmp);
      }

      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        float tmp (this->VPOS_parser_->post_float ());
        this->VPOS (tmp);
      }

      return true;
    }

    if (n == "CONTENT" && ns.empty ())
    {
      if (this->CONTENT_parser_)
      {
        this->CONTENT_parser_->pre ();
        this->CONTENT_parser_->_pre_impl ();
        this->CONTENT_parser_->_characters (s);
        this->CONTENT_parser_->_post_impl ();
        this->CONTENT_parser_->post_CONTENT ();
        this->CONTENT ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->CONTENT = true;
      return true;
    }

    if (n == "STYLE" && ns.empty ())
    {
      if (this->STYLE_parser_)
      {
        this->STYLE_parser_->pre ();
        this->STYLE_parser_->_pre_impl ();
        this->STYLE_parser_->_characters (s);
        this->STYLE_parser_->_post_impl ();
        this->STYLE_parser_->post_fontStylesType ();
        this->STYLE ();
      }

      return true;
    }

    if (n == "SUBS_TYPE" && ns.empty ())
    {
      if (this->SUBS_TYPE_parser_)
      {
        this->SUBS_TYPE_parser_->pre ();
        this->SUBS_TYPE_parser_->_pre_impl ();
        this->SUBS_TYPE_parser_->_characters (s);
        this->SUBS_TYPE_parser_->_post_impl ();
        this->SUBS_TYPE_parser_->post_SUBS_TYPE ();
        this->SUBS_TYPE ();
      }

      return true;
    }

    if (n == "SUBS_CONTENT" && ns.empty ())
    {
      if (this->SUBS_CONTENT_parser_)
      {
        this->SUBS_CONTENT_parser_->pre ();
        this->SUBS_CONTENT_parser_->_pre_impl ();
        this->SUBS_CONTENT_parser_->_characters (s);
        this->SUBS_CONTENT_parser_->_post_impl ();
        const ::std::string& tmp (this->SUBS_CONTENT_parser_->post_string ());
        this->SUBS_CONTENT (tmp);
      }

      return true;
    }

    if (n == "WC" && ns.empty ())
    {
      if (this->WC_parser_)
      {
        this->WC_parser_->pre ();
        this->WC_parser_->_pre_impl ();
        this->WC_parser_->_characters (s);
        this->WC_parser_->_post_impl ();
        this->WC_parser_->post_WC ();
        this->WC ();
      }

      return true;
    }

    if (n == "CC" && ns.empty ())
    {
      if (this->CC_parser_)
      {
        this->CC_parser_->pre ();
        this->CC_parser_->_pre_impl ();
        this->CC_parser_->_characters (s);
        this->CC_parser_->_post_impl ();
        const ::std::string& tmp (this->CC_parser_->post_string ());
        this->CC (tmp);
      }

      return true;
    }

    return false;
  }

  void StringType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.CONTENT = false;
  }

  void StringType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.CONTENT)
      this->_expected_attribute (
        "", "CONTENT");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for PageSpaceType_pskel.
  //
  bool PageSpaceType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "STYLEREFS" && ns.empty ())
    {
      if (this->STYLEREFS_parser_)
      {
        this->STYLEREFS_parser_->pre ();
        this->STYLEREFS_parser_->_pre_impl ();
        this->STYLEREFS_parser_->_characters (s);
        this->STYLEREFS_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STYLEREFS_parser_->post_idrefs ());
        this->STYLEREFS (tmp);
      }

      return true;
    }

    if (n == "HEIGHT" && ns.empty ())
    {
      if (this->HEIGHT_parser_)
      {
        this->HEIGHT_parser_->pre ();
        this->HEIGHT_parser_->_pre_impl ();
        this->HEIGHT_parser_->_characters (s);
        this->HEIGHT_parser_->_post_impl ();
        float tmp (this->HEIGHT_parser_->post_float ());
        this->HEIGHT (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->HEIGHT = true;
      return true;
    }

    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        float tmp (this->WIDTH_parser_->post_float ());
        this->WIDTH (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->WIDTH = true;
      return true;
    }

    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        float tmp (this->HPOS_parser_->post_float ());
        this->HPOS (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->HPOS = true;
      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        float tmp (this->VPOS_parser_->post_float ());
        this->VPOS (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->VPOS = true;
      return true;
    }

    if (n == "PC" && ns.empty ())
    {
      if (this->PC_parser_)
      {
        this->PC_parser_->pre ();
        this->PC_parser_->_pre_impl ();
        this->PC_parser_->_characters (s);
        this->PC_parser_->_post_impl ();
        this->PC_parser_->post_PC ();
        this->PC ();
      }

      return true;
    }

    return false;
  }

  void PageSpaceType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.HEIGHT = false;
    as.WIDTH = false;
    as.HPOS = false;
    as.VPOS = false;
  }

  void PageSpaceType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.HEIGHT)
      this->_expected_attribute (
        "", "HEIGHT");
    if (!as.WIDTH)
      this->_expected_attribute (
        "", "WIDTH");
    if (!as.HPOS)
      this->_expected_attribute (
        "", "HPOS");
    if (!as.VPOS)
      this->_expected_attribute (
        "", "VPOS");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for PolygonType_pskel.
  //
  bool PolygonType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "POINTS" && ns.empty ())
    {
      if (this->POINTS_parser_)
      {
        this->POINTS_parser_->pre ();
        this->POINTS_parser_->_pre_impl ();
        this->POINTS_parser_->_characters (s);
        this->POINTS_parser_->_post_impl ();
        this->POINTS_parser_->post_PointsType ();
        this->POINTS ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->POINTS = true;
      return true;
    }

    return false;
  }

  void PolygonType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.POINTS = false;
  }

  void PolygonType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.POINTS)
      this->_expected_attribute (
        "", "POINTS");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for EllipseType_pskel.
  //
  bool EllipseType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        this->HPOS_parser_->post_any_simple_type ();
        this->HPOS ();
      }

      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        this->VPOS_parser_->post_any_simple_type ();
        this->VPOS ();
      }

      return true;
    }

    if (n == "HLENGTH" && ns.empty ())
    {
      if (this->HLENGTH_parser_)
      {
        this->HLENGTH_parser_->pre ();
        this->HLENGTH_parser_->_pre_impl ();
        this->HLENGTH_parser_->_characters (s);
        this->HLENGTH_parser_->_post_impl ();
        this->HLENGTH_parser_->post_any_simple_type ();
        this->HLENGTH ();
      }

      return true;
    }

    if (n == "VLENGTH" && ns.empty ())
    {
      if (this->VLENGTH_parser_)
      {
        this->VLENGTH_parser_->pre ();
        this->VLENGTH_parser_->_pre_impl ();
        this->VLENGTH_parser_->_characters (s);
        this->VLENGTH_parser_->_post_impl ();
        this->VLENGTH_parser_->post_any_simple_type ();
        this->VLENGTH ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for CircleType_pskel.
  //
  bool CircleType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        this->HPOS_parser_->post_any_simple_type ();
        this->HPOS ();
      }

      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        this->VPOS_parser_->post_any_simple_type ();
        this->VPOS ();
      }

      return true;
    }

    if (n == "RADIUS" && ns.empty ())
    {
      if (this->RADIUS_parser_)
      {
        this->RADIUS_parser_->pre ();
        this->RADIUS_parser_->_pre_impl ();
        this->RADIUS_parser_->_characters (s);
        this->RADIUS_parser_->_post_impl ();
        this->RADIUS_parser_->post_any_simple_type ();
        this->RADIUS ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for fileIdentifierType_pskel.
  //
  bool fileIdentifierType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "fileIdentifierLocation" && ns.empty ())
    {
      if (this->fileIdentifierLocation_parser_)
      {
        this->fileIdentifierLocation_parser_->pre ();
        this->fileIdentifierLocation_parser_->_pre_impl ();
        this->fileIdentifierLocation_parser_->_characters (s);
        this->fileIdentifierLocation_parser_->_post_impl ();
        this->fileIdentifierLocation_parser_->post_any_simple_type ();
        this->fileIdentifierLocation ();
      }

      return true;
    }

    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ComposedBlockType_pskel.
  //
  bool ComposedBlockType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->TYPE_parser_->post_string ());
        this->TYPE (tmp);
      }

      return true;
    }

    if (n == "FILEID" && ns.empty ())
    {
      if (this->FILEID_parser_)
      {
        this->FILEID_parser_->pre ();
        this->FILEID_parser_->_pre_impl ();
        this->FILEID_parser_->_characters (s);
        this->FILEID_parser_->_post_impl ();
        const ::std::string& tmp (this->FILEID_parser_->post_string ());
        this->FILEID (tmp);
      }

      return true;
    }

    return this->::ALTO::BlockType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for IllustrationType_pskel.
  //
  bool IllustrationType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->TYPE_parser_->post_string ());
        this->TYPE (tmp);
      }

      return true;
    }

    if (n == "FILEID" && ns.empty ())
    {
      if (this->FILEID_parser_)
      {
        this->FILEID_parser_->pre ();
        this->FILEID_parser_->_pre_impl ();
        this->FILEID_parser_->_characters (s);
        this->FILEID_parser_->_post_impl ();
        const ::std::string& tmp (this->FILEID_parser_->post_string ());
        this->FILEID (tmp);
      }

      return true;
    }

    return this->::ALTO::BlockType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for TextBlockType_pskel.
  //
  bool TextBlockType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "language" && ns.empty ())
    {
      if (this->language_parser_)
      {
        this->language_parser_->pre ();
        this->language_parser_->_pre_impl ();
        this->language_parser_->_characters (s);
        this->language_parser_->_post_impl ();
        const ::std::string& tmp (this->language_parser_->post_language ());
        this->language (tmp);
      }

      return true;
    }

    return this->::ALTO::BlockType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ALTERNATIVE_pskel.
  //
  bool ALTERNATIVE_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "PURPOSE" && ns.empty ())
    {
      if (this->PURPOSE_parser_)
      {
        this->PURPOSE_parser_->pre ();
        this->PURPOSE_parser_->_pre_impl ();
        this->PURPOSE_parser_->_characters (s);
        this->PURPOSE_parser_->_post_impl ();
        const ::std::string& tmp (this->PURPOSE_parser_->post_string ());
        this->PURPOSE (tmp);
      }

      return true;
    }

    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for TextLine_pskel.
  //
  bool TextLine_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "STYLEREFS" && ns.empty ())
    {
      if (this->STYLEREFS_parser_)
      {
        this->STYLEREFS_parser_->pre ();
        this->STYLEREFS_parser_->_pre_impl ();
        this->STYLEREFS_parser_->_characters (s);
        this->STYLEREFS_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STYLEREFS_parser_->post_idrefs ());
        this->STYLEREFS (tmp);
      }

      return true;
    }

    if (n == "HEIGHT" && ns.empty ())
    {
      if (this->HEIGHT_parser_)
      {
        this->HEIGHT_parser_->pre ();
        this->HEIGHT_parser_->_pre_impl ();
        this->HEIGHT_parser_->_characters (s);
        this->HEIGHT_parser_->_post_impl ();
        float tmp (this->HEIGHT_parser_->post_float ());
        this->HEIGHT (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->HEIGHT = true;
      return true;
    }

    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        float tmp (this->WIDTH_parser_->post_float ());
        this->WIDTH (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->WIDTH = true;
      return true;
    }

    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        float tmp (this->HPOS_parser_->post_float ());
        this->HPOS (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->HPOS = true;
      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        float tmp (this->VPOS_parser_->post_float ());
        this->VPOS (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->VPOS = true;
      return true;
    }

    if (n == "BASELINE" && ns.empty ())
    {
      if (this->BASELINE_parser_)
      {
        this->BASELINE_parser_->pre ();
        this->BASELINE_parser_->_pre_impl ();
        this->BASELINE_parser_->_characters (s);
        this->BASELINE_parser_->_post_impl ();
        float tmp (this->BASELINE_parser_->post_float ());
        this->BASELINE (tmp);
      }

      return true;
    }

    if (n == "CS" && ns.empty ())
    {
      if (this->CS_parser_)
      {
        this->CS_parser_->pre ();
        this->CS_parser_->_pre_impl ();
        this->CS_parser_->_characters (s);
        this->CS_parser_->_post_impl ();
        bool tmp (this->CS_parser_->post_boolean ());
        this->CS (tmp);
      }

      return true;
    }

    return false;
  }

  void TextLine_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.HEIGHT = false;
    as.WIDTH = false;
    as.HPOS = false;
    as.VPOS = false;
  }

  void TextLine_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.HEIGHT)
      this->_expected_attribute (
        "", "HEIGHT");
    if (!as.WIDTH)
      this->_expected_attribute (
        "", "WIDTH");
    if (!as.HPOS)
      this->_expected_attribute (
        "", "HPOS");
    if (!as.VPOS)
      this->_expected_attribute (
        "", "VPOS");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Layout_pskel.
  //
  bool Layout_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "STYLEREFS" && ns.empty ())
    {
      if (this->STYLEREFS_parser_)
      {
        this->STYLEREFS_parser_->pre ();
        this->STYLEREFS_parser_->_pre_impl ();
        this->STYLEREFS_parser_->_characters (s);
        this->STYLEREFS_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STYLEREFS_parser_->post_idrefs ());
        this->STYLEREFS (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for SP_pskel.
  //
  bool SP_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        float tmp (this->WIDTH_parser_->post_float ());
        this->WIDTH (tmp);
      }

      return true;
    }

    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        float tmp (this->HPOS_parser_->post_float ());
        this->HPOS (tmp);
      }

      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        float tmp (this->VPOS_parser_->post_float ());
        this->VPOS (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for HYP_pskel.
  //
  bool HYP_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        float tmp (this->WIDTH_parser_->post_float ());
        this->WIDTH (tmp);
      }

      return true;
    }

    if (n == "HPOS" && ns.empty ())
    {
      if (this->HPOS_parser_)
      {
        this->HPOS_parser_->pre ();
        this->HPOS_parser_->_pre_impl ();
        this->HPOS_parser_->_characters (s);
        this->HPOS_parser_->_post_impl ();
        float tmp (this->HPOS_parser_->post_float ());
        this->HPOS (tmp);
      }

      return true;
    }

    if (n == "VPOS" && ns.empty ())
    {
      if (this->VPOS_parser_)
      {
        this->VPOS_parser_->pre ();
        this->VPOS_parser_->_pre_impl ();
        this->VPOS_parser_->_characters (s);
        this->VPOS_parser_->_post_impl ();
        float tmp (this->VPOS_parser_->post_float ());
        this->VPOS (tmp);
      }

      return true;
    }

    if (n == "CONTENT" && ns.empty ())
    {
      if (this->CONTENT_parser_)
      {
        this->CONTENT_parser_->pre ();
        this->CONTENT_parser_->_pre_impl ();
        this->CONTENT_parser_->_characters (s);
        this->CONTENT_parser_->_post_impl ();
        this->CONTENT_parser_->post_any_simple_type ();
        this->CONTENT ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->CONTENT = true;
      return true;
    }

    return false;
  }

  void HYP_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.CONTENT = false;
  }

  void HYP_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.CONTENT)
      this->_expected_attribute (
        "", "CONTENT");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for OCRProcessing_pskel.
  //
  bool OCRProcessing_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    return this->::ALTO::ocrProcessingType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  void OCRProcessing_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
    this->::ALTO::ocrProcessingType_pskel::_pre_a_validate ();
  }

  void OCRProcessing_pskel::
  _post_a_validate ()
  {
    this->::ALTO::ocrProcessingType_pskel::_post_a_validate ();

    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for TextStyle_pskel.
  //
  bool TextStyle_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "FONTFAMILY" && ns.empty ())
    {
      if (this->FONTFAMILY_parser_)
      {
        this->FONTFAMILY_parser_->pre ();
        this->FONTFAMILY_parser_->_pre_impl ();
        this->FONTFAMILY_parser_->_characters (s);
        this->FONTFAMILY_parser_->_post_impl ();
        const ::std::string& tmp (this->FONTFAMILY_parser_->post_string ());
        this->FONTFAMILY (tmp);
      }

      return true;
    }

    if (n == "FONTTYPE" && ns.empty ())
    {
      if (this->FONTTYPE_parser_)
      {
        this->FONTTYPE_parser_->pre ();
        this->FONTTYPE_parser_->_pre_impl ();
        this->FONTTYPE_parser_->_characters (s);
        this->FONTTYPE_parser_->_post_impl ();
        this->FONTTYPE_parser_->post_fontTypeType ();
        this->FONTTYPE ();
      }

      return true;
    }

    if (n == "FONTWIDTH" && ns.empty ())
    {
      if (this->FONTWIDTH_parser_)
      {
        this->FONTWIDTH_parser_->pre ();
        this->FONTWIDTH_parser_->_pre_impl ();
        this->FONTWIDTH_parser_->_characters (s);
        this->FONTWIDTH_parser_->_post_impl ();
        this->FONTWIDTH_parser_->post_fontWidthType ();
        this->FONTWIDTH ();
      }

      return true;
    }

    if (n == "FONTSIZE" && ns.empty ())
    {
      if (this->FONTSIZE_parser_)
      {
        this->FONTSIZE_parser_->pre ();
        this->FONTSIZE_parser_->_pre_impl ();
        this->FONTSIZE_parser_->_characters (s);
        this->FONTSIZE_parser_->_post_impl ();
        float tmp (this->FONTSIZE_parser_->post_float ());
        this->FONTSIZE (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->FONTSIZE = true;
      return true;
    }

    if (n == "FONTCOLOR" && ns.empty ())
    {
      if (this->FONTCOLOR_parser_)
      {
        this->FONTCOLOR_parser_->pre ();
        this->FONTCOLOR_parser_->_pre_impl ();
        this->FONTCOLOR_parser_->_characters (s);
        this->FONTCOLOR_parser_->_post_impl ();
        ::std::auto_ptr< ::xml_schema::buffer > tmp (this->FONTCOLOR_parser_->post_hex_binary ());
        this->FONTCOLOR (tmp);
      }

      return true;
    }

    if (n == "FONTSTYLE" && ns.empty ())
    {
      if (this->FONTSTYLE_parser_)
      {
        this->FONTSTYLE_parser_->pre ();
        this->FONTSTYLE_parser_->_pre_impl ();
        this->FONTSTYLE_parser_->_characters (s);
        this->FONTSTYLE_parser_->_post_impl ();
        this->FONTSTYLE_parser_->post_fontStylesType ();
        this->FONTSTYLE ();
      }

      return true;
    }

    return false;
  }

  void TextStyle_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.FONTSIZE = false;
  }

  void TextStyle_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.FONTSIZE)
      this->_expected_attribute (
        "", "FONTSIZE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for ParagraphStyle_pskel.
  //
  bool ParagraphStyle_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    if (n == "ALIGN" && ns.empty ())
    {
      if (this->ALIGN_parser_)
      {
        this->ALIGN_parser_->pre ();
        this->ALIGN_parser_->_pre_impl ();
        this->ALIGN_parser_->_characters (s);
        this->ALIGN_parser_->_post_impl ();
        this->ALIGN_parser_->post_ALIGN ();
        this->ALIGN ();
      }

      return true;
    }

    if (n == "LEFT" && ns.empty ())
    {
      if (this->LEFT_parser_)
      {
        this->LEFT_parser_->pre ();
        this->LEFT_parser_->_pre_impl ();
        this->LEFT_parser_->_characters (s);
        this->LEFT_parser_->_post_impl ();
        float tmp (this->LEFT_parser_->post_float ());
        this->LEFT (tmp);
      }

      return true;
    }

    if (n == "RIGHT" && ns.empty ())
    {
      if (this->RIGHT_parser_)
      {
        this->RIGHT_parser_->pre ();
        this->RIGHT_parser_->_pre_impl ();
        this->RIGHT_parser_->_characters (s);
        this->RIGHT_parser_->_post_impl ();
        float tmp (this->RIGHT_parser_->post_float ());
        this->RIGHT (tmp);
      }

      return true;
    }

    if (n == "LINESPACE" && ns.empty ())
    {
      if (this->LINESPACE_parser_)
      {
        this->LINESPACE_parser_->pre ();
        this->LINESPACE_parser_->_pre_impl ();
        this->LINESPACE_parser_->_characters (s);
        this->LINESPACE_parser_->_post_impl ();
        float tmp (this->LINESPACE_parser_->post_float ());
        this->LINESPACE (tmp);
      }

      return true;
    }

    if (n == "FIRSTLINE" && ns.empty ())
    {
      if (this->FIRSTLINE_parser_)
      {
        this->FIRSTLINE_parser_->pre ();
        this->FIRSTLINE_parser_->_pre_impl ();
        this->FIRSTLINE_parser_->_characters (s);
        this->FIRSTLINE_parser_->_post_impl ();
        float tmp (this->FIRSTLINE_parser_->post_float ());
        this->FIRSTLINE (tmp);
      }

      return true;
    }

    return false;
  }

  void ParagraphStyle_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
  }

  void ParagraphStyle_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Page_pskel.
  //
  bool Page_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    if (n == "PAGECLASS" && ns.empty ())
    {
      if (this->PAGECLASS_parser_)
      {
        this->PAGECLASS_parser_->pre ();
        this->PAGECLASS_parser_->_pre_impl ();
        this->PAGECLASS_parser_->_characters (s);
        this->PAGECLASS_parser_->_post_impl ();
        const ::std::string& tmp (this->PAGECLASS_parser_->post_string ());
        this->PAGECLASS (tmp);
      }

      return true;
    }

    if (n == "STYLEREFS" && ns.empty ())
    {
      if (this->STYLEREFS_parser_)
      {
        this->STYLEREFS_parser_->pre ();
        this->STYLEREFS_parser_->_pre_impl ();
        this->STYLEREFS_parser_->_characters (s);
        this->STYLEREFS_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STYLEREFS_parser_->post_idrefs ());
        this->STYLEREFS (tmp);
      }

      return true;
    }

    if (n == "HEIGHT" && ns.empty ())
    {
      if (this->HEIGHT_parser_)
      {
        this->HEIGHT_parser_->pre ();
        this->HEIGHT_parser_->_pre_impl ();
        this->HEIGHT_parser_->_characters (s);
        this->HEIGHT_parser_->_post_impl ();
        int tmp (this->HEIGHT_parser_->post_int ());
        this->HEIGHT (tmp);
      }

      return true;
    }

    if (n == "WIDTH" && ns.empty ())
    {
      if (this->WIDTH_parser_)
      {
        this->WIDTH_parser_->pre ();
        this->WIDTH_parser_->_pre_impl ();
        this->WIDTH_parser_->_characters (s);
        this->WIDTH_parser_->_post_impl ();
        int tmp (this->WIDTH_parser_->post_int ());
        this->WIDTH (tmp);
      }

      return true;
    }

    if (n == "PHYSICAL_IMG_NR" && ns.empty ())
    {
      if (this->PHYSICAL_IMG_NR_parser_)
      {
        this->PHYSICAL_IMG_NR_parser_->pre ();
        this->PHYSICAL_IMG_NR_parser_->_pre_impl ();
        this->PHYSICAL_IMG_NR_parser_->_characters (s);
        this->PHYSICAL_IMG_NR_parser_->_post_impl ();
        int tmp (this->PHYSICAL_IMG_NR_parser_->post_int ());
        this->PHYSICAL_IMG_NR (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->PHYSICAL_IMG_NR = true;
      return true;
    }

    if (n == "PRINTED_IMG_NR" && ns.empty ())
    {
      if (this->PRINTED_IMG_NR_parser_)
      {
        this->PRINTED_IMG_NR_parser_->pre ();
        this->PRINTED_IMG_NR_parser_->_pre_impl ();
        this->PRINTED_IMG_NR_parser_->_characters (s);
        this->PRINTED_IMG_NR_parser_->_post_impl ();
        const ::std::string& tmp (this->PRINTED_IMG_NR_parser_->post_string ());
        this->PRINTED_IMG_NR (tmp);
      }

      return true;
    }

    if (n == "QUALITY" && ns.empty ())
    {
      if (this->QUALITY_parser_)
      {
        this->QUALITY_parser_->pre ();
        this->QUALITY_parser_->_pre_impl ();
        this->QUALITY_parser_->_characters (s);
        this->QUALITY_parser_->_post_impl ();
        this->QUALITY_parser_->post_QUALITY ();
        this->QUALITY ();
      }

      return true;
    }

    if (n == "POSITION" && ns.empty ())
    {
      if (this->POSITION_parser_)
      {
        this->POSITION_parser_->pre ();
        this->POSITION_parser_->_pre_impl ();
        this->POSITION_parser_->_characters (s);
        this->POSITION_parser_->_post_impl ();
        this->POSITION_parser_->post_POSITION ();
        this->POSITION ();
      }

      return true;
    }

    if (n == "PROCESSING" && ns.empty ())
    {
      if (this->PROCESSING_parser_)
      {
        this->PROCESSING_parser_->pre ();
        this->PROCESSING_parser_->_pre_impl ();
        this->PROCESSING_parser_->_characters (s);
        this->PROCESSING_parser_->_post_impl ();
        const ::std::string& tmp (this->PROCESSING_parser_->post_idref ());
        this->PROCESSING (tmp);
      }

      return true;
    }

    if (n == "ACCURACY" && ns.empty ())
    {
      if (this->ACCURACY_parser_)
      {
        this->ACCURACY_parser_->pre ();
        this->ACCURACY_parser_->_pre_impl ();
        this->ACCURACY_parser_->_characters (s);
        this->ACCURACY_parser_->_post_impl ();
        float tmp (this->ACCURACY_parser_->post_float ());
        this->ACCURACY (tmp);
      }

      return true;
    }

    if (n == "PC" && ns.empty ())
    {
      if (this->PC_parser_)
      {
        this->PC_parser_->pre ();
        this->PC_parser_->_pre_impl ();
        this->PC_parser_->_characters (s);
        this->PC_parser_->_post_impl ();
        this->PC_parser_->post_PC1 ();
        this->PC ();
      }

      return true;
    }

    return false;
  }

  void Page_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
    as.PHYSICAL_IMG_NR = false;
  }

  void Page_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");
    if (!as.PHYSICAL_IMG_NR)
      this->_expected_attribute (
        "", "PHYSICAL_IMG_NR");

    this->v_state_attr_stack_.pop ();
  }
}

namespace ALTO
{
}

// Begin epilogue.
//
//
// End epilogue.

