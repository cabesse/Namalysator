// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef BNL_NEWSPAPER_V1_1_PSKEL_HXX
#define BNL_NEWSPAPER_V1_1_PSKEL_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

// Forward declarations
//
class ct_HIERARCHY_pskel;
class ct_ISSUE_pskel;
class ct_SUPPLEMENT_pskel;
class ct_LIST_LIKE_pskel;
class ct_ITEM_pskel;
class ct_SECTION_pskel;
class ct_CHAPTER_pskel;
class ct_ARTICLE_LIKE_pskel;
class ct_CHAPTER_LIKE_HEADING_pskel;
class ct_CHAPTER_HEADING_pskel;
class ct_SECTION_HEADING_pskel;
class ct_ILLUSTRATION_LIKE_STRUCT_pskel;
class ct_TABLE_LIKE_STRUCT_pskel;
class ct_BODY_ARTICLE_pskel;
class ct_BODY_CHAPTER_pskel;
class ct_BODY_SECTION_pskel;
class ct_BODY_CONTENT_ARTICLE_pskel;
class ct_BODY_CONTENT_CHAPTER_pskel;
class ct_BODY_CONTENT_SECTION_pskel;
class ct_FORMULA_pskel;
class ct_PARAGRAPH_pskel;
class ct_FOOTNOTE_PARAGRAPH_pskel;
class ct_FINAL_pskel;
class ct_FPTR_pskel;
class ct_SEQ_pskel;
class Newspaper_pskel;
class TITLE_SECTION_pskel;
class CONTENT_pskel;
class TITLE_SECTION1_pskel;
class CONTENT1_pskel;
class DATA_pskel;
class par_pskel;

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_PARSER_USE_CHAR
#define XSD_CXX_PARSER_USE_CHAR
#endif

#include <xsd/cxx/xml/error-handler.hxx>
#include <xsd/cxx/parser/exceptions.hxx>
#include <xsd/cxx/parser/elements.hxx>
#include <xsd/cxx/parser/xml-schema.hxx>
#include <xsd/cxx/parser/validating/parser.hxx>
#include <xsd/cxx/parser/validating/exceptions.hxx>
#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
#include <xsd/cxx/parser/expat/elements.hxx>

namespace xml_schema
{
  // Built-in XML Schema types mapping.
  //
  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
  typedef ::xsd::cxx::parser::qname< char > qname;
  typedef ::xsd::cxx::parser::buffer buffer;
  typedef ::xsd::cxx::parser::time_zone time_zone;
  typedef ::xsd::cxx::parser::gday gday;
  typedef ::xsd::cxx::parser::gmonth gmonth;
  typedef ::xsd::cxx::parser::gyear gyear;
  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
  typedef ::xsd::cxx::parser::gyear_month gyear_month;
  typedef ::xsd::cxx::parser::date date;
  typedef ::xsd::cxx::parser::time time;
  typedef ::xsd::cxx::parser::date_time date_time;
  typedef ::xsd::cxx::parser::duration duration;

  // Base parser skeletons.
  //
  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;

  // Parser skeletons and implementations for the XML Schema
  // built-in types.
  //
  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;

  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;

  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;

  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;

  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;

  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;

  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;

  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;

  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;

  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;

  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;

  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;

  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;

  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;

  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;

  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;

  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;

  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;

  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;

  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;

  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;

  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;

  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;

  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;

  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;

  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;

  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;

  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;

  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;

  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;

  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;

  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;

  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;

  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;

  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;

  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;

  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;

  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
  //
  typedef ::xsd::cxx::parser::exception< char > exception;

  // Parsing diagnostics.
  //
  typedef ::xsd::cxx::parser::severity severity;
  typedef ::xsd::cxx::parser::error< char > error;
  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
  typedef ::xsd::cxx::parser::parsing< char > parsing;

  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // Read-only string.
  //
  typedef ::xsd::cxx::ro_string< char > ro_string;

  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
  // for details.
  //
  typedef ::xsd::cxx::parser::expat::document< char > document;
}

class ct_HIERARCHY_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  SUPPLEMENT ();

  virtual void
  ISSUE ();

  virtual void
  post_ct_HIERARCHY ();

  // Parser construction API.
  //
  void
  SUPPLEMENT_parser (::ct_SUPPLEMENT_pskel&);

  void
  ISSUE_parser (::ct_ISSUE_pskel&);

  void
  parsers (::ct_SUPPLEMENT_pskel& /* SUPPLEMENT */,
           ::ct_ISSUE_pskel& /* ISSUE */);

  // Constructor.
  //
  ct_HIERARCHY_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_SUPPLEMENT_pskel* SUPPLEMENT_parser_;
  ::ct_ISSUE_pskel* ISSUE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_HIERARCHY_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_ISSUE_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TITLE_SECTION ();

  virtual void
  CONTENT ();

  virtual void
  SUPPLEMENT ();

  virtual void
  post_ct_ISSUE ();

  // Parser construction API.
  //
  void
  TITLE_SECTION_parser (::TITLE_SECTION_pskel&);

  void
  CONTENT_parser (::CONTENT_pskel&);

  void
  SUPPLEMENT_parser (::ct_SUPPLEMENT_pskel&);

  void
  parsers (::TITLE_SECTION_pskel& /* TITLE_SECTION */,
           ::CONTENT_pskel& /* CONTENT */,
           ::ct_SUPPLEMENT_pskel& /* SUPPLEMENT */);

  // Constructor.
  //
  ct_ISSUE_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::TITLE_SECTION_pskel* TITLE_SECTION_parser_;
  ::CONTENT_pskel* CONTENT_parser_;
  ::ct_SUPPLEMENT_pskel* SUPPLEMENT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_ISSUE_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_SUPPLEMENT_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TITLE_SECTION ();

  virtual void
  CONTENT ();

  virtual void
  post_ct_SUPPLEMENT ();

  // Parser construction API.
  //
  void
  TITLE_SECTION_parser (::TITLE_SECTION1_pskel&);

  void
  CONTENT_parser (::CONTENT1_pskel&);

  void
  parsers (::TITLE_SECTION1_pskel& /* TITLE_SECTION */,
           ::CONTENT1_pskel& /* CONTENT */);

  // Constructor.
  //
  ct_SUPPLEMENT_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::TITLE_SECTION1_pskel* TITLE_SECTION_parser_;
  ::CONTENT1_pskel* CONTENT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_SUPPLEMENT_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_LIST_LIKE_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  CAPTION ();

  virtual void
  DATA ();

  virtual void
  TABLE_OF_CONTENTS ();

  virtual void
  LIST ();

  virtual void
  ITEM ();

  virtual void
  post_ct_LIST_LIKE ();

  // Parser construction API.
  //
  void
  CAPTION_parser (::ct_FINAL_pskel&);

  void
  DATA_parser (::DATA_pskel&);

  void
  TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel&);

  void
  LIST_parser (::ct_LIST_LIKE_pskel&);

  void
  ITEM_parser (::ct_ITEM_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* CAPTION */,
           ::DATA_pskel& /* DATA */,
           ::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
           ::ct_LIST_LIKE_pskel& /* LIST */,
           ::ct_ITEM_pskel& /* ITEM */);

  // Constructor.
  //
  ct_LIST_LIKE_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* CAPTION_parser_;
  ::DATA_pskel* DATA_parser_;
  ::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
  ::ct_LIST_LIKE_pskel* LIST_parser_;
  ::ct_ITEM_pskel* ITEM_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_LIST_LIKE_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[3UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_ITEM_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  PAGE_NUMBER ();

  virtual void
  ITEM_CAPTION ();

  virtual void
  SUBHEADLINE ();

  virtual void
  OVERLINE ();

  virtual void
  HEADLINE ();

  virtual void
  CONTINUATION_HEADLINE ();

  virtual void
  AUTHOR ();

  virtual void
  ITEM ();

  virtual void
  post_ct_ITEM ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  PAGE_NUMBER_parser (::ct_FINAL_pskel&);

  void
  ITEM_CAPTION_parser (::ct_FINAL_pskel&);

  void
  SUBHEADLINE_parser (::ct_FINAL_pskel&);

  void
  OVERLINE_parser (::ct_FINAL_pskel&);

  void
  HEADLINE_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel&);

  void
  AUTHOR_parser (::ct_FINAL_pskel&);

  void
  ITEM_parser (::ct_ITEM_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_FINAL_pskel& /* PAGE_NUMBER */,
           ::ct_FINAL_pskel& /* ITEM_CAPTION */,
           ::ct_FINAL_pskel& /* SUBHEADLINE */,
           ::ct_FINAL_pskel& /* OVERLINE */,
           ::ct_FINAL_pskel& /* HEADLINE */,
           ::ct_FINAL_pskel& /* CONTINUATION_HEADLINE */,
           ::ct_FINAL_pskel& /* AUTHOR */,
           ::ct_ITEM_pskel& /* ITEM */);

  // Constructor.
  //
  ct_ITEM_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_FINAL_pskel* PAGE_NUMBER_parser_;
  ::ct_FINAL_pskel* ITEM_CAPTION_parser_;
  ::ct_FINAL_pskel* SUBHEADLINE_parser_;
  ::ct_FINAL_pskel* OVERLINE_parser_;
  ::ct_FINAL_pskel* HEADLINE_parser_;
  ::ct_FINAL_pskel* CONTINUATION_HEADLINE_parser_;
  ::ct_FINAL_pskel* AUTHOR_parser_;
  ::ct_ITEM_pskel* ITEM_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_ITEM_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[3UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_SECTION_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  HEADING ();

  virtual void
  BODY ();

  virtual void
  SECTION ();

  virtual void
  NECROLOGY ();

  virtual void
  WEATHER ();

  virtual void
  SHIPPING ();

  virtual void
  RIDAS ();

  virtual void
  LETTER ();

  virtual void
  INTERVIEW ();

  virtual void
  IMPRINT ();

  virtual void
  ARTICLE ();

  virtual void
  ACKNOWLEDGEMENT ();

  virtual void
  post_ct_SECTION ();

  // Parser construction API.
  //
  void
  HEADING_parser (::ct_SECTION_HEADING_pskel&);

  void
  BODY_parser (::ct_BODY_SECTION_pskel&);

  void
  SECTION_parser (::ct_SECTION_pskel&);

  void
  NECROLOGY_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  WEATHER_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  SHIPPING_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  RIDAS_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  LETTER_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  INTERVIEW_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  IMPRINT_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  ARTICLE_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  ACKNOWLEDGEMENT_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  parsers (::ct_SECTION_HEADING_pskel& /* HEADING */,
           ::ct_BODY_SECTION_pskel& /* BODY */,
           ::ct_SECTION_pskel& /* SECTION */,
           ::ct_ARTICLE_LIKE_pskel& /* NECROLOGY */,
           ::ct_ARTICLE_LIKE_pskel& /* WEATHER */,
           ::ct_ARTICLE_LIKE_pskel& /* SHIPPING */,
           ::ct_ARTICLE_LIKE_pskel& /* RIDAS */,
           ::ct_ARTICLE_LIKE_pskel& /* LETTER */,
           ::ct_ARTICLE_LIKE_pskel& /* INTERVIEW */,
           ::ct_ARTICLE_LIKE_pskel& /* IMPRINT */,
           ::ct_ARTICLE_LIKE_pskel& /* ARTICLE */,
           ::ct_ARTICLE_LIKE_pskel& /* ACKNOWLEDGEMENT */);

  // Constructor.
  //
  ct_SECTION_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_SECTION_HEADING_pskel* HEADING_parser_;
  ::ct_BODY_SECTION_pskel* BODY_parser_;
  ::ct_SECTION_pskel* SECTION_parser_;
  ::ct_ARTICLE_LIKE_pskel* NECROLOGY_parser_;
  ::ct_ARTICLE_LIKE_pskel* WEATHER_parser_;
  ::ct_ARTICLE_LIKE_pskel* SHIPPING_parser_;
  ::ct_ARTICLE_LIKE_pskel* RIDAS_parser_;
  ::ct_ARTICLE_LIKE_pskel* LETTER_parser_;
  ::ct_ARTICLE_LIKE_pskel* INTERVIEW_parser_;
  ::ct_ARTICLE_LIKE_pskel* IMPRINT_parser_;
  ::ct_ARTICLE_LIKE_pskel* ARTICLE_parser_;
  ::ct_ARTICLE_LIKE_pskel* ACKNOWLEDGEMENT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_SECTION_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[3UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_CHAPTER_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  HEADING ();

  virtual void
  BODY ();

  virtual void
  LIST ();

  virtual void
  CHAPTER ();

  virtual void
  post_ct_CHAPTER ();

  // Parser construction API.
  //
  void
  HEADING_parser (::ct_CHAPTER_HEADING_pskel&);

  void
  BODY_parser (::ct_BODY_CHAPTER_pskel&);

  void
  LIST_parser (::ct_LIST_LIKE_pskel&);

  void
  CHAPTER_parser (::ct_CHAPTER_pskel&);

  void
  parsers (::ct_CHAPTER_HEADING_pskel& /* HEADING */,
           ::ct_BODY_CHAPTER_pskel& /* BODY */,
           ::ct_LIST_LIKE_pskel& /* LIST */,
           ::ct_CHAPTER_pskel& /* CHAPTER */);

  // Constructor.
  //
  ct_CHAPTER_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_CHAPTER_HEADING_pskel* HEADING_parser_;
  ::ct_BODY_CHAPTER_pskel* BODY_parser_;
  ::ct_LIST_LIKE_pskel* LIST_parser_;
  ::ct_CHAPTER_pskel* CHAPTER_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_CHAPTER_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[3UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_ARTICLE_LIKE_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  HEADING ();

  virtual void
  BODY ();

  virtual void
  TABLE_OF_CONTENTS ();

  virtual void
  LIST ();

  virtual void
  CHAPTER ();

  virtual void
  post_ct_ARTICLE_LIKE ();

  // Parser construction API.
  //
  void
  HEADING_parser (::ct_CHAPTER_LIKE_HEADING_pskel&);

  void
  BODY_parser (::ct_BODY_ARTICLE_pskel&);

  void
  TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel&);

  void
  LIST_parser (::ct_LIST_LIKE_pskel&);

  void
  CHAPTER_parser (::ct_CHAPTER_pskel&);

  void
  parsers (::ct_CHAPTER_LIKE_HEADING_pskel& /* HEADING */,
           ::ct_BODY_ARTICLE_pskel& /* BODY */,
           ::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
           ::ct_LIST_LIKE_pskel& /* LIST */,
           ::ct_CHAPTER_pskel& /* CHAPTER */);

  // Constructor.
  //
  ct_ARTICLE_LIKE_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_CHAPTER_LIKE_HEADING_pskel* HEADING_parser_;
  ::ct_BODY_ARTICLE_pskel* BODY_parser_;
  ::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
  ::ct_LIST_LIKE_pskel* LIST_parser_;
  ::ct_CHAPTER_pskel* CHAPTER_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_ARTICLE_LIKE_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[3UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_CHAPTER_LIKE_HEADING_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  OVERLINE ();

  virtual void
  TITLE ();

  virtual void
  SUBHEADLINE ();

  virtual void
  AUTHOR ();

  virtual void
  TEXT ();

  virtual void
  post_ct_CHAPTER_LIKE_HEADING ();

  // Parser construction API.
  //
  void
  OVERLINE_parser (::ct_FINAL_pskel&);

  void
  TITLE_parser (::ct_FINAL_pskel&);

  void
  SUBHEADLINE_parser (::ct_FINAL_pskel&);

  void
  AUTHOR_parser (::ct_FINAL_pskel&);

  void
  TEXT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* OVERLINE */,
           ::ct_FINAL_pskel& /* TITLE */,
           ::ct_FINAL_pskel& /* SUBHEADLINE */,
           ::ct_FINAL_pskel& /* AUTHOR */,
           ::ct_FINAL_pskel& /* TEXT */);

  // Constructor.
  //
  ct_CHAPTER_LIKE_HEADING_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* OVERLINE_parser_;
  ::ct_FINAL_pskel* TITLE_parser_;
  ::ct_FINAL_pskel* SUBHEADLINE_parser_;
  ::ct_FINAL_pskel* AUTHOR_parser_;
  ::ct_FINAL_pskel* TEXT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_CHAPTER_LIKE_HEADING_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_CHAPTER_HEADING_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TITLE ();

  virtual void
  AUTHOR ();

  virtual void
  TEXT ();

  virtual void
  post_ct_CHAPTER_HEADING ();

  // Parser construction API.
  //
  void
  TITLE_parser (::ct_FINAL_pskel&);

  void
  AUTHOR_parser (::ct_FINAL_pskel&);

  void
  TEXT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TITLE */,
           ::ct_FINAL_pskel& /* AUTHOR */,
           ::ct_FINAL_pskel& /* TEXT */);

  // Constructor.
  //
  ct_CHAPTER_HEADING_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TITLE_parser_;
  ::ct_FINAL_pskel* AUTHOR_parser_;
  ::ct_FINAL_pskel* TEXT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_CHAPTER_HEADING_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_SECTION_HEADING_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TITLE ();

  virtual void
  TEXT ();

  virtual void
  post_ct_SECTION_HEADING ();

  // Parser construction API.
  //
  void
  TITLE_parser (::ct_FINAL_pskel&);

  void
  TEXT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TITLE */,
           ::ct_FINAL_pskel& /* TEXT */);

  // Constructor.
  //
  ct_SECTION_HEADING_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TITLE_parser_;
  ::ct_FINAL_pskel* TEXT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_SECTION_HEADING_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_ILLUSTRATION_LIKE_STRUCT_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  IMAGE ();

  virtual void
  CAPTION ();

  virtual void
  post_ct_ILLUSTRATION_LIKE_STRUCT ();

  // Parser construction API.
  //
  void
  IMAGE_parser (::ct_FINAL_pskel&);

  void
  CAPTION_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* IMAGE */,
           ::ct_FINAL_pskel& /* CAPTION */);

  // Constructor.
  //
  ct_ILLUSTRATION_LIKE_STRUCT_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* IMAGE_parser_;
  ::ct_FINAL_pskel* CAPTION_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_ILLUSTRATION_LIKE_STRUCT_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_TABLE_LIKE_STRUCT_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  IMAGE ();

  virtual void
  CAPTION ();

  virtual void
  post_ct_TABLE_LIKE_STRUCT ();

  // Parser construction API.
  //
  void
  IMAGE_parser (::ct_FINAL_pskel&);

  void
  CAPTION_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* IMAGE */,
           ::ct_FINAL_pskel& /* CAPTION */);

  // Constructor.
  //
  ct_TABLE_LIKE_STRUCT_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* IMAGE_parser_;
  ::ct_FINAL_pskel* CAPTION_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_TABLE_LIKE_STRUCT_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_BODY_ARTICLE_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  BODY_CONTENT ();

  virtual void
  FOOTNOTE ();

  virtual void
  ILLUSTRATION ();

  virtual void
  TABLE ();

  virtual void
  post_ct_BODY_ARTICLE ();

  // Parser construction API.
  //
  void
  BODY_CONTENT_parser (::ct_BODY_CONTENT_ARTICLE_pskel&);

  void
  FOOTNOTE_parser (::ct_FOOTNOTE_PARAGRAPH_pskel&);

  void
  ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

  void
  TABLE_parser (::ct_TABLE_LIKE_STRUCT_pskel&);

  void
  parsers (::ct_BODY_CONTENT_ARTICLE_pskel& /* BODY_CONTENT */,
           ::ct_FOOTNOTE_PARAGRAPH_pskel& /* FOOTNOTE */,
           ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
           ::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */);

  // Constructor.
  //
  ct_BODY_ARTICLE_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_BODY_CONTENT_ARTICLE_pskel* BODY_CONTENT_parser_;
  ::ct_FOOTNOTE_PARAGRAPH_pskel* FOOTNOTE_parser_;
  ::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
  ::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_BODY_ARTICLE_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_BODY_CHAPTER_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  BODY_CONTENT ();

  virtual void
  FOOTNOTE ();

  virtual void
  ILLUSTRATION ();

  virtual void
  TABLE ();

  virtual void
  post_ct_BODY_CHAPTER ();

  // Parser construction API.
  //
  void
  BODY_CONTENT_parser (::ct_BODY_CONTENT_CHAPTER_pskel&);

  void
  FOOTNOTE_parser (::ct_FOOTNOTE_PARAGRAPH_pskel&);

  void
  ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

  void
  TABLE_parser (::ct_TABLE_LIKE_STRUCT_pskel&);

  void
  parsers (::ct_BODY_CONTENT_CHAPTER_pskel& /* BODY_CONTENT */,
           ::ct_FOOTNOTE_PARAGRAPH_pskel& /* FOOTNOTE */,
           ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
           ::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */);

  // Constructor.
  //
  ct_BODY_CHAPTER_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_BODY_CONTENT_CHAPTER_pskel* BODY_CONTENT_parser_;
  ::ct_FOOTNOTE_PARAGRAPH_pskel* FOOTNOTE_parser_;
  ::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
  ::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_BODY_CHAPTER_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_BODY_SECTION_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  BODY_CONTENT ();

  virtual void
  FOOTNOTE ();

  virtual void
  ILLUSTRATION ();

  virtual void
  TABLE ();

  virtual void
  post_ct_BODY_SECTION ();

  // Parser construction API.
  //
  void
  BODY_CONTENT_parser (::ct_BODY_CONTENT_SECTION_pskel&);

  void
  FOOTNOTE_parser (::ct_FOOTNOTE_PARAGRAPH_pskel&);

  void
  ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

  void
  TABLE_parser (::ct_TABLE_LIKE_STRUCT_pskel&);

  void
  parsers (::ct_BODY_CONTENT_SECTION_pskel& /* BODY_CONTENT */,
           ::ct_FOOTNOTE_PARAGRAPH_pskel& /* FOOTNOTE */,
           ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
           ::ct_TABLE_LIKE_STRUCT_pskel& /* TABLE */);

  // Constructor.
  //
  ct_BODY_SECTION_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_BODY_CONTENT_SECTION_pskel* BODY_CONTENT_parser_;
  ::ct_FOOTNOTE_PARAGRAPH_pskel* FOOTNOTE_parser_;
  ::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
  ::ct_TABLE_LIKE_STRUCT_pskel* TABLE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_BODY_SECTION_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_BODY_CONTENT_ARTICLE_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  AUTHOR ();

  virtual void
  PARAGRAPH ();

  virtual void
  LINK ();

  virtual void
  FORMULA ();

  virtual void
  CROSSHEADING ();

  virtual void
  CONTINUATION_LINK ();

  virtual void
  CONTINUATION_HEADLINE ();

  virtual void
  ABSTRACT ();

  virtual void
  post_ct_BODY_CONTENT_ARTICLE ();

  // Parser construction API.
  //
  void
  AUTHOR_parser (::ct_FINAL_pskel&);

  void
  PARAGRAPH_parser (::ct_PARAGRAPH_pskel&);

  void
  LINK_parser (::ct_FINAL_pskel&);

  void
  FORMULA_parser (::ct_FORMULA_pskel&);

  void
  CROSSHEADING_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_LINK_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel&);

  void
  ABSTRACT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* AUTHOR */,
           ::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
           ::ct_FINAL_pskel& /* LINK */,
           ::ct_FORMULA_pskel& /* FORMULA */,
           ::ct_FINAL_pskel& /* CROSSHEADING */,
           ::ct_FINAL_pskel& /* CONTINUATION_LINK */,
           ::ct_FINAL_pskel& /* CONTINUATION_HEADLINE */,
           ::ct_FINAL_pskel& /* ABSTRACT */);

  // Constructor.
  //
  ct_BODY_CONTENT_ARTICLE_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* AUTHOR_parser_;
  ::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
  ::ct_FINAL_pskel* LINK_parser_;
  ::ct_FORMULA_pskel* FORMULA_parser_;
  ::ct_FINAL_pskel* CROSSHEADING_parser_;
  ::ct_FINAL_pskel* CONTINUATION_LINK_parser_;
  ::ct_FINAL_pskel* CONTINUATION_HEADLINE_parser_;
  ::ct_FINAL_pskel* ABSTRACT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_BODY_CONTENT_ARTICLE_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_BODY_CONTENT_CHAPTER_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  PARAGRAPH ();

  virtual void
  LINK ();

  virtual void
  FORMULA ();

  virtual void
  CROSSHEADING ();

  virtual void
  CONTINUATION_LINK ();

  virtual void
  CONTINUATION_HEADLINE ();

  virtual void
  post_ct_BODY_CONTENT_CHAPTER ();

  // Parser construction API.
  //
  void
  PARAGRAPH_parser (::ct_PARAGRAPH_pskel&);

  void
  LINK_parser (::ct_FINAL_pskel&);

  void
  FORMULA_parser (::ct_FORMULA_pskel&);

  void
  CROSSHEADING_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_LINK_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
           ::ct_FINAL_pskel& /* LINK */,
           ::ct_FORMULA_pskel& /* FORMULA */,
           ::ct_FINAL_pskel& /* CROSSHEADING */,
           ::ct_FINAL_pskel& /* CONTINUATION_LINK */,
           ::ct_FINAL_pskel& /* CONTINUATION_HEADLINE */);

  // Constructor.
  //
  ct_BODY_CONTENT_CHAPTER_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
  ::ct_FINAL_pskel* LINK_parser_;
  ::ct_FORMULA_pskel* FORMULA_parser_;
  ::ct_FINAL_pskel* CROSSHEADING_parser_;
  ::ct_FINAL_pskel* CONTINUATION_LINK_parser_;
  ::ct_FINAL_pskel* CONTINUATION_HEADLINE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_BODY_CONTENT_CHAPTER_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_BODY_CONTENT_SECTION_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  PARAGRAPH ();

  virtual void
  MARRIAGE ();

  virtual void
  DEATH_NOTICE ();

  virtual void
  BIRTH ();

  virtual void
  ADVERTISEMENT ();

  virtual void
  post_ct_BODY_CONTENT_SECTION ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  PARAGRAPH_parser (::ct_PARAGRAPH_pskel&);

  void
  MARRIAGE_parser (::ct_FINAL_pskel&);

  void
  DEATH_NOTICE_parser (::ct_FINAL_pskel&);

  void
  BIRTH_parser (::ct_FINAL_pskel&);

  void
  ADVERTISEMENT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
           ::ct_FINAL_pskel& /* MARRIAGE */,
           ::ct_FINAL_pskel& /* DEATH_NOTICE */,
           ::ct_FINAL_pskel& /* BIRTH */,
           ::ct_FINAL_pskel& /* ADVERTISEMENT */);

  // Constructor.
  //
  ct_BODY_CONTENT_SECTION_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
  ::ct_FINAL_pskel* MARRIAGE_parser_;
  ::ct_FINAL_pskel* DEATH_NOTICE_parser_;
  ::ct_FINAL_pskel* BIRTH_parser_;
  ::ct_FINAL_pskel* ADVERTISEMENT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_BODY_CONTENT_SECTION_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_FORMULA_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  IMAGE ();

  virtual void
  post_ct_FORMULA ();

  // Parser construction API.
  //
  void
  IMAGE_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* IMAGE */);

  // Constructor.
  //
  ct_FORMULA_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* IMAGE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_FORMULA_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_PARAGRAPH_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXT ();

  virtual void
  post_ct_PARAGRAPH ();

  // Parser construction API.
  //
  void
  TEXT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXT */);

  // Constructor.
  //
  ct_PARAGRAPH_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_PARAGRAPH_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_FOOTNOTE_PARAGRAPH_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXT ();

  virtual void
  post_ct_FOOTNOTE_PARAGRAPH ();

  // Parser construction API.
  //
  void
  TEXT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXT */);

  // Constructor.
  //
  ct_FOOTNOTE_PARAGRAPH_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_FOOTNOTE_PARAGRAPH_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_FINAL_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  fptr ();

  virtual void
  post_ct_FINAL ();

  // Parser construction API.
  //
  void
  fptr_parser (::ct_FPTR_pskel&);

  void
  parsers (::ct_FPTR_pskel& /* fptr */);

  // Constructor.
  //
  ct_FINAL_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FPTR_pskel* fptr_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_FINAL_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class ct_FPTR_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  area ();

  virtual void
  seq ();

  virtual void
  par ();

  virtual void
  post_ct_FPTR ();

  // Parser construction API.
  //
  void
  area_parser (::xml_schema::any_type_pskel&);

  void
  seq_parser (::ct_SEQ_pskel&);

  void
  par_parser (::par_pskel&);

  void
  parsers (::xml_schema::any_type_pskel& /* area */,
           ::ct_SEQ_pskel& /* seq */,
           ::par_pskel& /* par */);

  // Constructor.
  //
  ct_FPTR_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::xml_schema::any_type_pskel* area_parser_;
  ::ct_SEQ_pskel* seq_parser_;
  ::par_pskel* par_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_FPTR_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class ct_SEQ_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  area ();

  virtual void
  post_ct_SEQ ();

  // Parser construction API.
  //
  void
  area_parser (::xml_schema::any_type_pskel&);

  void
  parsers (::xml_schema::any_type_pskel& /* area */);

  // Constructor.
  //
  ct_SEQ_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::xml_schema::any_type_pskel* area_parser_;

  protected:
  struct v_state_descr_
  {
    void (::ct_SEQ_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class Newspaper_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  VOLUME ();

  virtual void
  post_Newspaper ();

  // Parser construction API.
  //
  void
  VOLUME_parser (::ct_HIERARCHY_pskel&);

  void
  parsers (::ct_HIERARCHY_pskel& /* VOLUME */);

  // Constructor.
  //
  Newspaper_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_HIERARCHY_pskel* VOLUME_parser_;

  protected:
  struct v_state_descr_
  {
    void (::Newspaper_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start);
};

class TITLE_SECTION_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  MOTTO ();

  virtual void
  TABLE_OF_CONTENTS ();

  virtual void
  PAGE_NUMBER ();

  virtual void
  ILLUSTRATION ();

  virtual void
  SUBHEADLINE ();

  virtual void
  OVERLINE ();

  virtual void
  HEADLINE ();

  virtual void
  CONTINUATION_HEADLINE ();

  virtual void
  post_TITLE_SECTION ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  MOTTO_parser (::ct_FINAL_pskel&);

  void
  TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel&);

  void
  PAGE_NUMBER_parser (::ct_FINAL_pskel&);

  void
  ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

  void
  SUBHEADLINE_parser (::ct_FINAL_pskel&);

  void
  OVERLINE_parser (::ct_FINAL_pskel&);

  void
  HEADLINE_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_FINAL_pskel& /* MOTTO */,
           ::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
           ::ct_FINAL_pskel& /* PAGE_NUMBER */,
           ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
           ::ct_FINAL_pskel& /* SUBHEADLINE */,
           ::ct_FINAL_pskel& /* OVERLINE */,
           ::ct_FINAL_pskel& /* HEADLINE */,
           ::ct_FINAL_pskel& /* CONTINUATION_HEADLINE */);

  // Constructor.
  //
  TITLE_SECTION_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_FINAL_pskel* MOTTO_parser_;
  ::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
  ::ct_FINAL_pskel* PAGE_NUMBER_parser_;
  ::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
  ::ct_FINAL_pskel* SUBHEADLINE_parser_;
  ::ct_FINAL_pskel* OVERLINE_parser_;
  ::ct_FINAL_pskel* HEADLINE_parser_;
  ::ct_FINAL_pskel* CONTINUATION_HEADLINE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::TITLE_SECTION_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class CONTENT_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  SECTION ();

  virtual void
  PARAGRAPH ();

  virtual void
  NECROLOGY ();

  virtual void
  WEATHER ();

  virtual void
  SHIPPING ();

  virtual void
  RIDAS ();

  virtual void
  LETTER ();

  virtual void
  INTERVIEW ();

  virtual void
  IMPRINT ();

  virtual void
  ARTICLE ();

  virtual void
  ACKNOWLEDGEMENT ();

  virtual void
  MARRIAGE ();

  virtual void
  DEATH_NOTICE ();

  virtual void
  BIRTH ();

  virtual void
  ADVERTISEMENT ();

  virtual void
  post_CONTENT ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  SECTION_parser (::ct_SECTION_pskel&);

  void
  PARAGRAPH_parser (::ct_PARAGRAPH_pskel&);

  void
  NECROLOGY_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  WEATHER_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  SHIPPING_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  RIDAS_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  LETTER_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  INTERVIEW_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  IMPRINT_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  ARTICLE_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  ACKNOWLEDGEMENT_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  MARRIAGE_parser (::ct_FINAL_pskel&);

  void
  DEATH_NOTICE_parser (::ct_FINAL_pskel&);

  void
  BIRTH_parser (::ct_FINAL_pskel&);

  void
  ADVERTISEMENT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_SECTION_pskel& /* SECTION */,
           ::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
           ::ct_ARTICLE_LIKE_pskel& /* NECROLOGY */,
           ::ct_ARTICLE_LIKE_pskel& /* WEATHER */,
           ::ct_ARTICLE_LIKE_pskel& /* SHIPPING */,
           ::ct_ARTICLE_LIKE_pskel& /* RIDAS */,
           ::ct_ARTICLE_LIKE_pskel& /* LETTER */,
           ::ct_ARTICLE_LIKE_pskel& /* INTERVIEW */,
           ::ct_ARTICLE_LIKE_pskel& /* IMPRINT */,
           ::ct_ARTICLE_LIKE_pskel& /* ARTICLE */,
           ::ct_ARTICLE_LIKE_pskel& /* ACKNOWLEDGEMENT */,
           ::ct_FINAL_pskel& /* MARRIAGE */,
           ::ct_FINAL_pskel& /* DEATH_NOTICE */,
           ::ct_FINAL_pskel& /* BIRTH */,
           ::ct_FINAL_pskel& /* ADVERTISEMENT */);

  // Constructor.
  //
  CONTENT_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_SECTION_pskel* SECTION_parser_;
  ::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
  ::ct_ARTICLE_LIKE_pskel* NECROLOGY_parser_;
  ::ct_ARTICLE_LIKE_pskel* WEATHER_parser_;
  ::ct_ARTICLE_LIKE_pskel* SHIPPING_parser_;
  ::ct_ARTICLE_LIKE_pskel* RIDAS_parser_;
  ::ct_ARTICLE_LIKE_pskel* LETTER_parser_;
  ::ct_ARTICLE_LIKE_pskel* INTERVIEW_parser_;
  ::ct_ARTICLE_LIKE_pskel* IMPRINT_parser_;
  ::ct_ARTICLE_LIKE_pskel* ARTICLE_parser_;
  ::ct_ARTICLE_LIKE_pskel* ACKNOWLEDGEMENT_parser_;
  ::ct_FINAL_pskel* MARRIAGE_parser_;
  ::ct_FINAL_pskel* DEATH_NOTICE_parser_;
  ::ct_FINAL_pskel* BIRTH_parser_;
  ::ct_FINAL_pskel* ADVERTISEMENT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::CONTENT_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class TITLE_SECTION1_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  TABLE_OF_CONTENTS ();

  virtual void
  PAGE_NUMBER ();

  virtual void
  ILLUSTRATION ();

  virtual void
  SUBHEADLINE ();

  virtual void
  OVERLINE ();

  virtual void
  HEADLINE ();

  virtual void
  CONTINUATION_HEADLINE ();

  virtual void
  post_TITLE_SECTION1 ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  TABLE_OF_CONTENTS_parser (::ct_LIST_LIKE_pskel&);

  void
  PAGE_NUMBER_parser (::ct_FINAL_pskel&);

  void
  ILLUSTRATION_parser (::ct_ILLUSTRATION_LIKE_STRUCT_pskel&);

  void
  SUBHEADLINE_parser (::ct_FINAL_pskel&);

  void
  OVERLINE_parser (::ct_FINAL_pskel&);

  void
  HEADLINE_parser (::ct_FINAL_pskel&);

  void
  CONTINUATION_HEADLINE_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_LIST_LIKE_pskel& /* TABLE_OF_CONTENTS */,
           ::ct_FINAL_pskel& /* PAGE_NUMBER */,
           ::ct_ILLUSTRATION_LIKE_STRUCT_pskel& /* ILLUSTRATION */,
           ::ct_FINAL_pskel& /* SUBHEADLINE */,
           ::ct_FINAL_pskel& /* OVERLINE */,
           ::ct_FINAL_pskel& /* HEADLINE */,
           ::ct_FINAL_pskel& /* CONTINUATION_HEADLINE */);

  // Constructor.
  //
  TITLE_SECTION1_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_LIST_LIKE_pskel* TABLE_OF_CONTENTS_parser_;
  ::ct_FINAL_pskel* PAGE_NUMBER_parser_;
  ::ct_ILLUSTRATION_LIKE_STRUCT_pskel* ILLUSTRATION_parser_;
  ::ct_FINAL_pskel* SUBHEADLINE_parser_;
  ::ct_FINAL_pskel* OVERLINE_parser_;
  ::ct_FINAL_pskel* HEADLINE_parser_;
  ::ct_FINAL_pskel* CONTINUATION_HEADLINE_parser_;

  protected:
  struct v_state_descr_
  {
    void (::TITLE_SECTION1_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class CONTENT1_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  SECTION ();

  virtual void
  PARAGRAPH ();

  virtual void
  NECROLOGY ();

  virtual void
  WEATHER ();

  virtual void
  SHIPPING ();

  virtual void
  RIDAS ();

  virtual void
  LETTER ();

  virtual void
  INTERVIEW ();

  virtual void
  IMPRINT ();

  virtual void
  ARTICLE ();

  virtual void
  ACKNOWLEDGEMENT ();

  virtual void
  MARRIAGE ();

  virtual void
  DEATH_NOTICE ();

  virtual void
  BIRTH ();

  virtual void
  ADVERTISEMENT ();

  virtual void
  post_CONTENT1 ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  SECTION_parser (::ct_SECTION_pskel&);

  void
  PARAGRAPH_parser (::ct_PARAGRAPH_pskel&);

  void
  NECROLOGY_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  WEATHER_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  SHIPPING_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  RIDAS_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  LETTER_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  INTERVIEW_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  IMPRINT_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  ARTICLE_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  ACKNOWLEDGEMENT_parser (::ct_ARTICLE_LIKE_pskel&);

  void
  MARRIAGE_parser (::ct_FINAL_pskel&);

  void
  DEATH_NOTICE_parser (::ct_FINAL_pskel&);

  void
  BIRTH_parser (::ct_FINAL_pskel&);

  void
  ADVERTISEMENT_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_SECTION_pskel& /* SECTION */,
           ::ct_PARAGRAPH_pskel& /* PARAGRAPH */,
           ::ct_ARTICLE_LIKE_pskel& /* NECROLOGY */,
           ::ct_ARTICLE_LIKE_pskel& /* WEATHER */,
           ::ct_ARTICLE_LIKE_pskel& /* SHIPPING */,
           ::ct_ARTICLE_LIKE_pskel& /* RIDAS */,
           ::ct_ARTICLE_LIKE_pskel& /* LETTER */,
           ::ct_ARTICLE_LIKE_pskel& /* INTERVIEW */,
           ::ct_ARTICLE_LIKE_pskel& /* IMPRINT */,
           ::ct_ARTICLE_LIKE_pskel& /* ARTICLE */,
           ::ct_ARTICLE_LIKE_pskel& /* ACKNOWLEDGEMENT */,
           ::ct_FINAL_pskel& /* MARRIAGE */,
           ::ct_FINAL_pskel& /* DEATH_NOTICE */,
           ::ct_FINAL_pskel& /* BIRTH */,
           ::ct_FINAL_pskel& /* ADVERTISEMENT */);

  // Constructor.
  //
  CONTENT1_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_SECTION_pskel* SECTION_parser_;
  ::ct_PARAGRAPH_pskel* PARAGRAPH_parser_;
  ::ct_ARTICLE_LIKE_pskel* NECROLOGY_parser_;
  ::ct_ARTICLE_LIKE_pskel* WEATHER_parser_;
  ::ct_ARTICLE_LIKE_pskel* SHIPPING_parser_;
  ::ct_ARTICLE_LIKE_pskel* RIDAS_parser_;
  ::ct_ARTICLE_LIKE_pskel* LETTER_parser_;
  ::ct_ARTICLE_LIKE_pskel* INTERVIEW_parser_;
  ::ct_ARTICLE_LIKE_pskel* IMPRINT_parser_;
  ::ct_ARTICLE_LIKE_pskel* ARTICLE_parser_;
  ::ct_ARTICLE_LIKE_pskel* ACKNOWLEDGEMENT_parser_;
  ::ct_FINAL_pskel* MARRIAGE_parser_;
  ::ct_FINAL_pskel* DEATH_NOTICE_parser_;
  ::ct_FINAL_pskel* BIRTH_parser_;
  ::ct_FINAL_pskel* ADVERTISEMENT_parser_;

  protected:
  struct v_state_descr_
  {
    void (::CONTENT1_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class DATA_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  TEXTBLOCK ();

  virtual void
  PUBLISHING_STMT ();

  virtual void
  PAGE_NUMBER ();

  virtual void
  ITEM_CAPTION ();

  virtual void
  AUTHOR ();

  virtual void
  post_DATA ();

  // Parser construction API.
  //
  void
  TEXTBLOCK_parser (::ct_FINAL_pskel&);

  void
  PUBLISHING_STMT_parser (::ct_FINAL_pskel&);

  void
  PAGE_NUMBER_parser (::ct_FINAL_pskel&);

  void
  ITEM_CAPTION_parser (::ct_FINAL_pskel&);

  void
  AUTHOR_parser (::ct_FINAL_pskel&);

  void
  parsers (::ct_FINAL_pskel& /* TEXTBLOCK */,
           ::ct_FINAL_pskel& /* PUBLISHING_STMT */,
           ::ct_FINAL_pskel& /* PAGE_NUMBER */,
           ::ct_FINAL_pskel& /* ITEM_CAPTION */,
           ::ct_FINAL_pskel& /* AUTHOR */);

  // Constructor.
  //
  DATA_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::ct_FINAL_pskel* TEXTBLOCK_parser_;
  ::ct_FINAL_pskel* PUBLISHING_STMT_parser_;
  ::ct_FINAL_pskel* PAGE_NUMBER_parser_;
  ::ct_FINAL_pskel* ITEM_CAPTION_parser_;
  ::ct_FINAL_pskel* AUTHOR_parser_;

  protected:
  struct v_state_descr_
  {
    void (::DATA_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

class par_pskel: public ::xml_schema::complex_content
{
  public:
  // Parser callbacks. Override them in your implementation.
  //
  // virtual void
  // pre ();

  virtual void
  area ();

  virtual void
  seq ();

  virtual void
  post_par ();

  // Parser construction API.
  //
  void
  area_parser (::xml_schema::any_type_pskel&);

  void
  seq_parser (::ct_SEQ_pskel&);

  void
  parsers (::xml_schema::any_type_pskel& /* area */,
           ::ct_SEQ_pskel& /* seq */);

  // Constructor.
  //
  par_pskel ();

  // Implementation.
  //
  protected:
  virtual bool
  _start_element_impl (const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string&,
                       const ::xml_schema::ro_string*);

  virtual bool
  _end_element_impl (const ::xml_schema::ro_string&,
                     const ::xml_schema::ro_string&);

  protected:
  ::xml_schema::any_type_pskel* area_parser_;
  ::ct_SEQ_pskel* seq_parser_;

  protected:
  struct v_state_descr_
  {
    void (::par_pskel::*func) (
      unsigned long&,
      unsigned long&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string&,
      const ::xml_schema::ro_string*,
      bool);
    unsigned long state;
    unsigned long count;
  };

  struct v_state_
  {
    v_state_descr_ data[2UL];
    unsigned long size;
  };

  v_state_ v_state_first_;
  ::xsd::cxx::parser::pod_stack v_state_stack_;

  virtual void
  _pre_e_validate ();

  virtual void
  _post_e_validate ();

  void
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start);
};

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // BNL_NEWSPAPER_V1_1_PSKEL_HXX
