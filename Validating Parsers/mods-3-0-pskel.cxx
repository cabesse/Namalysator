// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "mods-3-0-pskel.hxx"

namespace mods
{
  namespace v3
  {
    // modsType_pskel
    //

    void modsType_pskel::
    titleInfo ()
    {
    }

    void modsType_pskel::
    name ()
    {
    }

    void modsType_pskel::
    typeOfResource ()
    {
    }

    void modsType_pskel::
    genre ()
    {
    }

    void modsType_pskel::
    originInfo ()
    {
    }

    void modsType_pskel::
    language ()
    {
    }

    void modsType_pskel::
    physicalDescription ()
    {
    }

    void modsType_pskel::
    abstract ()
    {
    }

    void modsType_pskel::
    tableOfContents ()
    {
    }

    void modsType_pskel::
    targetAudience ()
    {
    }

    void modsType_pskel::
    note ()
    {
    }

    void modsType_pskel::
    subject ()
    {
    }

    void modsType_pskel::
    classification ()
    {
    }

    void modsType_pskel::
    relatedItem ()
    {
    }

    void modsType_pskel::
    identifier ()
    {
    }

    void modsType_pskel::
    location ()
    {
    }

    void modsType_pskel::
    accessCondition ()
    {
    }

    void modsType_pskel::
    extension ()
    {
    }

    void modsType_pskel::
    recordInfo ()
    {
    }

    void modsType_pskel::
    ID (const ::std::string&)
    {
    }

    void modsType_pskel::
    version ()
    {
    }

    void modsType_pskel::
    post_modsType ()
    {
    }

    // titleInfoType_pskel
    //

    void titleInfoType_pskel::
    title ()
    {
    }

    void titleInfoType_pskel::
    subTitle ()
    {
    }

    void titleInfoType_pskel::
    partNumber ()
    {
    }

    void titleInfoType_pskel::
    partName ()
    {
    }

    void titleInfoType_pskel::
    nonSort ()
    {
    }

    void titleInfoType_pskel::
    ID (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    type ()
    {
    }

    void titleInfoType_pskel::
    authority ()
    {
    }

    void titleInfoType_pskel::
    displayLabel (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    type1 (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    href (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    role (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    arcrole (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    title1 (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    show ()
    {
    }

    void titleInfoType_pskel::
    actuate ()
    {
    }

    void titleInfoType_pskel::
    lang ()
    {
    }

    void titleInfoType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void titleInfoType_pskel::
    script ()
    {
    }

    void titleInfoType_pskel::
    transliteration ()
    {
    }

    void titleInfoType_pskel::
    post_titleInfoType ()
    {
    }

    // nameType_pskel
    //

    void nameType_pskel::
    namePart ()
    {
    }

    void nameType_pskel::
    displayForm ()
    {
    }

    void nameType_pskel::
    affiliation ()
    {
    }

    void nameType_pskel::
    role ()
    {
    }

    void nameType_pskel::
    description ()
    {
    }

    void nameType_pskel::
    ID (const ::std::string&)
    {
    }

    void nameType_pskel::
    type ()
    {
    }

    void nameType_pskel::
    authority ()
    {
    }

    void nameType_pskel::
    type1 (const ::std::string&)
    {
    }

    void nameType_pskel::
    href (const ::std::string&)
    {
    }

    void nameType_pskel::
    role1 (const ::std::string&)
    {
    }

    void nameType_pskel::
    arcrole (const ::std::string&)
    {
    }

    void nameType_pskel::
    title (const ::std::string&)
    {
    }

    void nameType_pskel::
    show ()
    {
    }

    void nameType_pskel::
    actuate ()
    {
    }

    void nameType_pskel::
    lang ()
    {
    }

    void nameType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void nameType_pskel::
    script ()
    {
    }

    void nameType_pskel::
    transliteration ()
    {
    }

    void nameType_pskel::
    post_nameType ()
    {
    }

    // namePartType_pskel
    //

    void namePartType_pskel::
    type ()
    {
    }

    void namePartType_pskel::
    post_namePartType ()
    {
    }

    // roleType_pskel
    //

    void roleType_pskel::
    roleTerm ()
    {
    }

    void roleType_pskel::
    post_roleType ()
    {
    }

    // resourceType_pskel
    //

    void resourceType_pskel::
    post_resourceType ()
    {
    }

    // typeOfResourceType_pskel
    //

    void typeOfResourceType_pskel::
    collection ()
    {
    }

    void typeOfResourceType_pskel::
    manuscript ()
    {
    }

    void typeOfResourceType_pskel::
    post_typeOfResourceType ()
    {
      post_resourceType ();
    }

    // genreType_pskel
    //

    void genreType_pskel::
    authority ()
    {
    }

    void genreType_pskel::
    lang ()
    {
    }

    void genreType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void genreType_pskel::
    script ()
    {
    }

    void genreType_pskel::
    transliteration ()
    {
    }

    void genreType_pskel::
    post_genreType ()
    {
    }

    // originInfoType_pskel
    //

    void originInfoType_pskel::
    place ()
    {
    }

    void originInfoType_pskel::
    publisher ()
    {
    }

    void originInfoType_pskel::
    dateIssued ()
    {
    }

    void originInfoType_pskel::
    dateCreated ()
    {
    }

    void originInfoType_pskel::
    dateCaptured ()
    {
    }

    void originInfoType_pskel::
    dateValid ()
    {
    }

    void originInfoType_pskel::
    dateModified ()
    {
    }

    void originInfoType_pskel::
    copyrightDate ()
    {
    }

    void originInfoType_pskel::
    dateOther ()
    {
    }

    void originInfoType_pskel::
    edition ()
    {
    }

    void originInfoType_pskel::
    issuance ()
    {
    }

    void originInfoType_pskel::
    frequency ()
    {
    }

    void originInfoType_pskel::
    lang ()
    {
    }

    void originInfoType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void originInfoType_pskel::
    script ()
    {
    }

    void originInfoType_pskel::
    transliteration ()
    {
    }

    void originInfoType_pskel::
    post_originInfoType ()
    {
    }

    // placeType_pskel
    //

    void placeType_pskel::
    placeTerm ()
    {
    }

    void placeType_pskel::
    post_placeType ()
    {
    }

    // placeTermType_pskel
    //

    void placeTermType_pskel::
    authority ()
    {
    }

    void placeTermType_pskel::
    type ()
    {
    }

    void placeTermType_pskel::
    post_placeTermType ()
    {
    }

    // languageType_pskel
    //

    void languageType_pskel::
    languageTerm ()
    {
    }

    void languageType_pskel::
    post_languageType ()
    {
    }

    // physicalDescriptionType_pskel
    //

    void physicalDescriptionType_pskel::
    form ()
    {
    }

    void physicalDescriptionType_pskel::
    reformattingQuality ()
    {
    }

    void physicalDescriptionType_pskel::
    internetMediaType ()
    {
    }

    void physicalDescriptionType_pskel::
    extent ()
    {
    }

    void physicalDescriptionType_pskel::
    digitalOrigin ()
    {
    }

    void physicalDescriptionType_pskel::
    note ()
    {
    }

    void physicalDescriptionType_pskel::
    lang ()
    {
    }

    void physicalDescriptionType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void physicalDescriptionType_pskel::
    script ()
    {
    }

    void physicalDescriptionType_pskel::
    transliteration ()
    {
    }

    void physicalDescriptionType_pskel::
    post_physicalDescriptionType ()
    {
    }

    // targetAudienceType_pskel
    //

    void targetAudienceType_pskel::
    authority ()
    {
    }

    void targetAudienceType_pskel::
    lang ()
    {
    }

    void targetAudienceType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void targetAudienceType_pskel::
    script ()
    {
    }

    void targetAudienceType_pskel::
    transliteration ()
    {
    }

    void targetAudienceType_pskel::
    post_targetAudienceType ()
    {
    }

    // subjectType_pskel
    //

    void subjectType_pskel::
    topic ()
    {
    }

    void subjectType_pskel::
    geographic ()
    {
    }

    void subjectType_pskel::
    temporal ()
    {
    }

    void subjectType_pskel::
    titleInfo ()
    {
    }

    void subjectType_pskel::
    name ()
    {
    }

    void subjectType_pskel::
    geographicCode ()
    {
    }

    void subjectType_pskel::
    hierarchicalGeographic ()
    {
    }

    void subjectType_pskel::
    cartographics ()
    {
    }

    void subjectType_pskel::
    occupation ()
    {
    }

    void subjectType_pskel::
    ID (const ::std::string&)
    {
    }

    void subjectType_pskel::
    type (const ::std::string&)
    {
    }

    void subjectType_pskel::
    href (const ::std::string&)
    {
    }

    void subjectType_pskel::
    role (const ::std::string&)
    {
    }

    void subjectType_pskel::
    arcrole (const ::std::string&)
    {
    }

    void subjectType_pskel::
    title (const ::std::string&)
    {
    }

    void subjectType_pskel::
    show ()
    {
    }

    void subjectType_pskel::
    actuate ()
    {
    }

    void subjectType_pskel::
    authority ()
    {
    }

    void subjectType_pskel::
    lang ()
    {
    }

    void subjectType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void subjectType_pskel::
    script ()
    {
    }

    void subjectType_pskel::
    transliteration ()
    {
    }

    void subjectType_pskel::
    post_subjectType ()
    {
    }

    // classificationType_pskel
    //

    void classificationType_pskel::
    authority ()
    {
    }

    void classificationType_pskel::
    edition ()
    {
    }

    void classificationType_pskel::
    lang ()
    {
    }

    void classificationType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void classificationType_pskel::
    script ()
    {
    }

    void classificationType_pskel::
    transliteration ()
    {
    }

    void classificationType_pskel::
    post_classificationType ()
    {
    }

    // relatedItemType_pskel
    //

    void relatedItemType_pskel::
    part ()
    {
    }

    void relatedItemType_pskel::
    type ()
    {
    }

    void relatedItemType_pskel::
    displayLabel (const ::std::string&)
    {
    }

    void relatedItemType_pskel::
    type1 (const ::std::string&)
    {
    }

    void relatedItemType_pskel::
    href (const ::std::string&)
    {
    }

    void relatedItemType_pskel::
    role (const ::std::string&)
    {
    }

    void relatedItemType_pskel::
    arcrole (const ::std::string&)
    {
    }

    void relatedItemType_pskel::
    title (const ::std::string&)
    {
    }

    void relatedItemType_pskel::
    show ()
    {
    }

    void relatedItemType_pskel::
    actuate ()
    {
    }

    void relatedItemType_pskel::
    post_relatedItemType ()
    {
      post_modsType ();
    }

    // partType_pskel
    //

    void partType_pskel::
    detail ()
    {
    }

    void partType_pskel::
    extent ()
    {
    }

    void partType_pskel::
    date ()
    {
    }

    void partType_pskel::
    text ()
    {
    }

    void partType_pskel::
    post_partType ()
    {
    }

    // detailType_pskel
    //

    void detailType_pskel::
    number ()
    {
    }

    void detailType_pskel::
    caption ()
    {
    }

    void detailType_pskel::
    title ()
    {
    }

    void detailType_pskel::
    type ()
    {
    }

    void detailType_pskel::
    level (unsigned long long)
    {
    }

    void detailType_pskel::
    post_detailType ()
    {
    }

    // extentType_pskel
    //

    void extentType_pskel::
    start ()
    {
    }

    void extentType_pskel::
    end ()
    {
    }

    void extentType_pskel::
    total (unsigned long long)
    {
    }

    void extentType_pskel::
    list ()
    {
    }

    void extentType_pskel::
    unit ()
    {
    }

    void extentType_pskel::
    post_extentType ()
    {
    }

    // identifierType_pskel
    //

    void identifierType_pskel::
    type ()
    {
    }

    void identifierType_pskel::
    displayLabel ()
    {
    }

    void identifierType_pskel::
    invalid ()
    {
    }

    void identifierType_pskel::
    lang ()
    {
    }

    void identifierType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void identifierType_pskel::
    script ()
    {
    }

    void identifierType_pskel::
    transliteration ()
    {
    }

    void identifierType_pskel::
    post_identifierType ()
    {
    }

    // locationType_pskel
    //

    void locationType_pskel::
    physicalLocation ()
    {
    }

    void locationType_pskel::
    url ()
    {
    }

    void locationType_pskel::
    post_locationType ()
    {
    }

    // extensionType_pskel
    //

    void extensionType_pskel::
    post_extensionType ()
    {
    }

    // recordInfoType_pskel
    //

    void recordInfoType_pskel::
    recordContentSource ()
    {
    }

    void recordInfoType_pskel::
    recordCreationDate ()
    {
    }

    void recordInfoType_pskel::
    recordChangeDate ()
    {
    }

    void recordInfoType_pskel::
    recordIdentifier ()
    {
    }

    void recordInfoType_pskel::
    languageOfCataloging ()
    {
    }

    void recordInfoType_pskel::
    recordOrigin ()
    {
    }

    void recordInfoType_pskel::
    lang ()
    {
    }

    void recordInfoType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void recordInfoType_pskel::
    script ()
    {
    }

    void recordInfoType_pskel::
    transliteration ()
    {
    }

    void recordInfoType_pskel::
    post_recordInfoType ()
    {
    }

    // unstructuredText_pskel
    //

    void unstructuredText_pskel::
    type (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    href (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    role (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    arcrole (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    title (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    show ()
    {
    }

    void unstructuredText_pskel::
    actuate ()
    {
    }

    void unstructuredText_pskel::
    lang ()
    {
    }

    void unstructuredText_pskel::
    lang1 (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    script ()
    {
    }

    void unstructuredText_pskel::
    transliteration ()
    {
    }

    void unstructuredText_pskel::
    displayLabel (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    type1 (const ::std::string&)
    {
    }

    void unstructuredText_pskel::
    post_unstructuredText ()
    {
    }

    // baseDateType_pskel
    //

    void baseDateType_pskel::
    encoding ()
    {
    }

    void baseDateType_pskel::
    qualifier ()
    {
    }

    void baseDateType_pskel::
    point ()
    {
    }

    void baseDateType_pskel::
    post_baseDateType ()
    {
    }

    // dateType_pskel
    //

    void dateType_pskel::
    keyDate ()
    {
    }

    void dateType_pskel::
    post_dateType ()
    {
      post_baseDateType ();
    }

    // sourceType_pskel
    //

    void sourceType_pskel::
    authority ()
    {
    }

    void sourceType_pskel::
    lang ()
    {
    }

    void sourceType_pskel::
    lang1 (const ::std::string&)
    {
    }

    void sourceType_pskel::
    script ()
    {
    }

    void sourceType_pskel::
    transliteration ()
    {
    }

    void sourceType_pskel::
    post_sourceType ()
    {
    }

    // codeOrText_pskel
    //

    void codeOrText_pskel::
    post_codeOrText ()
    {
    }

    // placeAuthority_pskel
    //

    void placeAuthority_pskel::
    post_placeAuthority ()
    {
    }

    // modsCollection_pskel
    //

    void modsCollection_pskel::
    mods ()
    {
    }

    void modsCollection_pskel::
    post_modsCollection ()
    {
    }

    // version_pskel
    //

    void version_pskel::
    post_version ()
    {
    }

    // type_pskel
    //

    void type_pskel::
    post_type ()
    {
    }

    // type1_pskel
    //

    void type1_pskel::
    post_type1 ()
    {
    }

    // type2_pskel
    //

    void type2_pskel::
    post_type2 ()
    {
    }

    // roleTerm_pskel
    //

    void roleTerm_pskel::
    authority ()
    {
    }

    void roleTerm_pskel::
    type ()
    {
    }

    void roleTerm_pskel::
    post_roleTerm ()
    {
    }

    // collection_pskel
    //

    void collection_pskel::
    post_collection ()
    {
    }

    // manuscript_pskel
    //

    void manuscript_pskel::
    post_manuscript ()
    {
    }

    // issuance_pskel
    //

    void issuance_pskel::
    post_issuance ()
    {
    }

    // languageTerm_pskel
    //

    void languageTerm_pskel::
    authority ()
    {
    }

    void languageTerm_pskel::
    type ()
    {
    }

    void languageTerm_pskel::
    post_languageTerm ()
    {
    }

    // form_pskel
    //

    void form_pskel::
    authority ()
    {
    }

    void form_pskel::
    post_form ()
    {
    }

    // reformattingQuality_pskel
    //

    void reformattingQuality_pskel::
    post_reformattingQuality ()
    {
    }

    // digitalOrigin_pskel
    //

    void digitalOrigin_pskel::
    post_digitalOrigin ()
    {
    }

    // geographicCode_pskel
    //

    void geographicCode_pskel::
    authority ()
    {
    }

    void geographicCode_pskel::
    post_geographicCode ()
    {
    }

    // hierarchicalGeographic_pskel
    //

    void hierarchicalGeographic_pskel::
    continent ()
    {
    }

    void hierarchicalGeographic_pskel::
    country ()
    {
    }

    void hierarchicalGeographic_pskel::
    province ()
    {
    }

    void hierarchicalGeographic_pskel::
    region ()
    {
    }

    void hierarchicalGeographic_pskel::
    state ()
    {
    }

    void hierarchicalGeographic_pskel::
    territory ()
    {
    }

    void hierarchicalGeographic_pskel::
    county ()
    {
    }

    void hierarchicalGeographic_pskel::
    city ()
    {
    }

    void hierarchicalGeographic_pskel::
    island ()
    {
    }

    void hierarchicalGeographic_pskel::
    area ()
    {
    }

    void hierarchicalGeographic_pskel::
    post_hierarchicalGeographic ()
    {
    }

    // cartographics_pskel
    //

    void cartographics_pskel::
    scale ()
    {
    }

    void cartographics_pskel::
    projection ()
    {
    }

    void cartographics_pskel::
    coordinates ()
    {
    }

    void cartographics_pskel::
    post_cartographics ()
    {
    }

    // type3_pskel
    //

    void type3_pskel::
    post_type3 ()
    {
    }

    // invalid_pskel
    //

    void invalid_pskel::
    post_invalid ()
    {
    }

    // physicalLocation_pskel
    //

    void physicalLocation_pskel::
    displayLabel ()
    {
    }

    void physicalLocation_pskel::
    post_physicalLocation ()
    {
      post_sourceType ();
    }

    // url_pskel
    //

    void url_pskel::
    dateLastAccessed ()
    {
    }

    void url_pskel::
    displayLabel ()
    {
    }

    void url_pskel::
    post_url ()
    {
    }

    // recordIdentifier_pskel
    //

    void recordIdentifier_pskel::
    source ()
    {
    }

    void recordIdentifier_pskel::
    post_recordIdentifier ()
    {
    }

    // encoding_pskel
    //

    void encoding_pskel::
    post_encoding ()
    {
    }

    // qualifier_pskel
    //

    void qualifier_pskel::
    post_qualifier ()
    {
    }

    // point_pskel
    //

    void point_pskel::
    post_point ()
    {
    }

    // keyDate_pskel
    //

    void keyDate_pskel::
    post_keyDate ()
    {
    }

    // authority_pskel
    //

    void authority_pskel::
    post_authority ()
    {
    }
  }
}

#include <cassert>

namespace mods
{
  namespace v3
  {
    // Element validation and dispatch functions for modsType_pskel.
    //
    bool modsType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "titleInfo" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "name" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "typeOfResource" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "genre" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "originInfo" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;
          else if (n == "language" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 5UL;
          else if (n == "physicalDescription" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 6UL;
          else if (n == "abstract" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 7UL;
          else if (n == "tableOfContents" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 8UL;
          else if (n == "targetAudience" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 9UL;
          else if (n == "note" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 10UL;
          else if (n == "subject" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 11UL;
          else if (n == "classification" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 12UL;
          else if (n == "relatedItem" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 13UL;
          else if (n == "identifier" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 14UL;
          else if (n == "location" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 15UL;
          else if (n == "accessCondition" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 16UL;
          else if (n == "extension" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 17UL;
          else if (n == "recordInfo" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 18UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &modsType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "titleInfo",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool modsType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void modsType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void modsType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "titleInfo");

      this->v_state_stack_.pop ();
    }

    void modsType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->titleInfo_parser_;

            if (this->titleInfo_parser_)
              this->titleInfo_parser_->pre ();
          }
          else
          {
            if (this->titleInfo_parser_)
            {
              this->titleInfo_parser_->post_titleInfoType ();
              this->titleInfo ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

            if (this->name_parser_)
              this->name_parser_->pre ();
          }
          else
          {
            if (this->name_parser_)
            {
              this->name_parser_->post_nameType ();
              this->name ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->typeOfResource_parser_;

            if (this->typeOfResource_parser_)
              this->typeOfResource_parser_->pre ();
          }
          else
          {
            if (this->typeOfResource_parser_)
            {
              this->typeOfResource_parser_->post_typeOfResourceType ();
              this->typeOfResource ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->genre_parser_;

            if (this->genre_parser_)
              this->genre_parser_->pre ();
          }
          else
          {
            if (this->genre_parser_)
            {
              this->genre_parser_->post_genreType ();
              this->genre ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->originInfo_parser_;

            if (this->originInfo_parser_)
              this->originInfo_parser_->pre ();
          }
          else
          {
            if (this->originInfo_parser_)
            {
              this->originInfo_parser_->post_originInfoType ();
              this->originInfo ();
            }

            state = ~0UL;
          }

          break;
        }
        case 5UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->language_parser_;

            if (this->language_parser_)
              this->language_parser_->pre ();
          }
          else
          {
            if (this->language_parser_)
            {
              this->language_parser_->post_languageType ();
              this->language ();
            }

            state = ~0UL;
          }

          break;
        }
        case 6UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->physicalDescription_parser_;

            if (this->physicalDescription_parser_)
              this->physicalDescription_parser_->pre ();
          }
          else
          {
            if (this->physicalDescription_parser_)
            {
              this->physicalDescription_parser_->post_physicalDescriptionType ();
              this->physicalDescription ();
            }

            state = ~0UL;
          }

          break;
        }
        case 7UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->abstract_parser_;

            if (this->abstract_parser_)
              this->abstract_parser_->pre ();
          }
          else
          {
            if (this->abstract_parser_)
            {
              this->abstract_parser_->post_unstructuredText ();
              this->abstract ();
            }

            state = ~0UL;
          }

          break;
        }
        case 8UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->tableOfContents_parser_;

            if (this->tableOfContents_parser_)
              this->tableOfContents_parser_->pre ();
          }
          else
          {
            if (this->tableOfContents_parser_)
            {
              this->tableOfContents_parser_->post_unstructuredText ();
              this->tableOfContents ();
            }

            state = ~0UL;
          }

          break;
        }
        case 9UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->targetAudience_parser_;

            if (this->targetAudience_parser_)
              this->targetAudience_parser_->pre ();
          }
          else
          {
            if (this->targetAudience_parser_)
            {
              this->targetAudience_parser_->post_targetAudienceType ();
              this->targetAudience ();
            }

            state = ~0UL;
          }

          break;
        }
        case 10UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->note_parser_;

            if (this->note_parser_)
              this->note_parser_->pre ();
          }
          else
          {
            if (this->note_parser_)
            {
              this->note_parser_->post_unstructuredText ();
              this->note ();
            }

            state = ~0UL;
          }

          break;
        }
        case 11UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->subject_parser_;

            if (this->subject_parser_)
              this->subject_parser_->pre ();
          }
          else
          {
            if (this->subject_parser_)
            {
              this->subject_parser_->post_subjectType ();
              this->subject ();
            }

            state = ~0UL;
          }

          break;
        }
        case 12UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->classification_parser_;

            if (this->classification_parser_)
              this->classification_parser_->pre ();
          }
          else
          {
            if (this->classification_parser_)
            {
              this->classification_parser_->post_classificationType ();
              this->classification ();
            }

            state = ~0UL;
          }

          break;
        }
        case 13UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->relatedItem_parser_;

            if (this->relatedItem_parser_)
              this->relatedItem_parser_->pre ();
          }
          else
          {
            if (this->relatedItem_parser_)
            {
              this->relatedItem_parser_->post_relatedItemType ();
              this->relatedItem ();
            }

            state = ~0UL;
          }

          break;
        }
        case 14UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->identifier_parser_;

            if (this->identifier_parser_)
              this->identifier_parser_->pre ();
          }
          else
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->post_identifierType ();
              this->identifier ();
            }

            state = ~0UL;
          }

          break;
        }
        case 15UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

            if (this->location_parser_)
              this->location_parser_->pre ();
          }
          else
          {
            if (this->location_parser_)
            {
              this->location_parser_->post_locationType ();
              this->location ();
            }

            state = ~0UL;
          }

          break;
        }
        case 16UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->accessCondition_parser_;

            if (this->accessCondition_parser_)
              this->accessCondition_parser_->pre ();
          }
          else
          {
            if (this->accessCondition_parser_)
            {
              this->accessCondition_parser_->post_unstructuredText ();
              this->accessCondition ();
            }

            state = ~0UL;
          }

          break;
        }
        case 17UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->extension_parser_;

            if (this->extension_parser_)
              this->extension_parser_->pre ();
          }
          else
          {
            if (this->extension_parser_)
            {
              this->extension_parser_->post_extensionType ();
              this->extension ();
            }

            state = ~0UL;
          }

          break;
        }
        case 18UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->recordInfo_parser_;

            if (this->recordInfo_parser_)
              this->recordInfo_parser_->pre ();
          }
          else
          {
            if (this->recordInfo_parser_)
            {
              this->recordInfo_parser_->post_recordInfoType ();
              this->recordInfo ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for titleInfoType_pskel.
    //
    bool titleInfoType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "title" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "subTitle" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "partNumber" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "partName" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "nonSort" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &titleInfoType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "title",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool titleInfoType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void titleInfoType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void titleInfoType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "title");

      this->v_state_stack_.pop ();
    }

    void titleInfoType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->title_parser_;

            if (this->title_parser_)
              this->title_parser_->pre ();
          }
          else
          {
            if (this->title_parser_)
            {
              this->title_parser_->post_any_type ();
              this->title ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->subTitle_parser_;

            if (this->subTitle_parser_)
              this->subTitle_parser_->pre ();
          }
          else
          {
            if (this->subTitle_parser_)
            {
              this->subTitle_parser_->post_any_type ();
              this->subTitle ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->partNumber_parser_;

            if (this->partNumber_parser_)
              this->partNumber_parser_->pre ();
          }
          else
          {
            if (this->partNumber_parser_)
            {
              this->partNumber_parser_->post_any_type ();
              this->partNumber ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->partName_parser_;

            if (this->partName_parser_)
              this->partName_parser_->pre ();
          }
          else
          {
            if (this->partName_parser_)
            {
              this->partName_parser_->post_any_type ();
              this->partName ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->nonSort_parser_;

            if (this->nonSort_parser_)
              this->nonSort_parser_->pre ();
          }
          else
          {
            if (this->nonSort_parser_)
            {
              this->nonSort_parser_->post_any_type ();
              this->nonSort ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for nameType_pskel.
    //
    bool nameType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "namePart" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "displayForm" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "affiliation" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "role" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "description" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &nameType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "namePart",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool nameType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void nameType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void nameType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "namePart");

      this->v_state_stack_.pop ();
    }

    void nameType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->namePart_parser_;

            if (this->namePart_parser_)
              this->namePart_parser_->pre ();
          }
          else
          {
            if (this->namePart_parser_)
            {
              this->namePart_parser_->post_namePartType ();
              this->namePart ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->displayForm_parser_;

            if (this->displayForm_parser_)
              this->displayForm_parser_->pre ();
          }
          else
          {
            if (this->displayForm_parser_)
            {
              this->displayForm_parser_->post_any_type ();
              this->displayForm ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->affiliation_parser_;

            if (this->affiliation_parser_)
              this->affiliation_parser_->pre ();
          }
          else
          {
            if (this->affiliation_parser_)
            {
              this->affiliation_parser_->post_any_type ();
              this->affiliation ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->role_parser_;

            if (this->role_parser_)
              this->role_parser_->pre ();
          }
          else
          {
            if (this->role_parser_)
            {
              this->role_parser_->post_roleType ();
              this->role ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              this->description_parser_->post_any_type ();
              this->description ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for roleType_pskel.
    //
    bool roleType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "roleTerm" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &roleType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "roleTerm",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool roleType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void roleType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void roleType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "roleTerm");

      this->v_state_stack_.pop ();
    }

    void roleType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "roleTerm" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->roleTerm_parser_;

              if (this->roleTerm_parser_)
                this->roleTerm_parser_->pre ();
            }
            else
            {
              if (this->roleTerm_parser_)
              {
                this->roleTerm_parser_->post_roleTerm ();
                this->roleTerm ();
              }

              count = 0;
              state = ~0UL;
            }

            break;
          }
          else
          {
            assert (start);
            if (count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "roleTerm",
                ns, n);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for originInfoType_pskel.
    //
    bool originInfoType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "place" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "publisher" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "dateIssued" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "dateCreated" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "dateCaptured" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;
          else if (n == "dateValid" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 5UL;
          else if (n == "dateModified" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 6UL;
          else if (n == "copyrightDate" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 7UL;
          else if (n == "dateOther" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 8UL;
          else if (n == "edition" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 9UL;
          else if (n == "issuance" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 10UL;
          else if (n == "frequency" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 11UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &originInfoType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "place",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool originInfoType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void originInfoType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void originInfoType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "place");

      this->v_state_stack_.pop ();
    }

    void originInfoType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->place_parser_;

            if (this->place_parser_)
              this->place_parser_->pre ();
          }
          else
          {
            if (this->place_parser_)
            {
              this->place_parser_->post_placeType ();
              this->place ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->publisher_parser_;

            if (this->publisher_parser_)
              this->publisher_parser_->pre ();
          }
          else
          {
            if (this->publisher_parser_)
            {
              this->publisher_parser_->post_any_type ();
              this->publisher ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dateIssued_parser_;

            if (this->dateIssued_parser_)
              this->dateIssued_parser_->pre ();
          }
          else
          {
            if (this->dateIssued_parser_)
            {
              this->dateIssued_parser_->post_dateType ();
              this->dateIssued ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dateCreated_parser_;

            if (this->dateCreated_parser_)
              this->dateCreated_parser_->pre ();
          }
          else
          {
            if (this->dateCreated_parser_)
            {
              this->dateCreated_parser_->post_dateType ();
              this->dateCreated ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dateCaptured_parser_;

            if (this->dateCaptured_parser_)
              this->dateCaptured_parser_->pre ();
          }
          else
          {
            if (this->dateCaptured_parser_)
            {
              this->dateCaptured_parser_->post_dateType ();
              this->dateCaptured ();
            }

            state = ~0UL;
          }

          break;
        }
        case 5UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dateValid_parser_;

            if (this->dateValid_parser_)
              this->dateValid_parser_->pre ();
          }
          else
          {
            if (this->dateValid_parser_)
            {
              this->dateValid_parser_->post_dateType ();
              this->dateValid ();
            }

            state = ~0UL;
          }

          break;
        }
        case 6UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dateModified_parser_;

            if (this->dateModified_parser_)
              this->dateModified_parser_->pre ();
          }
          else
          {
            if (this->dateModified_parser_)
            {
              this->dateModified_parser_->post_dateType ();
              this->dateModified ();
            }

            state = ~0UL;
          }

          break;
        }
        case 7UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->copyrightDate_parser_;

            if (this->copyrightDate_parser_)
              this->copyrightDate_parser_->pre ();
          }
          else
          {
            if (this->copyrightDate_parser_)
            {
              this->copyrightDate_parser_->post_dateType ();
              this->copyrightDate ();
            }

            state = ~0UL;
          }

          break;
        }
        case 8UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dateOther_parser_;

            if (this->dateOther_parser_)
              this->dateOther_parser_->pre ();
          }
          else
          {
            if (this->dateOther_parser_)
            {
              this->dateOther_parser_->post_dateType ();
              this->dateOther ();
            }

            state = ~0UL;
          }

          break;
        }
        case 9UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->edition_parser_;

            if (this->edition_parser_)
              this->edition_parser_->pre ();
          }
          else
          {
            if (this->edition_parser_)
            {
              this->edition_parser_->post_any_type ();
              this->edition ();
            }

            state = ~0UL;
          }

          break;
        }
        case 10UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->issuance_parser_;

            if (this->issuance_parser_)
              this->issuance_parser_->pre ();
          }
          else
          {
            if (this->issuance_parser_)
            {
              this->issuance_parser_->post_issuance ();
              this->issuance ();
            }

            state = ~0UL;
          }

          break;
        }
        case 11UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->frequency_parser_;

            if (this->frequency_parser_)
              this->frequency_parser_->pre ();
          }
          else
          {
            if (this->frequency_parser_)
            {
              this->frequency_parser_->post_any_type ();
              this->frequency ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for placeType_pskel.
    //
    bool placeType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "placeTerm" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &placeType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "placeTerm",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool placeType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void placeType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void placeType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "placeTerm");

      this->v_state_stack_.pop ();
    }

    void placeType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "placeTerm" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->placeTerm_parser_;

              if (this->placeTerm_parser_)
                this->placeTerm_parser_->pre ();
            }
            else
            {
              if (this->placeTerm_parser_)
              {
                this->placeTerm_parser_->post_placeTermType ();
                this->placeTerm ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            if (count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "placeTerm",
                ns, n);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for languageType_pskel.
    //
    bool languageType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "languageTerm" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &languageType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "languageTerm",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool languageType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void languageType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void languageType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "languageTerm");

      this->v_state_stack_.pop ();
    }

    void languageType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "languageTerm" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->languageTerm_parser_;

              if (this->languageTerm_parser_)
                this->languageTerm_parser_->pre ();
            }
            else
            {
              if (this->languageTerm_parser_)
              {
                this->languageTerm_parser_->post_languageTerm ();
                this->languageTerm ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            if (count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "languageTerm",
                ns, n);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for physicalDescriptionType_pskel.
    //
    bool physicalDescriptionType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "form" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "reformattingQuality" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "internetMediaType" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "extent" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "digitalOrigin" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;
          else if (n == "note" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 5UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &physicalDescriptionType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "form",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool physicalDescriptionType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void physicalDescriptionType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void physicalDescriptionType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "form");

      this->v_state_stack_.pop ();
    }

    void physicalDescriptionType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->form_parser_;

            if (this->form_parser_)
              this->form_parser_->pre ();
          }
          else
          {
            if (this->form_parser_)
            {
              this->form_parser_->post_form ();
              this->form ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->reformattingQuality_parser_;

            if (this->reformattingQuality_parser_)
              this->reformattingQuality_parser_->pre ();
          }
          else
          {
            if (this->reformattingQuality_parser_)
            {
              this->reformattingQuality_parser_->post_reformattingQuality ();
              this->reformattingQuality ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->internetMediaType_parser_;

            if (this->internetMediaType_parser_)
              this->internetMediaType_parser_->pre ();
          }
          else
          {
            if (this->internetMediaType_parser_)
            {
              this->internetMediaType_parser_->post_any_type ();
              this->internetMediaType ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->extent_parser_;

            if (this->extent_parser_)
              this->extent_parser_->pre ();
          }
          else
          {
            if (this->extent_parser_)
            {
              this->extent_parser_->post_any_type ();
              this->extent ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->digitalOrigin_parser_;

            if (this->digitalOrigin_parser_)
              this->digitalOrigin_parser_->pre ();
          }
          else
          {
            if (this->digitalOrigin_parser_)
            {
              this->digitalOrigin_parser_->post_digitalOrigin ();
              this->digitalOrigin ();
            }

            state = ~0UL;
          }

          break;
        }
        case 5UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->note_parser_;

            if (this->note_parser_)
              this->note_parser_->pre ();
          }
          else
          {
            if (this->note_parser_)
            {
              this->note_parser_->post_unstructuredText ();
              this->note ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for subjectType_pskel.
    //
    bool subjectType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "topic" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "geographic" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "temporal" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "titleInfo" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "name" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;
          else if (n == "geographicCode" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 5UL;
          else if (n == "hierarchicalGeographic" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 6UL;
          else if (n == "cartographics" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 7UL;
          else if (n == "occupation" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 8UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &subjectType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "topic",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool subjectType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void subjectType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void subjectType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "topic");

      this->v_state_stack_.pop ();
    }

    void subjectType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->topic_parser_;

            if (this->topic_parser_)
              this->topic_parser_->pre ();
          }
          else
          {
            if (this->topic_parser_)
            {
              this->topic_parser_->post_any_type ();
              this->topic ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->geographic_parser_;

            if (this->geographic_parser_)
              this->geographic_parser_->pre ();
          }
          else
          {
            if (this->geographic_parser_)
            {
              this->geographic_parser_->post_any_type ();
              this->geographic ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->temporal_parser_;

            if (this->temporal_parser_)
              this->temporal_parser_->pre ();
          }
          else
          {
            if (this->temporal_parser_)
            {
              this->temporal_parser_->post_dateType ();
              this->temporal ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->titleInfo_parser_;

            if (this->titleInfo_parser_)
              this->titleInfo_parser_->pre ();
          }
          else
          {
            if (this->titleInfo_parser_)
            {
              this->titleInfo_parser_->post_titleInfoType ();
              this->titleInfo ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

            if (this->name_parser_)
              this->name_parser_->pre ();
          }
          else
          {
            if (this->name_parser_)
            {
              this->name_parser_->post_nameType ();
              this->name ();
            }

            state = ~0UL;
          }

          break;
        }
        case 5UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->geographicCode_parser_;

            if (this->geographicCode_parser_)
              this->geographicCode_parser_->pre ();
          }
          else
          {
            if (this->geographicCode_parser_)
            {
              this->geographicCode_parser_->post_geographicCode ();
              this->geographicCode ();
            }

            state = ~0UL;
          }

          break;
        }
        case 6UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->hierarchicalGeographic_parser_;

            if (this->hierarchicalGeographic_parser_)
              this->hierarchicalGeographic_parser_->pre ();
          }
          else
          {
            if (this->hierarchicalGeographic_parser_)
            {
              this->hierarchicalGeographic_parser_->post_hierarchicalGeographic ();
              this->hierarchicalGeographic ();
            }

            state = ~0UL;
          }

          break;
        }
        case 7UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->cartographics_parser_;

            if (this->cartographics_parser_)
              this->cartographics_parser_->pre ();
          }
          else
          {
            if (this->cartographics_parser_)
            {
              this->cartographics_parser_->post_cartographics ();
              this->cartographics ();
            }

            state = ~0UL;
          }

          break;
        }
        case 8UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->occupation_parser_;

            if (this->occupation_parser_)
              this->occupation_parser_->pre ();
          }
          else
          {
            if (this->occupation_parser_)
            {
              this->occupation_parser_->post_any_type ();
              this->occupation ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for relatedItemType_pskel.
    //
    bool relatedItemType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::mods::v3::modsType_pskel::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "part" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &relatedItemType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool relatedItemType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::mods::v3::modsType_pskel::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void relatedItemType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;

      ::mods::v3::modsType_pskel::_pre_e_validate ();
    }

    void relatedItemType_pskel::
    _post_e_validate ()
    {
      ::mods::v3::modsType_pskel::_post_e_validate ();

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }


      this->v_state_stack_.pop ();
    }

    void relatedItemType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "part" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->part_parser_;

              if (this->part_parser_)
                this->part_parser_->pre ();
            }
            else
            {
              if (this->part_parser_)
              {
                this->part_parser_->post_partType ();
                this->part ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for partType_pskel.
    //
    bool partType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "detail" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "extent" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "date" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "text" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &partType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "detail",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool partType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void partType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void partType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "detail");

      this->v_state_stack_.pop ();
    }

    void partType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->detail_parser_;

            if (this->detail_parser_)
              this->detail_parser_->pre ();
          }
          else
          {
            if (this->detail_parser_)
            {
              this->detail_parser_->post_detailType ();
              this->detail ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->extent_parser_;

            if (this->extent_parser_)
              this->extent_parser_->pre ();
          }
          else
          {
            if (this->extent_parser_)
            {
              this->extent_parser_->post_extentType ();
              this->extent ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->date_parser_;

            if (this->date_parser_)
              this->date_parser_->pre ();
          }
          else
          {
            if (this->date_parser_)
            {
              this->date_parser_->post_baseDateType ();
              this->date ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->text_parser_;

            if (this->text_parser_)
              this->text_parser_->pre ();
          }
          else
          {
            if (this->text_parser_)
            {
              this->text_parser_->post_unstructuredText ();
              this->text ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for detailType_pskel.
    //
    bool detailType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "number" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "caption" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "title" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &detailType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "number",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool detailType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void detailType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void detailType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "number");

      this->v_state_stack_.pop ();
    }

    void detailType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->number_parser_;

            if (this->number_parser_)
              this->number_parser_->pre ();
          }
          else
          {
            if (this->number_parser_)
            {
              this->number_parser_->post_any_type ();
              this->number ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->caption_parser_;

            if (this->caption_parser_)
              this->caption_parser_->pre ();
          }
          else
          {
            if (this->caption_parser_)
            {
              this->caption_parser_->post_any_type ();
              this->caption ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->title_parser_;

            if (this->title_parser_)
              this->title_parser_->pre ();
          }
          else
          {
            if (this->title_parser_)
            {
              this->title_parser_->post_any_type ();
              this->title ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for extentType_pskel.
    //
    bool extentType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "start" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "end" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "total" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "list" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &extentType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool extentType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void extentType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void extentType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }


      this->v_state_stack_.pop ();
    }

    void extentType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "start" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->start_parser_;

              if (this->start_parser_)
                this->start_parser_->pre ();
            }
            else
            {
              if (this->start_parser_)
              {
                this->start_parser_->post_any_type ();
                this->start ();
              }

              count = 0;
              state = 1UL;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = 1UL;
            // Fall through.
          }
        }
        case 1UL:
        {
          if (n == "end" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->end_parser_;

              if (this->end_parser_)
                this->end_parser_->pre ();
            }
            else
            {
              if (this->end_parser_)
              {
                this->end_parser_->post_any_type ();
                this->end ();
              }

              count = 0;
              state = 2UL;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = 2UL;
            // Fall through.
          }
        }
        case 2UL:
        {
          if (n == "total" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->total_parser_;

              if (this->total_parser_)
                this->total_parser_->pre ();
            }
            else
            {
              if (this->total_parser_)
              {
                unsigned long long tmp (this->total_parser_->post_positive_integer ());
                this->total (tmp);
              }

              count = 0;
              state = 3UL;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = 3UL;
            // Fall through.
          }
        }
        case 3UL:
        {
          if (n == "list" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->list_parser_;

              if (this->list_parser_)
                this->list_parser_->pre ();
            }
            else
            {
              if (this->list_parser_)
              {
                this->list_parser_->post_any_type ();
                this->list ();
              }

              count = 0;
              state = ~0UL;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for locationType_pskel.
    //
    bool locationType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "physicalLocation" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "url" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &locationType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool locationType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void locationType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void locationType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }


      this->v_state_stack_.pop ();
    }

    void locationType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "physicalLocation" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->physicalLocation_parser_;

              if (this->physicalLocation_parser_)
                this->physicalLocation_parser_->pre ();
            }
            else
            {
              if (this->physicalLocation_parser_)
              {
                this->physicalLocation_parser_->post_physicalLocation ();
                this->physicalLocation ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = 1UL;
            // Fall through.
          }
        }
        case 1UL:
        {
          if (n == "url" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->url_parser_;

              if (this->url_parser_)
                this->url_parser_->pre ();
            }
            else
            {
              if (this->url_parser_)
              {
                this->url_parser_->post_url ();
                this->url ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for extensionType_pskel.
    //
    bool extensionType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (!n.empty ())
            s = 0UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &extensionType_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "##any", "*",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool extensionType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void extensionType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void extensionType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "##any", "*");

      this->v_state_stack_.pop ();
    }

    void extensionType_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (!n.empty ())
          {
            if (start)
            {
              this->_start_any_element (ns, n, t);
              this->::xml_schema::complex_content::context_.top ().any_ = true;
            }
            else
            {
              this->::xml_schema::complex_content::context_.top ().any_ = false;
              this->_end_any_element (ns, n);
              count++;
            }

            break;
          }
          else
          {
            assert (start);
            if (count < 1UL)
              this->_expected_element (
                "##any", "*",
                ns, n);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for recordInfoType_pskel.
    //
    bool recordInfoType_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "recordContentSource" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "recordCreationDate" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "recordChangeDate" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "recordIdentifier" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "languageOfCataloging" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;
          else if (n == "recordOrigin" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 5UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &recordInfoType_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "recordContentSource",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool recordInfoType_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void recordInfoType_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void recordInfoType_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "recordContentSource");

      this->v_state_stack_.pop ();
    }

    void recordInfoType_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->recordContentSource_parser_;

            if (this->recordContentSource_parser_)
              this->recordContentSource_parser_->pre ();
          }
          else
          {
            if (this->recordContentSource_parser_)
            {
              this->recordContentSource_parser_->post_sourceType ();
              this->recordContentSource ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->recordCreationDate_parser_;

            if (this->recordCreationDate_parser_)
              this->recordCreationDate_parser_->pre ();
          }
          else
          {
            if (this->recordCreationDate_parser_)
            {
              this->recordCreationDate_parser_->post_dateType ();
              this->recordCreationDate ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->recordChangeDate_parser_;

            if (this->recordChangeDate_parser_)
              this->recordChangeDate_parser_->pre ();
          }
          else
          {
            if (this->recordChangeDate_parser_)
            {
              this->recordChangeDate_parser_->post_dateType ();
              this->recordChangeDate ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->recordIdentifier_parser_;

            if (this->recordIdentifier_parser_)
              this->recordIdentifier_parser_->pre ();
          }
          else
          {
            if (this->recordIdentifier_parser_)
            {
              this->recordIdentifier_parser_->post_recordIdentifier ();
              this->recordIdentifier ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->languageOfCataloging_parser_;

            if (this->languageOfCataloging_parser_)
              this->languageOfCataloging_parser_->pre ();
          }
          else
          {
            if (this->languageOfCataloging_parser_)
            {
              this->languageOfCataloging_parser_->post_languageType ();
              this->languageOfCataloging ();
            }

            state = ~0UL;
          }

          break;
        }
        case 5UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->recordOrigin_parser_;

            if (this->recordOrigin_parser_)
              this->recordOrigin_parser_->pre ();
          }
          else
          {
            if (this->recordOrigin_parser_)
            {
              this->recordOrigin_parser_->post_any_type ();
              this->recordOrigin ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for modsCollection_pskel.
    //
    bool modsCollection_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "mods" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &modsCollection_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "mods",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool modsCollection_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void modsCollection_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void modsCollection_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "mods");

      this->v_state_stack_.pop ();
    }

    void modsCollection_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "mods" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->mods_parser_;

              if (this->mods_parser_)
                this->mods_parser_->pre ();
            }
            else
            {
              if (this->mods_parser_)
              {
                this->mods_parser_->post_modsType ();
                this->mods ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            if (count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "mods",
                ns, n);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }

    // Element validation and dispatch functions for hierarchicalGeographic_pskel.
    //
    bool hierarchicalGeographic_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "continent" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "country" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "province" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;
          else if (n == "region" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 3UL;
          else if (n == "state" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 4UL;
          else if (n == "territory" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 5UL;
          else if (n == "county" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 6UL;
          else if (n == "city" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 7UL;
          else if (n == "island" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 8UL;
          else if (n == "area" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 9UL;

          if (s != ~0UL)
          {
            vd->count++;

            vd = vs.data + vs.size++;
            vd->func = &hierarchicalGeographic_pskel::choice_0;
            vd->state = s;
            vd->count = 0;

            this->choice_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "continent",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool hierarchicalGeographic_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void hierarchicalGeographic_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void hierarchicalGeographic_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "continent");

      this->v_state_stack_.pop ();
    }

    void hierarchicalGeographic_pskel::
    choice_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
    {
      XSD_UNUSED (count);
      XSD_UNUSED (ns);
      XSD_UNUSED (n);
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->continent_parser_;

            if (this->continent_parser_)
              this->continent_parser_->pre ();
          }
          else
          {
            if (this->continent_parser_)
            {
              this->continent_parser_->post_any_type ();
              this->continent ();
            }

            state = ~0UL;
          }

          break;
        }
        case 1UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->country_parser_;

            if (this->country_parser_)
              this->country_parser_->pre ();
          }
          else
          {
            if (this->country_parser_)
            {
              this->country_parser_->post_any_type ();
              this->country ();
            }

            state = ~0UL;
          }

          break;
        }
        case 2UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->province_parser_;

            if (this->province_parser_)
              this->province_parser_->pre ();
          }
          else
          {
            if (this->province_parser_)
            {
              this->province_parser_->post_any_type ();
              this->province ();
            }

            state = ~0UL;
          }

          break;
        }
        case 3UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->region_parser_;

            if (this->region_parser_)
              this->region_parser_->pre ();
          }
          else
          {
            if (this->region_parser_)
            {
              this->region_parser_->post_any_type ();
              this->region ();
            }

            state = ~0UL;
          }

          break;
        }
        case 4UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->state_parser_;

            if (this->state_parser_)
              this->state_parser_->pre ();
          }
          else
          {
            if (this->state_parser_)
            {
              this->state_parser_->post_any_type ();
              this->state ();
            }

            state = ~0UL;
          }

          break;
        }
        case 5UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->territory_parser_;

            if (this->territory_parser_)
              this->territory_parser_->pre ();
          }
          else
          {
            if (this->territory_parser_)
            {
              this->territory_parser_->post_any_type ();
              this->territory ();
            }

            state = ~0UL;
          }

          break;
        }
        case 6UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->county_parser_;

            if (this->county_parser_)
              this->county_parser_->pre ();
          }
          else
          {
            if (this->county_parser_)
            {
              this->county_parser_->post_any_type ();
              this->county ();
            }

            state = ~0UL;
          }

          break;
        }
        case 7UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->city_parser_;

            if (this->city_parser_)
              this->city_parser_->pre ();
          }
          else
          {
            if (this->city_parser_)
            {
              this->city_parser_->post_any_type ();
              this->city ();
            }

            state = ~0UL;
          }

          break;
        }
        case 8UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->island_parser_;

            if (this->island_parser_)
              this->island_parser_->pre ();
          }
          else
          {
            if (this->island_parser_)
            {
              this->island_parser_->post_any_type ();
              this->island ();
            }

            state = ~0UL;
          }

          break;
        }
        case 9UL:
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

            if (this->area_parser_)
              this->area_parser_->pre ();
          }
          else
          {
            if (this->area_parser_)
            {
              this->area_parser_->post_any_type ();
              this->area ();
            }

            state = ~0UL;
          }

          break;
        }
      }
    }

    // Element validation and dispatch functions for cartographics_pskel.
    //
    bool cartographics_pskel::
    _start_element_impl (const ::xml_schema::ro_string& ns,
                         const ::xml_schema::ro_string& n,
                         const ::xml_schema::ro_string* t)
    {
      XSD_UNUSED (t);

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      if (vd->func == 0 && vd->state == 0)
      {
        if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
          return true;
        else
          vd->state = 1;
      }

      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
          vd = vs.data + (--vs.size - 1);
        else
          break;
      }

      if (vd->func == 0)
      {
        if (vd->state != ~0UL)
        {
          unsigned long s = ~0UL;

          if (n == "scale" &&
              ns == "http://www.loc.gov/mods/v3")
            s = 0UL;
          else if (n == "projection" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 1UL;
          else if (n == "coordinates" &&
                   ns == "http://www.loc.gov/mods/v3")
            s = 2UL;

          if (s != ~0UL)
          {
            vd->count++;
            vd->state = ~0UL;

            vd = vs.data + vs.size++;
            vd->func = &cartographics_pskel::sequence_0;
            vd->state = s;
            vd->count = 0;

            this->sequence_0 (vd->state, vd->count, ns, n, t, true);
          }
          else
          {
            if (vd->count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "scale",
                ns, n);
            return false;
          }
        }
        else
          return false;
      }

      return true;
    }

    bool cartographics_pskel::
    _end_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n)
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size - 1];

      if (vd.func == 0 && vd.state == 0)
      {
        if (!::xml_schema::complex_content::_end_element_impl (ns, n))
          assert (false);
        return true;
      }

      assert (vd.func != 0);
      (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

      if (vd.state == ~0UL)
        vs.size--;

      return true;
    }

    void cartographics_pskel::
    _pre_e_validate ()
    {
      this->v_state_stack_.push ();
      static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_& vd = vs.data[vs.size++];

      vd.func = 0;
      vd.state = 0;
      vd.count = 0;
    }

    void cartographics_pskel::
    _post_e_validate ()
    {
      v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
      v_state_descr_* vd = vs.data + (vs.size - 1);

      ::xml_schema::ro_string empty;
      while (vd->func != 0)
      {
        (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
        assert (vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
      }

      if (vd->count < 1UL)
        this->_expected_element (
          "http://www.loc.gov/mods/v3", "scale");

      this->v_state_stack_.pop ();
    }

    void cartographics_pskel::
    sequence_0 (unsigned long& state,
                unsigned long& count,
                const ::xml_schema::ro_string& ns,
                const ::xml_schema::ro_string& n,
                const ::xml_schema::ro_string* t,
                bool start)
    {
      XSD_UNUSED (t);

      switch (state)
      {
        case 0UL:
        {
          if (n == "scale" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->scale_parser_;

              if (this->scale_parser_)
                this->scale_parser_->pre ();
            }
            else
            {
              if (this->scale_parser_)
              {
                this->scale_parser_->post_any_type ();
                this->scale ();
              }

              count = 0;
              state = 1UL;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = 1UL;
            // Fall through.
          }
        }
        case 1UL:
        {
          if (n == "projection" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->projection_parser_;

              if (this->projection_parser_)
                this->projection_parser_->pre ();
            }
            else
            {
              if (this->projection_parser_)
              {
                this->projection_parser_->post_any_type ();
                this->projection ();
              }

              count = 0;
              state = 2UL;
            }

            break;
          }
          else
          {
            assert (start);
            count = 0;
            state = 2UL;
            // Fall through.
          }
        }
        case 2UL:
        {
          if (n == "coordinates" &&
              ns == "http://www.loc.gov/mods/v3")
          {
            if (start)
            {
              this->::xml_schema::complex_content::context_.top ().parser_ = this->coordinates_parser_;

              if (this->coordinates_parser_)
                this->coordinates_parser_->pre ();
            }
            else
            {
              if (this->coordinates_parser_)
              {
                this->coordinates_parser_->post_any_type ();
                this->coordinates ();
              }

              count++;
            }

            break;
          }
          else
          {
            assert (start);
            if (count < 1UL)
              this->_expected_element (
                "http://www.loc.gov/mods/v3", "coordinates",
                ns, n);
            count = 0;
            state = ~0UL;
            // Fall through.
          }
        }
        case ~0UL:
          break;
      }
    }
  }
}

namespace mods
{
  namespace v3
  {
    // Attribute validation and dispatch functions for modsType_pskel.
    //
    bool modsType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "ID" && ns.empty ())
      {
        if (this->ID_parser_)
        {
          this->ID_parser_->pre ();
          this->ID_parser_->_pre_impl ();
          this->ID_parser_->_characters (s);
          this->ID_parser_->_post_impl ();
          const ::std::string& tmp (this->ID_parser_->post_id ());
          this->ID (tmp);
        }

        return true;
      }

      if (n == "version" && ns.empty ())
      {
        if (this->version_parser_)
        {
          this->version_parser_->pre ();
          this->version_parser_->_pre_impl ();
          this->version_parser_->_characters (s);
          this->version_parser_->_post_impl ();
          this->version_parser_->post_version ();
          this->version ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for titleInfoType_pskel.
    //
    bool titleInfoType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "ID" && ns.empty ())
      {
        if (this->ID_parser_)
        {
          this->ID_parser_->pre ();
          this->ID_parser_->_pre_impl ();
          this->ID_parser_->_characters (s);
          this->ID_parser_->_post_impl ();
          const ::std::string& tmp (this->ID_parser_->post_id ());
          this->ID (tmp);
        }

        return true;
      }

      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_type ();
          this->type ();
        }

        return true;
      }

      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "displayLabel" && ns.empty ())
      {
        if (this->displayLabel_parser_)
        {
          this->displayLabel_parser_->pre ();
          this->displayLabel_parser_->_pre_impl ();
          this->displayLabel_parser_->_characters (s);
          this->displayLabel_parser_->_post_impl ();
          const ::std::string& tmp (this->displayLabel_parser_->post_string ());
          this->displayLabel (tmp);
        }

        return true;
      }

      if (n == "type" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->type1_parser_)
        {
          this->type1_parser_->pre ();
          this->type1_parser_->_pre_impl ();
          this->type1_parser_->_characters (s);
          this->type1_parser_->_post_impl ();
          const ::std::string& tmp (this->type1_parser_->post_string ());
          this->type1 (tmp);
        }

        return true;
      }

      if (n == "href" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->href_parser_)
        {
          this->href_parser_->pre ();
          this->href_parser_->_pre_impl ();
          this->href_parser_->_characters (s);
          this->href_parser_->_post_impl ();
          const ::std::string& tmp (this->href_parser_->post_uri ());
          this->href (tmp);
        }

        return true;
      }

      if (n == "role" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->role_parser_)
        {
          this->role_parser_->pre ();
          this->role_parser_->_pre_impl ();
          this->role_parser_->_characters (s);
          this->role_parser_->_post_impl ();
          const ::std::string& tmp (this->role_parser_->post_string ());
          this->role (tmp);
        }

        return true;
      }

      if (n == "arcrole" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->arcrole_parser_)
        {
          this->arcrole_parser_->pre ();
          this->arcrole_parser_->_pre_impl ();
          this->arcrole_parser_->_characters (s);
          this->arcrole_parser_->_post_impl ();
          const ::std::string& tmp (this->arcrole_parser_->post_string ());
          this->arcrole (tmp);
        }

        return true;
      }

      if (n == "title" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->title1_parser_)
        {
          this->title1_parser_->pre ();
          this->title1_parser_->_pre_impl ();
          this->title1_parser_->_characters (s);
          this->title1_parser_->_post_impl ();
          const ::std::string& tmp (this->title1_parser_->post_string ());
          this->title1 (tmp);
        }

        return true;
      }

      if (n == "show" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->show_parser_)
        {
          this->show_parser_->pre ();
          this->show_parser_->_pre_impl ();
          this->show_parser_->_characters (s);
          this->show_parser_->_post_impl ();
          this->show_parser_->post_show ();
          this->show ();
        }

        return true;
      }

      if (n == "actuate" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->actuate_parser_)
        {
          this->actuate_parser_->pre ();
          this->actuate_parser_->_pre_impl ();
          this->actuate_parser_->_characters (s);
          this->actuate_parser_->_post_impl ();
          this->actuate_parser_->post_actuate ();
          this->actuate ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for nameType_pskel.
    //
    bool nameType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "ID" && ns.empty ())
      {
        if (this->ID_parser_)
        {
          this->ID_parser_->pre ();
          this->ID_parser_->_pre_impl ();
          this->ID_parser_->_characters (s);
          this->ID_parser_->_post_impl ();
          const ::std::string& tmp (this->ID_parser_->post_id ());
          this->ID (tmp);
        }

        return true;
      }

      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_type1 ();
          this->type ();
        }

        return true;
      }

      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "type" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->type1_parser_)
        {
          this->type1_parser_->pre ();
          this->type1_parser_->_pre_impl ();
          this->type1_parser_->_characters (s);
          this->type1_parser_->_post_impl ();
          const ::std::string& tmp (this->type1_parser_->post_string ());
          this->type1 (tmp);
        }

        return true;
      }

      if (n == "href" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->href_parser_)
        {
          this->href_parser_->pre ();
          this->href_parser_->_pre_impl ();
          this->href_parser_->_characters (s);
          this->href_parser_->_post_impl ();
          const ::std::string& tmp (this->href_parser_->post_uri ());
          this->href (tmp);
        }

        return true;
      }

      if (n == "role" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->role1_parser_)
        {
          this->role1_parser_->pre ();
          this->role1_parser_->_pre_impl ();
          this->role1_parser_->_characters (s);
          this->role1_parser_->_post_impl ();
          const ::std::string& tmp (this->role1_parser_->post_string ());
          this->role1 (tmp);
        }

        return true;
      }

      if (n == "arcrole" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->arcrole_parser_)
        {
          this->arcrole_parser_->pre ();
          this->arcrole_parser_->_pre_impl ();
          this->arcrole_parser_->_characters (s);
          this->arcrole_parser_->_post_impl ();
          const ::std::string& tmp (this->arcrole_parser_->post_string ());
          this->arcrole (tmp);
        }

        return true;
      }

      if (n == "title" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->title_parser_)
        {
          this->title_parser_->pre ();
          this->title_parser_->_pre_impl ();
          this->title_parser_->_characters (s);
          this->title_parser_->_post_impl ();
          const ::std::string& tmp (this->title_parser_->post_string ());
          this->title (tmp);
        }

        return true;
      }

      if (n == "show" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->show_parser_)
        {
          this->show_parser_->pre ();
          this->show_parser_->_pre_impl ();
          this->show_parser_->_characters (s);
          this->show_parser_->_post_impl ();
          this->show_parser_->post_show ();
          this->show ();
        }

        return true;
      }

      if (n == "actuate" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->actuate_parser_)
        {
          this->actuate_parser_->pre ();
          this->actuate_parser_->_pre_impl ();
          this->actuate_parser_->_characters (s);
          this->actuate_parser_->_post_impl ();
          this->actuate_parser_->post_actuate ();
          this->actuate ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for namePartType_pskel.
    //
    bool namePartType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_type2 ();
          this->type ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for typeOfResourceType_pskel.
    //
    bool typeOfResourceType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "collection" && ns.empty ())
      {
        if (this->collection_parser_)
        {
          this->collection_parser_->pre ();
          this->collection_parser_->_pre_impl ();
          this->collection_parser_->_characters (s);
          this->collection_parser_->_post_impl ();
          this->collection_parser_->post_collection ();
          this->collection ();
        }

        return true;
      }

      if (n == "manuscript" && ns.empty ())
      {
        if (this->manuscript_parser_)
        {
          this->manuscript_parser_->pre ();
          this->manuscript_parser_->_pre_impl ();
          this->manuscript_parser_->_characters (s);
          this->manuscript_parser_->_post_impl ();
          this->manuscript_parser_->post_manuscript ();
          this->manuscript ();
        }

        return true;
      }

      return this->::mods::v3::resourceType_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for genreType_pskel.
    //
    bool genreType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for originInfoType_pskel.
    //
    bool originInfoType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for placeTermType_pskel.
    //
    bool placeTermType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_placeAuthority ();
          this->authority ();
        }

        return true;
      }

      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_codeOrText ();
          this->type ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for physicalDescriptionType_pskel.
    //
    bool physicalDescriptionType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for targetAudienceType_pskel.
    //
    bool targetAudienceType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for subjectType_pskel.
    //
    bool subjectType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "ID" && ns.empty ())
      {
        if (this->ID_parser_)
        {
          this->ID_parser_->pre ();
          this->ID_parser_->_pre_impl ();
          this->ID_parser_->_characters (s);
          this->ID_parser_->_post_impl ();
          const ::std::string& tmp (this->ID_parser_->post_id ());
          this->ID (tmp);
        }

        return true;
      }

      if (n == "type" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          const ::std::string& tmp (this->type_parser_->post_string ());
          this->type (tmp);
        }

        return true;
      }

      if (n == "href" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->href_parser_)
        {
          this->href_parser_->pre ();
          this->href_parser_->_pre_impl ();
          this->href_parser_->_characters (s);
          this->href_parser_->_post_impl ();
          const ::std::string& tmp (this->href_parser_->post_uri ());
          this->href (tmp);
        }

        return true;
      }

      if (n == "role" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->role_parser_)
        {
          this->role_parser_->pre ();
          this->role_parser_->_pre_impl ();
          this->role_parser_->_characters (s);
          this->role_parser_->_post_impl ();
          const ::std::string& tmp (this->role_parser_->post_string ());
          this->role (tmp);
        }

        return true;
      }

      if (n == "arcrole" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->arcrole_parser_)
        {
          this->arcrole_parser_->pre ();
          this->arcrole_parser_->_pre_impl ();
          this->arcrole_parser_->_characters (s);
          this->arcrole_parser_->_post_impl ();
          const ::std::string& tmp (this->arcrole_parser_->post_string ());
          this->arcrole (tmp);
        }

        return true;
      }

      if (n == "title" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->title_parser_)
        {
          this->title_parser_->pre ();
          this->title_parser_->_pre_impl ();
          this->title_parser_->_characters (s);
          this->title_parser_->_post_impl ();
          const ::std::string& tmp (this->title_parser_->post_string ());
          this->title (tmp);
        }

        return true;
      }

      if (n == "show" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->show_parser_)
        {
          this->show_parser_->pre ();
          this->show_parser_->_pre_impl ();
          this->show_parser_->_characters (s);
          this->show_parser_->_post_impl ();
          this->show_parser_->post_show ();
          this->show ();
        }

        return true;
      }

      if (n == "actuate" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->actuate_parser_)
        {
          this->actuate_parser_->pre ();
          this->actuate_parser_->_pre_impl ();
          this->actuate_parser_->_characters (s);
          this->actuate_parser_->_post_impl ();
          this->actuate_parser_->post_actuate ();
          this->actuate ();
        }

        return true;
      }

      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for classificationType_pskel.
    //
    bool classificationType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "edition" && ns.empty ())
      {
        if (this->edition_parser_)
        {
          this->edition_parser_->pre ();
          this->edition_parser_->_pre_impl ();
          this->edition_parser_->_characters (s);
          this->edition_parser_->_post_impl ();
          this->edition_parser_->post_any_simple_type ();
          this->edition ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for relatedItemType_pskel.
    //
    bool relatedItemType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_type3 ();
          this->type ();
        }

        return true;
      }

      if (n == "displayLabel" && ns.empty ())
      {
        if (this->displayLabel_parser_)
        {
          this->displayLabel_parser_->pre ();
          this->displayLabel_parser_->_pre_impl ();
          this->displayLabel_parser_->_characters (s);
          this->displayLabel_parser_->_post_impl ();
          const ::std::string& tmp (this->displayLabel_parser_->post_string ());
          this->displayLabel (tmp);
        }

        return true;
      }

      if (n == "type" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->type1_parser_)
        {
          this->type1_parser_->pre ();
          this->type1_parser_->_pre_impl ();
          this->type1_parser_->_characters (s);
          this->type1_parser_->_post_impl ();
          const ::std::string& tmp (this->type1_parser_->post_string ());
          this->type1 (tmp);
        }

        return true;
      }

      if (n == "href" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->href_parser_)
        {
          this->href_parser_->pre ();
          this->href_parser_->_pre_impl ();
          this->href_parser_->_characters (s);
          this->href_parser_->_post_impl ();
          const ::std::string& tmp (this->href_parser_->post_uri ());
          this->href (tmp);
        }

        return true;
      }

      if (n == "role" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->role_parser_)
        {
          this->role_parser_->pre ();
          this->role_parser_->_pre_impl ();
          this->role_parser_->_characters (s);
          this->role_parser_->_post_impl ();
          const ::std::string& tmp (this->role_parser_->post_string ());
          this->role (tmp);
        }

        return true;
      }

      if (n == "arcrole" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->arcrole_parser_)
        {
          this->arcrole_parser_->pre ();
          this->arcrole_parser_->_pre_impl ();
          this->arcrole_parser_->_characters (s);
          this->arcrole_parser_->_post_impl ();
          const ::std::string& tmp (this->arcrole_parser_->post_string ());
          this->arcrole (tmp);
        }

        return true;
      }

      if (n == "title" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->title_parser_)
        {
          this->title_parser_->pre ();
          this->title_parser_->_pre_impl ();
          this->title_parser_->_characters (s);
          this->title_parser_->_post_impl ();
          const ::std::string& tmp (this->title_parser_->post_string ());
          this->title (tmp);
        }

        return true;
      }

      if (n == "show" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->show_parser_)
        {
          this->show_parser_->pre ();
          this->show_parser_->_pre_impl ();
          this->show_parser_->_characters (s);
          this->show_parser_->_post_impl ();
          this->show_parser_->post_show ();
          this->show ();
        }

        return true;
      }

      if (n == "actuate" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->actuate_parser_)
        {
          this->actuate_parser_->pre ();
          this->actuate_parser_->_pre_impl ();
          this->actuate_parser_->_characters (s);
          this->actuate_parser_->_post_impl ();
          this->actuate_parser_->post_actuate ();
          this->actuate ();
        }

        return true;
      }

      return this->::mods::v3::modsType_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for detailType_pskel.
    //
    bool detailType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_any_simple_type ();
          this->type ();
        }

        return true;
      }

      if (n == "level" && ns.empty ())
      {
        if (this->level_parser_)
        {
          this->level_parser_->pre ();
          this->level_parser_->_pre_impl ();
          this->level_parser_->_characters (s);
          this->level_parser_->_post_impl ();
          unsigned long long tmp (this->level_parser_->post_positive_integer ());
          this->level (tmp);
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for extentType_pskel.
    //
    bool extentType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "unit" && ns.empty ())
      {
        if (this->unit_parser_)
        {
          this->unit_parser_->pre ();
          this->unit_parser_->_pre_impl ();
          this->unit_parser_->_characters (s);
          this->unit_parser_->_post_impl ();
          this->unit_parser_->post_any_simple_type ();
          this->unit ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for identifierType_pskel.
    //
    bool identifierType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_any_simple_type ();
          this->type ();
        }

        return true;
      }

      if (n == "displayLabel" && ns.empty ())
      {
        if (this->displayLabel_parser_)
        {
          this->displayLabel_parser_->pre ();
          this->displayLabel_parser_->_pre_impl ();
          this->displayLabel_parser_->_characters (s);
          this->displayLabel_parser_->_post_impl ();
          this->displayLabel_parser_->post_any_simple_type ();
          this->displayLabel ();
        }

        return true;
      }

      if (n == "invalid" && ns.empty ())
      {
        if (this->invalid_parser_)
        {
          this->invalid_parser_->pre ();
          this->invalid_parser_->_pre_impl ();
          this->invalid_parser_->_characters (s);
          this->invalid_parser_->_post_impl ();
          this->invalid_parser_->post_invalid ();
          this->invalid ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for recordInfoType_pskel.
    //
    bool recordInfoType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return false;
    }

    // Attribute validation and dispatch functions for unstructuredText_pskel.
    //
    bool unstructuredText_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "type" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          const ::std::string& tmp (this->type_parser_->post_string ());
          this->type (tmp);
        }

        return true;
      }

      if (n == "href" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->href_parser_)
        {
          this->href_parser_->pre ();
          this->href_parser_->_pre_impl ();
          this->href_parser_->_characters (s);
          this->href_parser_->_post_impl ();
          const ::std::string& tmp (this->href_parser_->post_uri ());
          this->href (tmp);
        }

        return true;
      }

      if (n == "role" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->role_parser_)
        {
          this->role_parser_->pre ();
          this->role_parser_->_pre_impl ();
          this->role_parser_->_characters (s);
          this->role_parser_->_post_impl ();
          const ::std::string& tmp (this->role_parser_->post_string ());
          this->role (tmp);
        }

        return true;
      }

      if (n == "arcrole" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->arcrole_parser_)
        {
          this->arcrole_parser_->pre ();
          this->arcrole_parser_->_pre_impl ();
          this->arcrole_parser_->_characters (s);
          this->arcrole_parser_->_post_impl ();
          const ::std::string& tmp (this->arcrole_parser_->post_string ());
          this->arcrole (tmp);
        }

        return true;
      }

      if (n == "title" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->title_parser_)
        {
          this->title_parser_->pre ();
          this->title_parser_->_pre_impl ();
          this->title_parser_->_characters (s);
          this->title_parser_->_post_impl ();
          const ::std::string& tmp (this->title_parser_->post_string ());
          this->title (tmp);
        }

        return true;
      }

      if (n == "show" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->show_parser_)
        {
          this->show_parser_->pre ();
          this->show_parser_->_pre_impl ();
          this->show_parser_->_characters (s);
          this->show_parser_->_post_impl ();
          this->show_parser_->post_show ();
          this->show ();
        }

        return true;
      }

      if (n == "actuate" &&
          ns == "http://www.w3.org/TR/xlink")
      {
        if (this->actuate_parser_)
        {
          this->actuate_parser_->pre ();
          this->actuate_parser_->_pre_impl ();
          this->actuate_parser_->_characters (s);
          this->actuate_parser_->_post_impl ();
          this->actuate_parser_->post_actuate ();
          this->actuate ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      if (n == "displayLabel" && ns.empty ())
      {
        if (this->displayLabel_parser_)
        {
          this->displayLabel_parser_->pre ();
          this->displayLabel_parser_->_pre_impl ();
          this->displayLabel_parser_->_characters (s);
          this->displayLabel_parser_->_post_impl ();
          const ::std::string& tmp (this->displayLabel_parser_->post_string ());
          this->displayLabel (tmp);
        }

        return true;
      }

      if (n == "type" && ns.empty ())
      {
        if (this->type1_parser_)
        {
          this->type1_parser_->pre ();
          this->type1_parser_->_pre_impl ();
          this->type1_parser_->_characters (s);
          this->type1_parser_->_post_impl ();
          const ::std::string& tmp (this->type1_parser_->post_string ());
          this->type1 (tmp);
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for baseDateType_pskel.
    //
    bool baseDateType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "encoding" && ns.empty ())
      {
        if (this->encoding_parser_)
        {
          this->encoding_parser_->pre ();
          this->encoding_parser_->_pre_impl ();
          this->encoding_parser_->_characters (s);
          this->encoding_parser_->_post_impl ();
          this->encoding_parser_->post_encoding ();
          this->encoding ();
        }

        return true;
      }

      if (n == "qualifier" && ns.empty ())
      {
        if (this->qualifier_parser_)
        {
          this->qualifier_parser_->pre ();
          this->qualifier_parser_->_pre_impl ();
          this->qualifier_parser_->_characters (s);
          this->qualifier_parser_->_post_impl ();
          this->qualifier_parser_->post_qualifier ();
          this->qualifier ();
        }

        return true;
      }

      if (n == "point" && ns.empty ())
      {
        if (this->point_parser_)
        {
          this->point_parser_->pre ();
          this->point_parser_->_pre_impl ();
          this->point_parser_->_characters (s);
          this->point_parser_->_post_impl ();
          this->point_parser_->post_point ();
          this->point ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for dateType_pskel.
    //
    bool dateType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "keyDate" && ns.empty ())
      {
        if (this->keyDate_parser_)
        {
          this->keyDate_parser_->pre ();
          this->keyDate_parser_->_pre_impl ();
          this->keyDate_parser_->_characters (s);
          this->keyDate_parser_->_post_impl ();
          this->keyDate_parser_->post_keyDate ();
          this->keyDate ();
        }

        return true;
      }

      return this->::mods::v3::baseDateType_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for sourceType_pskel.
    //
    bool sourceType_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "lang" && ns.empty ())
      {
        if (this->lang_parser_)
        {
          this->lang_parser_->pre ();
          this->lang_parser_->_pre_impl ();
          this->lang_parser_->_characters (s);
          this->lang_parser_->_post_impl ();
          this->lang_parser_->post_any_simple_type ();
          this->lang ();
        }

        return true;
      }

      if (n == "lang" &&
          ns == "http://www.w3.org/XML/1998/namespace")
      {
        if (this->lang1_parser_)
        {
          this->lang1_parser_->pre ();
          this->lang1_parser_->_pre_impl ();
          this->lang1_parser_->_characters (s);
          this->lang1_parser_->_post_impl ();
          const ::std::string& tmp (this->lang1_parser_->post_language ());
          this->lang1 (tmp);
        }

        return true;
      }

      if (n == "script" && ns.empty ())
      {
        if (this->script_parser_)
        {
          this->script_parser_->pre ();
          this->script_parser_->_pre_impl ();
          this->script_parser_->_characters (s);
          this->script_parser_->_post_impl ();
          this->script_parser_->post_any_simple_type ();
          this->script ();
        }

        return true;
      }

      if (n == "transliteration" && ns.empty ())
      {
        if (this->transliteration_parser_)
        {
          this->transliteration_parser_->pre ();
          this->transliteration_parser_->_pre_impl ();
          this->transliteration_parser_->_characters (s);
          this->transliteration_parser_->_post_impl ();
          this->transliteration_parser_->post_any_simple_type ();
          this->transliteration ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for roleTerm_pskel.
    //
    bool roleTerm_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_codeOrText ();
          this->type ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for languageTerm_pskel.
    //
    bool languageTerm_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_authority ();
          this->authority ();
        }

        return true;
      }

      if (n == "type" && ns.empty ())
      {
        if (this->type_parser_)
        {
          this->type_parser_->pre ();
          this->type_parser_->_pre_impl ();
          this->type_parser_->_characters (s);
          this->type_parser_->_post_impl ();
          this->type_parser_->post_codeOrText ();
          this->type ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for form_pskel.
    //
    bool form_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_any_simple_type ();
          this->authority ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for geographicCode_pskel.
    //
    bool geographicCode_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "authority" && ns.empty ())
      {
        if (this->authority_parser_)
        {
          this->authority_parser_->pre ();
          this->authority_parser_->_pre_impl ();
          this->authority_parser_->_characters (s);
          this->authority_parser_->_post_impl ();
          this->authority_parser_->post_placeAuthority ();
          this->authority ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for physicalLocation_pskel.
    //
    bool physicalLocation_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "displayLabel" && ns.empty ())
      {
        if (this->displayLabel_parser_)
        {
          this->displayLabel_parser_->pre ();
          this->displayLabel_parser_->_pre_impl ();
          this->displayLabel_parser_->_characters (s);
          this->displayLabel_parser_->_post_impl ();
          this->displayLabel_parser_->post_any_simple_type ();
          this->displayLabel ();
        }

        return true;
      }

      return this->::mods::v3::sourceType_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for url_pskel.
    //
    bool url_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "dateLastAccessed" && ns.empty ())
      {
        if (this->dateLastAccessed_parser_)
        {
          this->dateLastAccessed_parser_->pre ();
          this->dateLastAccessed_parser_->_pre_impl ();
          this->dateLastAccessed_parser_->_characters (s);
          this->dateLastAccessed_parser_->_post_impl ();
          this->dateLastAccessed_parser_->post_any_simple_type ();
          this->dateLastAccessed ();
        }

        return true;
      }

      if (n == "displayLabel" && ns.empty ())
      {
        if (this->displayLabel_parser_)
        {
          this->displayLabel_parser_->pre ();
          this->displayLabel_parser_->_pre_impl ();
          this->displayLabel_parser_->_characters (s);
          this->displayLabel_parser_->_post_impl ();
          this->displayLabel_parser_->post_any_simple_type ();
          this->displayLabel ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }

    // Attribute validation and dispatch functions for recordIdentifier_pskel.
    //
    bool recordIdentifier_pskel::
    _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                               const ::xml_schema::ro_string& n,
                               const ::xml_schema::ro_string& s)
    {
      if (n == "source" && ns.empty ())
      {
        if (this->source_parser_)
        {
          this->source_parser_->pre ();
          this->source_parser_->_pre_impl ();
          this->source_parser_->_characters (s);
          this->source_parser_->_post_impl ();
          this->source_parser_->post_any_simple_type ();
          this->source ();
        }

        return true;
      }

      return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
    }
  }
}

namespace mods
{
  namespace v3
  {
    // Character validation functions for extensionType_pskel.
    //
    bool extensionType_pskel::
    _characters_impl (const ::xml_schema::ro_string& s)
    {
      this->_any_characters (s);
      return true;
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

