// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "mets-pskel.hxx"

namespace METS
{
  // metsType_pskel
  //

  void metsType_pskel::
  metsHdr ()
  {
  }

  void metsType_pskel::
  dmdSec ()
  {
  }

  void metsType_pskel::
  amdSec ()
  {
  }

  void metsType_pskel::
  fileSec ()
  {
  }

  void metsType_pskel::
  structMap ()
  {
  }

  void metsType_pskel::
  structLink ()
  {
  }

  void metsType_pskel::
  behaviorSec ()
  {
  }

  void metsType_pskel::
  ID (const ::std::string&)
  {
  }

  void metsType_pskel::
  OBJID (const ::std::string&)
  {
  }

  void metsType_pskel::
  LABEL (const ::std::string&)
  {
  }

  void metsType_pskel::
  TYPE (const ::std::string&)
  {
  }

  void metsType_pskel::
  PROFILE (const ::std::string&)
  {
  }

  void metsType_pskel::
  post_metsType ()
  {
  }

  // amdSecType_pskel
  //

  void amdSecType_pskel::
  techMD ()
  {
  }

  void amdSecType_pskel::
  rightsMD ()
  {
  }

  void amdSecType_pskel::
  sourceMD ()
  {
  }

  void amdSecType_pskel::
  digiprovMD ()
  {
  }

  void amdSecType_pskel::
  ID (const ::std::string&)
  {
  }

  void amdSecType_pskel::
  post_amdSecType ()
  {
  }

  // fileGrpType_pskel
  //

  void fileGrpType_pskel::
  fileGrp ()
  {
  }

  void fileGrpType_pskel::
  file ()
  {
  }

  void fileGrpType_pskel::
  ID (const ::std::string&)
  {
  }

  void fileGrpType_pskel::
  VERSDATE (const ::xml_schema::date_time&)
  {
  }

  void fileGrpType_pskel::
  ADMID (const ::xml_schema::string_sequence&)
  {
  }

  void fileGrpType_pskel::
  USE (const ::std::string&)
  {
  }

  void fileGrpType_pskel::
  post_fileGrpType ()
  {
  }

  // structMapType_pskel
  //

  void structMapType_pskel::
  div ()
  {
  }

  void structMapType_pskel::
  ID (const ::std::string&)
  {
  }

  void structMapType_pskel::
  TYPE (const ::std::string&)
  {
  }

  void structMapType_pskel::
  LABEL (const ::std::string&)
  {
  }

  void structMapType_pskel::
  post_structMapType ()
  {
  }

  // divType_pskel
  //

  void divType_pskel::
  mptr ()
  {
  }

  void divType_pskel::
  fptr ()
  {
  }

  void divType_pskel::
  div ()
  {
  }

  void divType_pskel::
  ID (const ::std::string&)
  {
  }

  void divType_pskel::
  ORDER (long long)
  {
  }

  void divType_pskel::
  ORDERLABEL (const ::std::string&)
  {
  }

  void divType_pskel::
  LABEL (const ::std::string&)
  {
  }

  void divType_pskel::
  DMDID (const ::xml_schema::string_sequence&)
  {
  }

  void divType_pskel::
  ADMID (const ::xml_schema::string_sequence&)
  {
  }

  void divType_pskel::
  TYPE (const ::std::string&)
  {
  }

  void divType_pskel::
  post_divType ()
  {
  }

  // seqType_pskel
  //

  void seqType_pskel::
  area ()
  {
  }

  void seqType_pskel::
  ID (const ::std::string&)
  {
  }

  void seqType_pskel::
  post_seqType ()
  {
  }

  // areaType_pskel
  //

  void areaType_pskel::
  ID (const ::std::string&)
  {
  }

  void areaType_pskel::
  FILEID (const ::std::string&)
  {
  }

  void areaType_pskel::
  SHAPE ()
  {
  }

  void areaType_pskel::
  COORDS (const ::std::string&)
  {
  }

  void areaType_pskel::
  BEGIN (const ::std::string&)
  {
  }

  void areaType_pskel::
  END (const ::std::string&)
  {
  }

  void areaType_pskel::
  BETYPE ()
  {
  }

  void areaType_pskel::
  EXTENT (const ::std::string&)
  {
  }

  void areaType_pskel::
  EXTTYPE ()
  {
  }

  void areaType_pskel::
  ADMID (const ::xml_schema::string_sequence&)
  {
  }

  void areaType_pskel::
  post_areaType ()
  {
  }

  // structLinkType_pskel
  //

  void structLinkType_pskel::
  smLink ()
  {
  }

  void structLinkType_pskel::
  post_structLinkType ()
  {
  }

  // behaviorSecType_pskel
  //

  void behaviorSecType_pskel::
  behaviorSec ()
  {
  }

  void behaviorSecType_pskel::
  behavior ()
  {
  }

  void behaviorSecType_pskel::
  ID (const ::std::string&)
  {
  }

  void behaviorSecType_pskel::
  CREATED (const ::xml_schema::date_time&)
  {
  }

  void behaviorSecType_pskel::
  LABEL (const ::std::string&)
  {
  }

  void behaviorSecType_pskel::
  post_behaviorSecType ()
  {
  }

  // behaviorType_pskel
  //

  void behaviorType_pskel::
  interfaceDef ()
  {
  }

  void behaviorType_pskel::
  mechanism ()
  {
  }

  void behaviorType_pskel::
  ID (const ::std::string&)
  {
  }

  void behaviorType_pskel::
  STRUCTID (const ::xml_schema::string_sequence&)
  {
  }

  void behaviorType_pskel::
  BTYPE (const ::std::string&)
  {
  }

  void behaviorType_pskel::
  CREATED (const ::xml_schema::date_time&)
  {
  }

  void behaviorType_pskel::
  LABEL (const ::std::string&)
  {
  }

  void behaviorType_pskel::
  GROUPID (const ::std::string&)
  {
  }

  void behaviorType_pskel::
  ADMID (const ::xml_schema::string_sequence&)
  {
  }

  void behaviorType_pskel::
  post_behaviorType ()
  {
  }

  // objectType_pskel
  //

  void objectType_pskel::
  ID (const ::std::string&)
  {
  }

  void objectType_pskel::
  LABEL (const ::std::string&)
  {
  }

  void objectType_pskel::
  LOCTYPE ()
  {
  }

  void objectType_pskel::
  OTHERLOCTYPE (const ::std::string&)
  {
  }

  void objectType_pskel::
  type (const ::std::string&)
  {
  }

  void objectType_pskel::
  href (const ::std::string&)
  {
  }

  void objectType_pskel::
  role (const ::std::string&)
  {
  }

  void objectType_pskel::
  arcrole (const ::std::string&)
  {
  }

  void objectType_pskel::
  title (const ::std::string&)
  {
  }

  void objectType_pskel::
  show ()
  {
  }

  void objectType_pskel::
  actuate ()
  {
  }

  void objectType_pskel::
  post_objectType ()
  {
  }

  // mdSecType_pskel
  //

  void mdSecType_pskel::
  mdRef ()
  {
  }

  void mdSecType_pskel::
  mdWrap ()
  {
  }

  void mdSecType_pskel::
  ID (const ::std::string&)
  {
  }

  void mdSecType_pskel::
  GROUPID (const ::std::string&)
  {
  }

  void mdSecType_pskel::
  ADMID (const ::xml_schema::string_sequence&)
  {
  }

  void mdSecType_pskel::
  CREATED (const ::xml_schema::date_time&)
  {
  }

  void mdSecType_pskel::
  STATUS (const ::std::string&)
  {
  }

  void mdSecType_pskel::
  post_mdSecType ()
  {
  }

  // mets_pskel
  //

  void mets_pskel::
  post_mets ()
  {
    post_metsType ();
  }

  // metsHdr_pskel
  //

  void metsHdr_pskel::
  agent ()
  {
  }

  void metsHdr_pskel::
  altRecordID ()
  {
  }

  void metsHdr_pskel::
  ID (const ::std::string&)
  {
  }

  void metsHdr_pskel::
  CREATEDATE (const ::xml_schema::date_time&)
  {
  }

  void metsHdr_pskel::
  LASTMODDATE (const ::xml_schema::date_time&)
  {
  }

  void metsHdr_pskel::
  RECORDSTATUS (const ::std::string&)
  {
  }

  void metsHdr_pskel::
  post_metsHdr ()
  {
  }

  // fileSec_pskel
  //

  void fileSec_pskel::
  fileGrp ()
  {
  }

  void fileSec_pskel::
  ID (const ::std::string&)
  {
  }

  void fileSec_pskel::
  post_fileSec ()
  {
  }

  // file_pskel
  //

  void file_pskel::
  FLocat ()
  {
  }

  void file_pskel::
  FContent ()
  {
  }

  void file_pskel::
  ID (const ::std::string&)
  {
  }

  void file_pskel::
  MIMETYPE (const ::std::string&)
  {
  }

  void file_pskel::
  SEQ (int)
  {
  }

  void file_pskel::
  SIZE (long long)
  {
  }

  void file_pskel::
  CREATED (const ::xml_schema::date_time&)
  {
  }

  void file_pskel::
  CHECKSUM (const ::std::string&)
  {
  }

  void file_pskel::
  CHECKSUMTYPE ()
  {
  }

  void file_pskel::
  OWNERID (const ::std::string&)
  {
  }

  void file_pskel::
  ADMID (const ::xml_schema::string_sequence&)
  {
  }

  void file_pskel::
  DMDID (const ::xml_schema::string_sequence&)
  {
  }

  void file_pskel::
  GROUPID (const ::std::string&)
  {
  }

  void file_pskel::
  USE (const ::std::string&)
  {
  }

  void file_pskel::
  post_file ()
  {
  }

  // mptr_pskel
  //

  void mptr_pskel::
  ID (const ::std::string&)
  {
  }

  void mptr_pskel::
  LOCTYPE ()
  {
  }

  void mptr_pskel::
  OTHERLOCTYPE (const ::std::string&)
  {
  }

  void mptr_pskel::
  type (const ::std::string&)
  {
  }

  void mptr_pskel::
  href (const ::std::string&)
  {
  }

  void mptr_pskel::
  role (const ::std::string&)
  {
  }

  void mptr_pskel::
  arcrole (const ::std::string&)
  {
  }

  void mptr_pskel::
  title (const ::std::string&)
  {
  }

  void mptr_pskel::
  show ()
  {
  }

  void mptr_pskel::
  actuate ()
  {
  }

  void mptr_pskel::
  post_mptr ()
  {
  }

  // fptr_pskel
  //

  void fptr_pskel::
  par ()
  {
  }

  void fptr_pskel::
  seq ()
  {
  }

  void fptr_pskel::
  area ()
  {
  }

  void fptr_pskel::
  ID (const ::std::string&)
  {
  }

  void fptr_pskel::
  FILEID (const ::std::string&)
  {
  }

  void fptr_pskel::
  post_fptr ()
  {
  }

  // SHAPE_pskel
  //

  void SHAPE_pskel::
  post_SHAPE ()
  {
  }

  // BETYPE_pskel
  //

  void BETYPE_pskel::
  post_BETYPE ()
  {
  }

  // EXTTYPE_pskel
  //

  void EXTTYPE_pskel::
  post_EXTTYPE ()
  {
  }

  // smLink_pskel
  //

  void smLink_pskel::
  arcrole (const ::std::string&)
  {
  }

  void smLink_pskel::
  title (const ::std::string&)
  {
  }

  void smLink_pskel::
  show ()
  {
  }

  void smLink_pskel::
  actuate ()
  {
  }

  void smLink_pskel::
  to (const ::std::string&)
  {
  }

  void smLink_pskel::
  from (const ::std::string&)
  {
  }

  void smLink_pskel::
  post_smLink ()
  {
  }

  // mdRef_pskel
  //

  void mdRef_pskel::
  ID (const ::std::string&)
  {
  }

  void mdRef_pskel::
  LOCTYPE ()
  {
  }

  void mdRef_pskel::
  OTHERLOCTYPE (const ::std::string&)
  {
  }

  void mdRef_pskel::
  type (const ::std::string&)
  {
  }

  void mdRef_pskel::
  href (const ::std::string&)
  {
  }

  void mdRef_pskel::
  role (const ::std::string&)
  {
  }

  void mdRef_pskel::
  arcrole (const ::std::string&)
  {
  }

  void mdRef_pskel::
  title (const ::std::string&)
  {
  }

  void mdRef_pskel::
  show ()
  {
  }

  void mdRef_pskel::
  actuate ()
  {
  }

  void mdRef_pskel::
  MDTYPE ()
  {
  }

  void mdRef_pskel::
  OTHERMDTYPE (const ::std::string&)
  {
  }

  void mdRef_pskel::
  MIMETYPE (const ::std::string&)
  {
  }

  void mdRef_pskel::
  LABEL (const ::std::string&)
  {
  }

  void mdRef_pskel::
  XPTR (const ::std::string&)
  {
  }

  void mdRef_pskel::
  post_mdRef ()
  {
  }

  // mdWrap_pskel
  //

  void mdWrap_pskel::
  binData (::std::auto_ptr< ::xml_schema::buffer >)
  {
  }

  void mdWrap_pskel::
  xmlData ()
  {
  }

  void mdWrap_pskel::
  ID (const ::std::string&)
  {
  }

  void mdWrap_pskel::
  MIMETYPE (const ::std::string&)
  {
  }

  void mdWrap_pskel::
  MDTYPE ()
  {
  }

  void mdWrap_pskel::
  OTHERMDTYPE (const ::std::string&)
  {
  }

  void mdWrap_pskel::
  LABEL (const ::std::string&)
  {
  }

  void mdWrap_pskel::
  post_mdWrap ()
  {
  }

  // MDTYPE_pskel
  //

  void MDTYPE_pskel::
  post_MDTYPE ()
  {
  }

  // LOCTYPE_pskel
  //

  void LOCTYPE_pskel::
  post_LOCTYPE ()
  {
  }

  // agent_pskel
  //

  void agent_pskel::
  name (const ::std::string&)
  {
  }

  void agent_pskel::
  note (const ::std::string&)
  {
  }

  void agent_pskel::
  ID (const ::std::string&)
  {
  }

  void agent_pskel::
  ROLE ()
  {
  }

  void agent_pskel::
  OTHERROLE (const ::std::string&)
  {
  }

  void agent_pskel::
  TYPE ()
  {
  }

  void agent_pskel::
  OTHERTYPE (const ::std::string&)
  {
  }

  void agent_pskel::
  post_agent ()
  {
  }

  // altRecordID_pskel
  //

  void altRecordID_pskel::
  ID (const ::std::string&)
  {
  }

  void altRecordID_pskel::
  TYPE (const ::std::string&)
  {
  }

  void altRecordID_pskel::
  post_altRecordID ()
  {
  }

  // fileGrp_pskel
  //

  void fileGrp_pskel::
  post_fileGrp ()
  {
    post_fileGrpType ();
  }

  // FLocat_pskel
  //

  void FLocat_pskel::
  ID (const ::std::string&)
  {
  }

  void FLocat_pskel::
  LOCTYPE ()
  {
  }

  void FLocat_pskel::
  OTHERLOCTYPE (const ::std::string&)
  {
  }

  void FLocat_pskel::
  USE (const ::std::string&)
  {
  }

  void FLocat_pskel::
  type (const ::std::string&)
  {
  }

  void FLocat_pskel::
  href (const ::std::string&)
  {
  }

  void FLocat_pskel::
  role (const ::std::string&)
  {
  }

  void FLocat_pskel::
  arcrole (const ::std::string&)
  {
  }

  void FLocat_pskel::
  title (const ::std::string&)
  {
  }

  void FLocat_pskel::
  show ()
  {
  }

  void FLocat_pskel::
  actuate ()
  {
  }

  void FLocat_pskel::
  post_FLocat ()
  {
  }

  // FContent_pskel
  //

  void FContent_pskel::
  binData (::std::auto_ptr< ::xml_schema::buffer >)
  {
  }

  void FContent_pskel::
  xmlData ()
  {
  }

  void FContent_pskel::
  USE (const ::std::string&)
  {
  }

  void FContent_pskel::
  post_FContent ()
  {
  }

  // CHECKSUMTYPE_pskel
  //

  void CHECKSUMTYPE_pskel::
  post_CHECKSUMTYPE ()
  {
  }

  // par_pskel
  //

  void par_pskel::
  area ()
  {
  }

  void par_pskel::
  seq ()
  {
  }

  void par_pskel::
  ID (const ::std::string&)
  {
  }

  void par_pskel::
  post_par ()
  {
  }

  // xmlData_pskel
  //

  void xmlData_pskel::
  post_xmlData ()
  {
  }

  // ROLE_pskel
  //

  void ROLE_pskel::
  post_ROLE ()
  {
  }

  // TYPE_pskel
  //

  void TYPE_pskel::
  post_TYPE ()
  {
  }

  // xmlData1_pskel
  //

  void xmlData1_pskel::
  post_xmlData1 ()
  {
  }
}

#include <cassert>

namespace METS
{
  // Element validation and dispatch functions for metsType_pskel.
  //
  bool metsType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "metsHdr" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "dmdSec" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;
        else if (n == "amdSec" &&
                 ns == "http://www.loc.gov/METS/")
          s = 2UL;
        else if (n == "fileSec" &&
                 ns == "http://www.loc.gov/METS/")
          s = 3UL;
        else if (n == "structMap" &&
                 ns == "http://www.loc.gov/METS/")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &metsType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "metsHdr",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool metsType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void metsType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void metsType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "metsHdr");

    this->v_state_stack_.pop ();
  }

  void metsType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "metsHdr" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->metsHdr_parser_;

            if (this->metsHdr_parser_)
              this->metsHdr_parser_->pre ();
          }
          else
          {
            if (this->metsHdr_parser_)
            {
              this->metsHdr_parser_->post_metsHdr ();
              this->metsHdr ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "dmdSec" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->dmdSec_parser_;

            if (this->dmdSec_parser_)
              this->dmdSec_parser_->pre ();
          }
          else
          {
            if (this->dmdSec_parser_)
            {
              this->dmdSec_parser_->post_mdSecType ();
              this->dmdSec ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "amdSec" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->amdSec_parser_;

            if (this->amdSec_parser_)
              this->amdSec_parser_->pre ();
          }
          else
          {
            if (this->amdSec_parser_)
            {
              this->amdSec_parser_->post_amdSecType ();
              this->amdSec ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "fileSec" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->fileSec_parser_;

            if (this->fileSec_parser_)
              this->fileSec_parser_->pre ();
          }
          else
          {
            if (this->fileSec_parser_)
            {
              this->fileSec_parser_->post_fileSec ();
              this->fileSec ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "structMap" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->structMap_parser_;

            if (this->structMap_parser_)
              this->structMap_parser_->pre ();
          }
          else
          {
            if (this->structMap_parser_)
            {
              this->structMap_parser_->post_structMapType ();
              this->structMap ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "structMap",
              ns, n);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "structLink" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->structLink_parser_;

            if (this->structLink_parser_)
              this->structLink_parser_->pre ();
          }
          else
          {
            if (this->structLink_parser_)
            {
              this->structLink_parser_->post_structLinkType ();
              this->structLink ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "behaviorSec" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->behaviorSec_parser_;

            if (this->behaviorSec_parser_)
              this->behaviorSec_parser_->pre ();
          }
          else
          {
            if (this->behaviorSec_parser_)
            {
              this->behaviorSec_parser_->post_behaviorSecType ();
              this->behaviorSec ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for amdSecType_pskel.
  //
  bool amdSecType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "techMD" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "rightsMD" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;
        else if (n == "sourceMD" &&
                 ns == "http://www.loc.gov/METS/")
          s = 2UL;
        else if (n == "digiprovMD" &&
                 ns == "http://www.loc.gov/METS/")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &amdSecType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool amdSecType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void amdSecType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void amdSecType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void amdSecType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "techMD" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->techMD_parser_;

            if (this->techMD_parser_)
              this->techMD_parser_->pre ();
          }
          else
          {
            if (this->techMD_parser_)
            {
              this->techMD_parser_->post_mdSecType ();
              this->techMD ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "rightsMD" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->rightsMD_parser_;

            if (this->rightsMD_parser_)
              this->rightsMD_parser_->pre ();
          }
          else
          {
            if (this->rightsMD_parser_)
            {
              this->rightsMD_parser_->post_mdSecType ();
              this->rightsMD ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "sourceMD" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->sourceMD_parser_;

            if (this->sourceMD_parser_)
              this->sourceMD_parser_->pre ();
          }
          else
          {
            if (this->sourceMD_parser_)
            {
              this->sourceMD_parser_->post_mdSecType ();
              this->sourceMD ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "digiprovMD" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->digiprovMD_parser_;

            if (this->digiprovMD_parser_)
              this->digiprovMD_parser_->pre ();
          }
          else
          {
            if (this->digiprovMD_parser_)
            {
              this->digiprovMD_parser_->post_mdSecType ();
              this->digiprovMD ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for fileGrpType_pskel.
  //
  bool fileGrpType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "fileGrp" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "file" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &fileGrpType_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool fileGrpType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void fileGrpType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void fileGrpType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void fileGrpType_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "fileGrp" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->fileGrp_parser_;

            if (this->fileGrp_parser_)
              this->fileGrp_parser_->pre ();
          }
          else
          {
            if (this->fileGrp_parser_)
            {
              this->fileGrp_parser_->post_fileGrpType ();
              this->fileGrp ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (n == "file" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->file_parser_;

            if (this->file_parser_)
              this->file_parser_->pre ();
          }
          else
          {
            if (this->file_parser_)
            {
              this->file_parser_->post_file ();
              this->file ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for structMapType_pskel.
  //
  bool structMapType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "div" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &structMapType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "div",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool structMapType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void structMapType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void structMapType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "div");

    this->v_state_stack_.pop ();
  }

  void structMapType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "div" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->div_parser_;

            if (this->div_parser_)
              this->div_parser_->pre ();
          }
          else
          {
            if (this->div_parser_)
            {
              this->div_parser_->post_divType ();
              this->div ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "div",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for divType_pskel.
  //
  bool divType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "mptr" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "fptr" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;
        else if (n == "div" &&
                 ns == "http://www.loc.gov/METS/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &divType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool divType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void divType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void divType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void divType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "mptr" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->mptr_parser_;

            if (this->mptr_parser_)
              this->mptr_parser_->pre ();
          }
          else
          {
            if (this->mptr_parser_)
            {
              this->mptr_parser_->post_mptr ();
              this->mptr ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "fptr" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->fptr_parser_;

            if (this->fptr_parser_)
              this->fptr_parser_->pre ();
          }
          else
          {
            if (this->fptr_parser_)
            {
              this->fptr_parser_->post_fptr ();
              this->fptr ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "div" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->div_parser_;

            if (this->div_parser_)
              this->div_parser_->pre ();
          }
          else
          {
            if (this->div_parser_)
            {
              this->div_parser_->post_divType ();
              this->div ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for seqType_pskel.
  //
  bool seqType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "area" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &seqType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "area",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool seqType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void seqType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void seqType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "area");

    this->v_state_stack_.pop ();
  }

  void seqType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "area" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

            if (this->area_parser_)
              this->area_parser_->pre ();
          }
          else
          {
            if (this->area_parser_)
            {
              this->area_parser_->post_areaType ();
              this->area ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "area",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for structLinkType_pskel.
  //
  bool structLinkType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "smLink" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &structLinkType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "smLink",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool structLinkType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void structLinkType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void structLinkType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "smLink");

    this->v_state_stack_.pop ();
  }

  void structLinkType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "smLink" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->smLink_parser_;

            if (this->smLink_parser_)
              this->smLink_parser_->pre ();
          }
          else
          {
            if (this->smLink_parser_)
            {
              this->smLink_parser_->post_smLink ();
              this->smLink ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "smLink",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for behaviorSecType_pskel.
  //
  bool behaviorSecType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "behaviorSec" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "behavior" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &behaviorSecType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool behaviorSecType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void behaviorSecType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void behaviorSecType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void behaviorSecType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "behaviorSec" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->behaviorSec_parser_;

            if (this->behaviorSec_parser_)
              this->behaviorSec_parser_->pre ();
          }
          else
          {
            if (this->behaviorSec_parser_)
            {
              this->behaviorSec_parser_->post_behaviorSecType ();
              this->behaviorSec ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "behavior" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->behavior_parser_;

            if (this->behavior_parser_)
              this->behavior_parser_->pre ();
          }
          else
          {
            if (this->behavior_parser_)
            {
              this->behavior_parser_->post_behaviorType ();
              this->behavior ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for behaviorType_pskel.
  //
  bool behaviorType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "interfaceDef" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "mechanism" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &behaviorType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "interfaceDef",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool behaviorType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void behaviorType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void behaviorType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "interfaceDef");

    this->v_state_stack_.pop ();
  }

  void behaviorType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "interfaceDef" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->interfaceDef_parser_;

            if (this->interfaceDef_parser_)
              this->interfaceDef_parser_->pre ();
          }
          else
          {
            if (this->interfaceDef_parser_)
            {
              this->interfaceDef_parser_->post_objectType ();
              this->interfaceDef ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "mechanism" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->mechanism_parser_;

            if (this->mechanism_parser_)
              this->mechanism_parser_->pre ();
          }
          else
          {
            if (this->mechanism_parser_)
            {
              this->mechanism_parser_->post_objectType ();
              this->mechanism ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "mechanism",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for mdSecType_pskel.
  //
  bool mdSecType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    all_0 (vd->state, v_all_count_.top (), ns, n, t, true);

    if (vd->state != ~0UL)
      vd->count++;
    else
      return false;

    return true;
  }

  bool mdSecType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    all_0 (vd.state, v_all_count_.top (), ns, n, 0, false);

    return true;
  }

  void mdSecType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_all_count_.push ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void mdSecType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.count != 0)
    {
      ::xml_schema::ro_string empty;
      all_0 (vd.state, v_all_count_.top (), empty, empty, 0, true);
    }


    vs.size--;
    v_all_count_.pop ();

    this->v_state_stack_.pop ();
  }

  void mdSecType_pskel::
  all_0 (unsigned long& state,
         unsigned char* count,
         const ::xml_schema::ro_string& ns,
         const ::xml_schema::ro_string& n,
         const ::xml_schema::ro_string* t,
         bool start)
  {
    XSD_UNUSED (t);

    if (n == "mdRef" &&
        ns == "http://www.loc.gov/METS/")
    {
      if (count[0UL] == 0)
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->mdRef_parser_;

          if (this->mdRef_parser_)
            this->mdRef_parser_->pre ();
        }
        else
        {
          if (this->mdRef_parser_)
          {
            this->mdRef_parser_->post_mdRef ();
            this->mdRef ();
          }

          count[0UL] = 1;
        }
      }
      else
      {
        assert (start);
        state = ~0UL;
      }
    }
    else if (n == "mdWrap" &&
             ns == "http://www.loc.gov/METS/")
    {
      if (count[1UL] == 0)
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->mdWrap_parser_;

          if (this->mdWrap_parser_)
            this->mdWrap_parser_->pre ();
        }
        else
        {
          if (this->mdWrap_parser_)
          {
            this->mdWrap_parser_->post_mdWrap ();
            this->mdWrap ();
          }

          count[1UL] = 1;
        }
      }
      else
      {
        assert (start);
        state = ~0UL;
      }
    }
    else if (n.empty () && ns.empty ())
    {
      state = ~0UL;
    }
    else
      state = ~0UL;
  }

  // Element validation and dispatch functions for metsHdr_pskel.
  //
  bool metsHdr_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "agent" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "altRecordID" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &metsHdr_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool metsHdr_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void metsHdr_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void metsHdr_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void metsHdr_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "agent" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->agent_parser_;

            if (this->agent_parser_)
              this->agent_parser_->pre ();
          }
          else
          {
            if (this->agent_parser_)
            {
              this->agent_parser_->post_agent ();
              this->agent ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "altRecordID" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->altRecordID_parser_;

            if (this->altRecordID_parser_)
              this->altRecordID_parser_->pre ();
          }
          else
          {
            if (this->altRecordID_parser_)
            {
              this->altRecordID_parser_->post_altRecordID ();
              this->altRecordID ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for fileSec_pskel.
  //
  bool fileSec_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "fileGrp" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &fileSec_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "fileGrp",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool fileSec_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void fileSec_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void fileSec_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "fileGrp");

    this->v_state_stack_.pop ();
  }

  void fileSec_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "fileGrp" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->fileGrp_parser_;

            if (this->fileGrp_parser_)
              this->fileGrp_parser_->pre ();
          }
          else
          {
            if (this->fileGrp_parser_)
            {
              this->fileGrp_parser_->post_fileGrp ();
              this->fileGrp ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "fileGrp",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for file_pskel.
  //
  bool file_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "FLocat" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "FContent" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &file_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool file_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void file_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void file_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void file_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "FLocat" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FLocat_parser_;

            if (this->FLocat_parser_)
              this->FLocat_parser_->pre ();
          }
          else
          {
            if (this->FLocat_parser_)
            {
              this->FLocat_parser_->post_FLocat ();
              this->FLocat ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "FContent" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FContent_parser_;

            if (this->FContent_parser_)
              this->FContent_parser_->pre ();
          }
          else
          {
            if (this->FContent_parser_)
            {
              this->FContent_parser_->post_FContent ();
              this->FContent ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for fptr_pskel.
  //
  bool fptr_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "par" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "seq" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;
        else if (n == "area" &&
                 ns == "http://www.loc.gov/METS/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &fptr_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool fptr_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void fptr_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void fptr_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void fptr_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->par_parser_;

          if (this->par_parser_)
            this->par_parser_->pre ();
        }
        else
        {
          if (this->par_parser_)
          {
            this->par_parser_->post_par ();
            this->par ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->seq_parser_;

          if (this->seq_parser_)
            this->seq_parser_->pre ();
        }
        else
        {
          if (this->seq_parser_)
          {
            this->seq_parser_->post_seqType ();
            this->seq ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

          if (this->area_parser_)
            this->area_parser_->pre ();
        }
        else
        {
          if (this->area_parser_)
          {
            this->area_parser_->post_areaType ();
            this->area ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for mdWrap_pskel.
  //
  bool mdWrap_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "binData" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "xmlData" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &mdWrap_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool mdWrap_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void mdWrap_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void mdWrap_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void mdWrap_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->binData_parser_;

          if (this->binData_parser_)
            this->binData_parser_->pre ();
        }
        else
        {
          if (this->binData_parser_)
          {
            ::std::auto_ptr< ::xml_schema::buffer > tmp (this->binData_parser_->post_base64_binary ());
            this->binData (tmp);
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->xmlData_parser_;

          if (this->xmlData_parser_)
            this->xmlData_parser_->pre ();
        }
        else
        {
          if (this->xmlData_parser_)
          {
            this->xmlData_parser_->post_xmlData ();
            this->xmlData ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for agent_pskel.
  //
  bool agent_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &agent_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "name",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool agent_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void agent_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void agent_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "name");

    this->v_state_stack_.pop ();
  }

  void agent_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

            if (this->name_parser_)
              this->name_parser_->pre ();
          }
          else
          {
            if (this->name_parser_)
            {
              const ::std::string& tmp (this->name_parser_->post_string ());
              this->name (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "name",
              ns, n);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "note" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->note_parser_;

            if (this->note_parser_)
              this->note_parser_->pre ();
          }
          else
          {
            if (this->note_parser_)
            {
              const ::std::string& tmp (this->note_parser_->post_string ());
              this->note (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for FContent_pskel.
  //
  bool FContent_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "binData" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "xmlData" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &FContent_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool FContent_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void FContent_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void FContent_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void FContent_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->binData_parser_;

          if (this->binData_parser_)
            this->binData_parser_->pre ();
        }
        else
        {
          if (this->binData_parser_)
          {
            ::std::auto_ptr< ::xml_schema::buffer > tmp (this->binData_parser_->post_base64_binary ());
            this->binData (tmp);
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->xmlData_parser_;

          if (this->xmlData_parser_)
            this->xmlData_parser_->pre ();
        }
        else
        {
          if (this->xmlData_parser_)
          {
            this->xmlData_parser_->post_xmlData1 ();
            this->xmlData ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for par_pskel.
  //
  bool par_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "area" &&
            ns == "http://www.loc.gov/METS/")
          s = 0UL;
        else if (n == "seq" &&
                 ns == "http://www.loc.gov/METS/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &par_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://www.loc.gov/METS/", "area",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool par_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void par_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void par_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://www.loc.gov/METS/", "area");

    this->v_state_stack_.pop ();
  }

  void par_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "area" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

            if (this->area_parser_)
              this->area_parser_->pre ();
          }
          else
          {
            if (this->area_parser_)
            {
              this->area_parser_->post_areaType ();
              this->area ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (n == "seq" &&
            ns == "http://www.loc.gov/METS/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->seq_parser_;

            if (this->seq_parser_)
              this->seq_parser_->pre ();
          }
          else
          {
            if (this->seq_parser_)
            {
              this->seq_parser_->post_seqType ();
              this->seq ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for xmlData_pskel.
  //
  bool xmlData_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (!n.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &xmlData_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "##any", "*",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool xmlData_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void xmlData_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void xmlData_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "##any", "*");

    this->v_state_stack_.pop ();
  }

  void xmlData_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (!n.empty ())
        {
          if (start)
          {
            this->_start_any_element (ns, n, t);
            this->::xml_schema::complex_content::context_.top ().any_ = true;
          }
          else
          {
            this->::xml_schema::complex_content::context_.top ().any_ = false;
            this->_end_any_element (ns, n);
            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "##any", "*",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for xmlData1_pskel.
  //
  bool xmlData1_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (!n.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &xmlData1_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "##any", "*",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool xmlData1_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void xmlData1_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void xmlData1_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "##any", "*");

    this->v_state_stack_.pop ();
  }

  void xmlData1_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (!n.empty ())
        {
          if (start)
          {
            this->_start_any_element (ns, n, t);
            this->::xml_schema::complex_content::context_.top ().any_ = true;
          }
          else
          {
            this->::xml_schema::complex_content::context_.top ().any_ = false;
            this->_end_any_element (ns, n);
            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "##any", "*",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace METS
{
  // Attribute validation and dispatch functions for metsType_pskel.
  //
  bool metsType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "OBJID" && ns.empty ())
    {
      if (this->OBJID_parser_)
      {
        this->OBJID_parser_->pre ();
        this->OBJID_parser_->_pre_impl ();
        this->OBJID_parser_->_characters (s);
        this->OBJID_parser_->_post_impl ();
        const ::std::string& tmp (this->OBJID_parser_->post_string ());
        this->OBJID (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->TYPE_parser_->post_string ());
        this->TYPE (tmp);
      }

      return true;
    }

    if (n == "PROFILE" && ns.empty ())
    {
      if (this->PROFILE_parser_)
      {
        this->PROFILE_parser_->pre ();
        this->PROFILE_parser_->_pre_impl ();
        this->PROFILE_parser_->_characters (s);
        this->PROFILE_parser_->_post_impl ();
        const ::std::string& tmp (this->PROFILE_parser_->post_string ());
        this->PROFILE (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for amdSecType_pskel.
  //
  bool amdSecType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for fileGrpType_pskel.
  //
  bool fileGrpType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "VERSDATE" && ns.empty ())
    {
      if (this->VERSDATE_parser_)
      {
        this->VERSDATE_parser_->pre ();
        this->VERSDATE_parser_->_pre_impl ();
        this->VERSDATE_parser_->_characters (s);
        this->VERSDATE_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->VERSDATE_parser_->post_date_time ());
        this->VERSDATE (tmp);
      }

      return true;
    }

    if (n == "ADMID" && ns.empty ())
    {
      if (this->ADMID_parser_)
      {
        this->ADMID_parser_->pre ();
        this->ADMID_parser_->_pre_impl ();
        this->ADMID_parser_->_characters (s);
        this->ADMID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->ADMID_parser_->post_idrefs ());
        this->ADMID (tmp);
      }

      return true;
    }

    if (n == "USE" && ns.empty ())
    {
      if (this->USE_parser_)
      {
        this->USE_parser_->pre ();
        this->USE_parser_->_pre_impl ();
        this->USE_parser_->_characters (s);
        this->USE_parser_->_post_impl ();
        const ::std::string& tmp (this->USE_parser_->post_string ());
        this->USE (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for structMapType_pskel.
  //
  bool structMapType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->TYPE_parser_->post_string ());
        this->TYPE (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for divType_pskel.
  //
  bool divType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "ORDER" && ns.empty ())
    {
      if (this->ORDER_parser_)
      {
        this->ORDER_parser_->pre ();
        this->ORDER_parser_->_pre_impl ();
        this->ORDER_parser_->_characters (s);
        this->ORDER_parser_->_post_impl ();
        long long tmp (this->ORDER_parser_->post_integer ());
        this->ORDER (tmp);
      }

      return true;
    }

    if (n == "ORDERLABEL" && ns.empty ())
    {
      if (this->ORDERLABEL_parser_)
      {
        this->ORDERLABEL_parser_->pre ();
        this->ORDERLABEL_parser_->_pre_impl ();
        this->ORDERLABEL_parser_->_characters (s);
        this->ORDERLABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->ORDERLABEL_parser_->post_string ());
        this->ORDERLABEL (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    if (n == "DMDID" && ns.empty ())
    {
      if (this->DMDID_parser_)
      {
        this->DMDID_parser_->pre ();
        this->DMDID_parser_->_pre_impl ();
        this->DMDID_parser_->_characters (s);
        this->DMDID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->DMDID_parser_->post_idrefs ());
        this->DMDID (tmp);
      }

      return true;
    }

    if (n == "ADMID" && ns.empty ())
    {
      if (this->ADMID_parser_)
      {
        this->ADMID_parser_->pre ();
        this->ADMID_parser_->_pre_impl ();
        this->ADMID_parser_->_characters (s);
        this->ADMID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->ADMID_parser_->post_idrefs ());
        this->ADMID (tmp);
      }

      return true;
    }

    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->TYPE_parser_->post_string ());
        this->TYPE (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for seqType_pskel.
  //
  bool seqType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for areaType_pskel.
  //
  bool areaType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "FILEID" && ns.empty ())
    {
      if (this->FILEID_parser_)
      {
        this->FILEID_parser_->pre ();
        this->FILEID_parser_->_pre_impl ();
        this->FILEID_parser_->_characters (s);
        this->FILEID_parser_->_post_impl ();
        const ::std::string& tmp (this->FILEID_parser_->post_idref ());
        this->FILEID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->FILEID = true;
      return true;
    }

    if (n == "SHAPE" && ns.empty ())
    {
      if (this->SHAPE_parser_)
      {
        this->SHAPE_parser_->pre ();
        this->SHAPE_parser_->_pre_impl ();
        this->SHAPE_parser_->_characters (s);
        this->SHAPE_parser_->_post_impl ();
        this->SHAPE_parser_->post_SHAPE ();
        this->SHAPE ();
      }

      return true;
    }

    if (n == "COORDS" && ns.empty ())
    {
      if (this->COORDS_parser_)
      {
        this->COORDS_parser_->pre ();
        this->COORDS_parser_->_pre_impl ();
        this->COORDS_parser_->_characters (s);
        this->COORDS_parser_->_post_impl ();
        const ::std::string& tmp (this->COORDS_parser_->post_string ());
        this->COORDS (tmp);
      }

      return true;
    }

    if (n == "BEGIN" && ns.empty ())
    {
      if (this->BEGIN_parser_)
      {
        this->BEGIN_parser_->pre ();
        this->BEGIN_parser_->_pre_impl ();
        this->BEGIN_parser_->_characters (s);
        this->BEGIN_parser_->_post_impl ();
        const ::std::string& tmp (this->BEGIN_parser_->post_string ());
        this->BEGIN (tmp);
      }

      return true;
    }

    if (n == "END" && ns.empty ())
    {
      if (this->END_parser_)
      {
        this->END_parser_->pre ();
        this->END_parser_->_pre_impl ();
        this->END_parser_->_characters (s);
        this->END_parser_->_post_impl ();
        const ::std::string& tmp (this->END_parser_->post_string ());
        this->END (tmp);
      }

      return true;
    }

    if (n == "BETYPE" && ns.empty ())
    {
      if (this->BETYPE_parser_)
      {
        this->BETYPE_parser_->pre ();
        this->BETYPE_parser_->_pre_impl ();
        this->BETYPE_parser_->_characters (s);
        this->BETYPE_parser_->_post_impl ();
        this->BETYPE_parser_->post_BETYPE ();
        this->BETYPE ();
      }

      return true;
    }

    if (n == "EXTENT" && ns.empty ())
    {
      if (this->EXTENT_parser_)
      {
        this->EXTENT_parser_->pre ();
        this->EXTENT_parser_->_pre_impl ();
        this->EXTENT_parser_->_characters (s);
        this->EXTENT_parser_->_post_impl ();
        const ::std::string& tmp (this->EXTENT_parser_->post_string ());
        this->EXTENT (tmp);
      }

      return true;
    }

    if (n == "EXTTYPE" && ns.empty ())
    {
      if (this->EXTTYPE_parser_)
      {
        this->EXTTYPE_parser_->pre ();
        this->EXTTYPE_parser_->_pre_impl ();
        this->EXTTYPE_parser_->_characters (s);
        this->EXTTYPE_parser_->_post_impl ();
        this->EXTTYPE_parser_->post_EXTTYPE ();
        this->EXTTYPE ();
      }

      return true;
    }

    if (n == "ADMID" && ns.empty ())
    {
      if (this->ADMID_parser_)
      {
        this->ADMID_parser_->pre ();
        this->ADMID_parser_->_pre_impl ();
        this->ADMID_parser_->_characters (s);
        this->ADMID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->ADMID_parser_->post_idrefs ());
        this->ADMID (tmp);
      }

      return true;
    }

    return false;
  }

  void areaType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.FILEID = false;
  }

  void areaType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.FILEID)
      this->_expected_attribute (
        "", "FILEID");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for behaviorSecType_pskel.
  //
  bool behaviorSecType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "CREATED" && ns.empty ())
    {
      if (this->CREATED_parser_)
      {
        this->CREATED_parser_->pre ();
        this->CREATED_parser_->_pre_impl ();
        this->CREATED_parser_->_characters (s);
        this->CREATED_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->CREATED_parser_->post_date_time ());
        this->CREATED (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for behaviorType_pskel.
  //
  bool behaviorType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    if (n == "STRUCTID" && ns.empty ())
    {
      if (this->STRUCTID_parser_)
      {
        this->STRUCTID_parser_->pre ();
        this->STRUCTID_parser_->_pre_impl ();
        this->STRUCTID_parser_->_characters (s);
        this->STRUCTID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->STRUCTID_parser_->post_idrefs ());
        this->STRUCTID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->STRUCTID = true;
      return true;
    }

    if (n == "BTYPE" && ns.empty ())
    {
      if (this->BTYPE_parser_)
      {
        this->BTYPE_parser_->pre ();
        this->BTYPE_parser_->_pre_impl ();
        this->BTYPE_parser_->_characters (s);
        this->BTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->BTYPE_parser_->post_string ());
        this->BTYPE (tmp);
      }

      return true;
    }

    if (n == "CREATED" && ns.empty ())
    {
      if (this->CREATED_parser_)
      {
        this->CREATED_parser_->pre ();
        this->CREATED_parser_->_pre_impl ();
        this->CREATED_parser_->_characters (s);
        this->CREATED_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->CREATED_parser_->post_date_time ());
        this->CREATED (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    if (n == "GROUPID" && ns.empty ())
    {
      if (this->GROUPID_parser_)
      {
        this->GROUPID_parser_->pre ();
        this->GROUPID_parser_->_pre_impl ();
        this->GROUPID_parser_->_characters (s);
        this->GROUPID_parser_->_post_impl ();
        const ::std::string& tmp (this->GROUPID_parser_->post_string ());
        this->GROUPID (tmp);
      }

      return true;
    }

    if (n == "ADMID" && ns.empty ())
    {
      if (this->ADMID_parser_)
      {
        this->ADMID_parser_->pre ();
        this->ADMID_parser_->_pre_impl ();
        this->ADMID_parser_->_characters (s);
        this->ADMID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->ADMID_parser_->post_idrefs ());
        this->ADMID (tmp);
      }

      return true;
    }

    return false;
  }

  void behaviorType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
    as.STRUCTID = false;
  }

  void behaviorType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");
    if (!as.STRUCTID)
      this->_expected_attribute (
        "", "STRUCTID");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for objectType_pskel.
  //
  bool objectType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    if (n == "LOCTYPE" && ns.empty ())
    {
      if (this->LOCTYPE_parser_)
      {
        this->LOCTYPE_parser_->pre ();
        this->LOCTYPE_parser_->_pre_impl ();
        this->LOCTYPE_parser_->_characters (s);
        this->LOCTYPE_parser_->_post_impl ();
        this->LOCTYPE_parser_->post_LOCTYPE ();
        this->LOCTYPE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->LOCTYPE = true;
      return true;
    }

    if (n == "OTHERLOCTYPE" && ns.empty ())
    {
      if (this->OTHERLOCTYPE_parser_)
      {
        this->OTHERLOCTYPE_parser_->pre ();
        this->OTHERLOCTYPE_parser_->_pre_impl ();
        this->OTHERLOCTYPE_parser_->_characters (s);
        this->OTHERLOCTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERLOCTYPE_parser_->post_string ());
        this->OTHERLOCTYPE (tmp);
      }

      return true;
    }

    if (n == "type" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_string ());
        this->type (tmp);
      }

      return true;
    }

    if (n == "href" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();
        this->href_parser_->_pre_impl ();
        this->href_parser_->_characters (s);
        this->href_parser_->_post_impl ();
        const ::std::string& tmp (this->href_parser_->post_uri ());
        this->href (tmp);
      }

      return true;
    }

    if (n == "role" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->role_parser_)
      {
        this->role_parser_->pre ();
        this->role_parser_->_pre_impl ();
        this->role_parser_->_characters (s);
        this->role_parser_->_post_impl ();
        const ::std::string& tmp (this->role_parser_->post_string ());
        this->role (tmp);
      }

      return true;
    }

    if (n == "arcrole" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->arcrole_parser_)
      {
        this->arcrole_parser_->pre ();
        this->arcrole_parser_->_pre_impl ();
        this->arcrole_parser_->_characters (s);
        this->arcrole_parser_->_post_impl ();
        const ::std::string& tmp (this->arcrole_parser_->post_string ());
        this->arcrole (tmp);
      }

      return true;
    }

    if (n == "title" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "show" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->show_parser_)
      {
        this->show_parser_->pre ();
        this->show_parser_->_pre_impl ();
        this->show_parser_->_characters (s);
        this->show_parser_->_post_impl ();
        this->show_parser_->post_show ();
        this->show ();
      }

      return true;
    }

    if (n == "actuate" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->actuate_parser_)
      {
        this->actuate_parser_->pre ();
        this->actuate_parser_->_pre_impl ();
        this->actuate_parser_->_characters (s);
        this->actuate_parser_->_post_impl ();
        this->actuate_parser_->post_actuate ();
        this->actuate ();
      }

      return true;
    }

    return false;
  }

  void objectType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.LOCTYPE = false;
  }

  void objectType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.LOCTYPE)
      this->_expected_attribute (
        "", "LOCTYPE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for mdSecType_pskel.
  //
  bool mdSecType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    if (n == "GROUPID" && ns.empty ())
    {
      if (this->GROUPID_parser_)
      {
        this->GROUPID_parser_->pre ();
        this->GROUPID_parser_->_pre_impl ();
        this->GROUPID_parser_->_characters (s);
        this->GROUPID_parser_->_post_impl ();
        const ::std::string& tmp (this->GROUPID_parser_->post_string ());
        this->GROUPID (tmp);
      }

      return true;
    }

    if (n == "ADMID" && ns.empty ())
    {
      if (this->ADMID_parser_)
      {
        this->ADMID_parser_->pre ();
        this->ADMID_parser_->_pre_impl ();
        this->ADMID_parser_->_characters (s);
        this->ADMID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->ADMID_parser_->post_idrefs ());
        this->ADMID (tmp);
      }

      return true;
    }

    if (n == "CREATED" && ns.empty ())
    {
      if (this->CREATED_parser_)
      {
        this->CREATED_parser_->pre ();
        this->CREATED_parser_->_pre_impl ();
        this->CREATED_parser_->_characters (s);
        this->CREATED_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->CREATED_parser_->post_date_time ());
        this->CREATED (tmp);
      }

      return true;
    }

    if (n == "STATUS" && ns.empty ())
    {
      if (this->STATUS_parser_)
      {
        this->STATUS_parser_->pre ();
        this->STATUS_parser_->_pre_impl ();
        this->STATUS_parser_->_characters (s);
        this->STATUS_parser_->_post_impl ();
        const ::std::string& tmp (this->STATUS_parser_->post_string ());
        this->STATUS (tmp);
      }

      return true;
    }

    return false;
  }

  void mdSecType_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
  }

  void mdSecType_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for metsHdr_pskel.
  //
  bool metsHdr_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "CREATEDATE" && ns.empty ())
    {
      if (this->CREATEDATE_parser_)
      {
        this->CREATEDATE_parser_->pre ();
        this->CREATEDATE_parser_->_pre_impl ();
        this->CREATEDATE_parser_->_characters (s);
        this->CREATEDATE_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->CREATEDATE_parser_->post_date_time ());
        this->CREATEDATE (tmp);
      }

      return true;
    }

    if (n == "LASTMODDATE" && ns.empty ())
    {
      if (this->LASTMODDATE_parser_)
      {
        this->LASTMODDATE_parser_->pre ();
        this->LASTMODDATE_parser_->_pre_impl ();
        this->LASTMODDATE_parser_->_characters (s);
        this->LASTMODDATE_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->LASTMODDATE_parser_->post_date_time ());
        this->LASTMODDATE (tmp);
      }

      return true;
    }

    if (n == "RECORDSTATUS" && ns.empty ())
    {
      if (this->RECORDSTATUS_parser_)
      {
        this->RECORDSTATUS_parser_->pre ();
        this->RECORDSTATUS_parser_->_pre_impl ();
        this->RECORDSTATUS_parser_->_characters (s);
        this->RECORDSTATUS_parser_->_post_impl ();
        const ::std::string& tmp (this->RECORDSTATUS_parser_->post_string ());
        this->RECORDSTATUS (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for fileSec_pskel.
  //
  bool fileSec_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for file_pskel.
  //
  bool file_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ID = true;
      return true;
    }

    if (n == "MIMETYPE" && ns.empty ())
    {
      if (this->MIMETYPE_parser_)
      {
        this->MIMETYPE_parser_->pre ();
        this->MIMETYPE_parser_->_pre_impl ();
        this->MIMETYPE_parser_->_characters (s);
        this->MIMETYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->MIMETYPE_parser_->post_string ());
        this->MIMETYPE (tmp);
      }

      return true;
    }

    if (n == "SEQ" && ns.empty ())
    {
      if (this->SEQ_parser_)
      {
        this->SEQ_parser_->pre ();
        this->SEQ_parser_->_pre_impl ();
        this->SEQ_parser_->_characters (s);
        this->SEQ_parser_->_post_impl ();
        int tmp (this->SEQ_parser_->post_int ());
        this->SEQ (tmp);
      }

      return true;
    }

    if (n == "SIZE" && ns.empty ())
    {
      if (this->SIZE_parser_)
      {
        this->SIZE_parser_->pre ();
        this->SIZE_parser_->_pre_impl ();
        this->SIZE_parser_->_characters (s);
        this->SIZE_parser_->_post_impl ();
        long long tmp (this->SIZE_parser_->post_long ());
        this->SIZE (tmp);
      }

      return true;
    }

    if (n == "CREATED" && ns.empty ())
    {
      if (this->CREATED_parser_)
      {
        this->CREATED_parser_->pre ();
        this->CREATED_parser_->_pre_impl ();
        this->CREATED_parser_->_characters (s);
        this->CREATED_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->CREATED_parser_->post_date_time ());
        this->CREATED (tmp);
      }

      return true;
    }

    if (n == "CHECKSUM" && ns.empty ())
    {
      if (this->CHECKSUM_parser_)
      {
        this->CHECKSUM_parser_->pre ();
        this->CHECKSUM_parser_->_pre_impl ();
        this->CHECKSUM_parser_->_characters (s);
        this->CHECKSUM_parser_->_post_impl ();
        const ::std::string& tmp (this->CHECKSUM_parser_->post_string ());
        this->CHECKSUM (tmp);
      }

      return true;
    }

    if (n == "CHECKSUMTYPE" && ns.empty ())
    {
      if (this->CHECKSUMTYPE_parser_)
      {
        this->CHECKSUMTYPE_parser_->pre ();
        this->CHECKSUMTYPE_parser_->_pre_impl ();
        this->CHECKSUMTYPE_parser_->_characters (s);
        this->CHECKSUMTYPE_parser_->_post_impl ();
        this->CHECKSUMTYPE_parser_->post_CHECKSUMTYPE ();
        this->CHECKSUMTYPE ();
      }

      return true;
    }

    if (n == "OWNERID" && ns.empty ())
    {
      if (this->OWNERID_parser_)
      {
        this->OWNERID_parser_->pre ();
        this->OWNERID_parser_->_pre_impl ();
        this->OWNERID_parser_->_characters (s);
        this->OWNERID_parser_->_post_impl ();
        const ::std::string& tmp (this->OWNERID_parser_->post_string ());
        this->OWNERID (tmp);
      }

      return true;
    }

    if (n == "ADMID" && ns.empty ())
    {
      if (this->ADMID_parser_)
      {
        this->ADMID_parser_->pre ();
        this->ADMID_parser_->_pre_impl ();
        this->ADMID_parser_->_characters (s);
        this->ADMID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->ADMID_parser_->post_idrefs ());
        this->ADMID (tmp);
      }

      return true;
    }

    if (n == "DMDID" && ns.empty ())
    {
      if (this->DMDID_parser_)
      {
        this->DMDID_parser_->pre ();
        this->DMDID_parser_->_pre_impl ();
        this->DMDID_parser_->_characters (s);
        this->DMDID_parser_->_post_impl ();
        const ::xml_schema::string_sequence& tmp (this->DMDID_parser_->post_idrefs ());
        this->DMDID (tmp);
      }

      return true;
    }

    if (n == "GROUPID" && ns.empty ())
    {
      if (this->GROUPID_parser_)
      {
        this->GROUPID_parser_->pre ();
        this->GROUPID_parser_->_pre_impl ();
        this->GROUPID_parser_->_characters (s);
        this->GROUPID_parser_->_post_impl ();
        const ::std::string& tmp (this->GROUPID_parser_->post_string ());
        this->GROUPID (tmp);
      }

      return true;
    }

    if (n == "USE" && ns.empty ())
    {
      if (this->USE_parser_)
      {
        this->USE_parser_->pre ();
        this->USE_parser_->_pre_impl ();
        this->USE_parser_->_characters (s);
        this->USE_parser_->_post_impl ();
        const ::std::string& tmp (this->USE_parser_->post_string ());
        this->USE (tmp);
      }

      return true;
    }

    return false;
  }

  void file_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ID = false;
  }

  void file_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ID)
      this->_expected_attribute (
        "", "ID");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for mptr_pskel.
  //
  bool mptr_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "LOCTYPE" && ns.empty ())
    {
      if (this->LOCTYPE_parser_)
      {
        this->LOCTYPE_parser_->pre ();
        this->LOCTYPE_parser_->_pre_impl ();
        this->LOCTYPE_parser_->_characters (s);
        this->LOCTYPE_parser_->_post_impl ();
        this->LOCTYPE_parser_->post_LOCTYPE ();
        this->LOCTYPE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->LOCTYPE = true;
      return true;
    }

    if (n == "OTHERLOCTYPE" && ns.empty ())
    {
      if (this->OTHERLOCTYPE_parser_)
      {
        this->OTHERLOCTYPE_parser_->pre ();
        this->OTHERLOCTYPE_parser_->_pre_impl ();
        this->OTHERLOCTYPE_parser_->_characters (s);
        this->OTHERLOCTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERLOCTYPE_parser_->post_string ());
        this->OTHERLOCTYPE (tmp);
      }

      return true;
    }

    if (n == "type" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_string ());
        this->type (tmp);
      }

      return true;
    }

    if (n == "href" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();
        this->href_parser_->_pre_impl ();
        this->href_parser_->_characters (s);
        this->href_parser_->_post_impl ();
        const ::std::string& tmp (this->href_parser_->post_uri ());
        this->href (tmp);
      }

      return true;
    }

    if (n == "role" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->role_parser_)
      {
        this->role_parser_->pre ();
        this->role_parser_->_pre_impl ();
        this->role_parser_->_characters (s);
        this->role_parser_->_post_impl ();
        const ::std::string& tmp (this->role_parser_->post_string ());
        this->role (tmp);
      }

      return true;
    }

    if (n == "arcrole" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->arcrole_parser_)
      {
        this->arcrole_parser_->pre ();
        this->arcrole_parser_->_pre_impl ();
        this->arcrole_parser_->_characters (s);
        this->arcrole_parser_->_post_impl ();
        const ::std::string& tmp (this->arcrole_parser_->post_string ());
        this->arcrole (tmp);
      }

      return true;
    }

    if (n == "title" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "show" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->show_parser_)
      {
        this->show_parser_->pre ();
        this->show_parser_->_pre_impl ();
        this->show_parser_->_characters (s);
        this->show_parser_->_post_impl ();
        this->show_parser_->post_show ();
        this->show ();
      }

      return true;
    }

    if (n == "actuate" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->actuate_parser_)
      {
        this->actuate_parser_->pre ();
        this->actuate_parser_->_pre_impl ();
        this->actuate_parser_->_characters (s);
        this->actuate_parser_->_post_impl ();
        this->actuate_parser_->post_actuate ();
        this->actuate ();
      }

      return true;
    }

    return false;
  }

  void mptr_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.LOCTYPE = false;
  }

  void mptr_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.LOCTYPE)
      this->_expected_attribute (
        "", "LOCTYPE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for fptr_pskel.
  //
  bool fptr_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "FILEID" && ns.empty ())
    {
      if (this->FILEID_parser_)
      {
        this->FILEID_parser_->pre ();
        this->FILEID_parser_->_pre_impl ();
        this->FILEID_parser_->_characters (s);
        this->FILEID_parser_->_post_impl ();
        const ::std::string& tmp (this->FILEID_parser_->post_idref ());
        this->FILEID (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for smLink_pskel.
  //
  bool smLink_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "arcrole" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->arcrole_parser_)
      {
        this->arcrole_parser_->pre ();
        this->arcrole_parser_->_pre_impl ();
        this->arcrole_parser_->_characters (s);
        this->arcrole_parser_->_post_impl ();
        const ::std::string& tmp (this->arcrole_parser_->post_string ());
        this->arcrole (tmp);
      }

      return true;
    }

    if (n == "title" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "show" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->show_parser_)
      {
        this->show_parser_->pre ();
        this->show_parser_->_pre_impl ();
        this->show_parser_->_characters (s);
        this->show_parser_->_post_impl ();
        this->show_parser_->post_show ();
        this->show ();
      }

      return true;
    }

    if (n == "actuate" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->actuate_parser_)
      {
        this->actuate_parser_->pre ();
        this->actuate_parser_->_pre_impl ();
        this->actuate_parser_->_characters (s);
        this->actuate_parser_->_post_impl ();
        this->actuate_parser_->post_actuate ();
        this->actuate ();
      }

      return true;
    }

    if (n == "to" && ns.empty ())
    {
      if (this->to_parser_)
      {
        this->to_parser_->pre ();
        this->to_parser_->_pre_impl ();
        this->to_parser_->_characters (s);
        this->to_parser_->_post_impl ();
        const ::std::string& tmp (this->to_parser_->post_idref ());
        this->to (tmp);
      }

      return true;
    }

    if (n == "from" && ns.empty ())
    {
      if (this->from_parser_)
      {
        this->from_parser_->pre ();
        this->from_parser_->_pre_impl ();
        this->from_parser_->_characters (s);
        this->from_parser_->_post_impl ();
        const ::std::string& tmp (this->from_parser_->post_idref ());
        this->from (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for mdRef_pskel.
  //
  bool mdRef_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "LOCTYPE" && ns.empty ())
    {
      if (this->LOCTYPE_parser_)
      {
        this->LOCTYPE_parser_->pre ();
        this->LOCTYPE_parser_->_pre_impl ();
        this->LOCTYPE_parser_->_characters (s);
        this->LOCTYPE_parser_->_post_impl ();
        this->LOCTYPE_parser_->post_LOCTYPE ();
        this->LOCTYPE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->LOCTYPE = true;
      return true;
    }

    if (n == "OTHERLOCTYPE" && ns.empty ())
    {
      if (this->OTHERLOCTYPE_parser_)
      {
        this->OTHERLOCTYPE_parser_->pre ();
        this->OTHERLOCTYPE_parser_->_pre_impl ();
        this->OTHERLOCTYPE_parser_->_characters (s);
        this->OTHERLOCTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERLOCTYPE_parser_->post_string ());
        this->OTHERLOCTYPE (tmp);
      }

      return true;
    }

    if (n == "type" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_string ());
        this->type (tmp);
      }

      return true;
    }

    if (n == "href" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();
        this->href_parser_->_pre_impl ();
        this->href_parser_->_characters (s);
        this->href_parser_->_post_impl ();
        const ::std::string& tmp (this->href_parser_->post_uri ());
        this->href (tmp);
      }

      return true;
    }

    if (n == "role" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->role_parser_)
      {
        this->role_parser_->pre ();
        this->role_parser_->_pre_impl ();
        this->role_parser_->_characters (s);
        this->role_parser_->_post_impl ();
        const ::std::string& tmp (this->role_parser_->post_string ());
        this->role (tmp);
      }

      return true;
    }

    if (n == "arcrole" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->arcrole_parser_)
      {
        this->arcrole_parser_->pre ();
        this->arcrole_parser_->_pre_impl ();
        this->arcrole_parser_->_characters (s);
        this->arcrole_parser_->_post_impl ();
        const ::std::string& tmp (this->arcrole_parser_->post_string ());
        this->arcrole (tmp);
      }

      return true;
    }

    if (n == "title" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "show" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->show_parser_)
      {
        this->show_parser_->pre ();
        this->show_parser_->_pre_impl ();
        this->show_parser_->_characters (s);
        this->show_parser_->_post_impl ();
        this->show_parser_->post_show ();
        this->show ();
      }

      return true;
    }

    if (n == "actuate" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->actuate_parser_)
      {
        this->actuate_parser_->pre ();
        this->actuate_parser_->_pre_impl ();
        this->actuate_parser_->_characters (s);
        this->actuate_parser_->_post_impl ();
        this->actuate_parser_->post_actuate ();
        this->actuate ();
      }

      return true;
    }

    if (n == "MDTYPE" && ns.empty ())
    {
      if (this->MDTYPE_parser_)
      {
        this->MDTYPE_parser_->pre ();
        this->MDTYPE_parser_->_pre_impl ();
        this->MDTYPE_parser_->_characters (s);
        this->MDTYPE_parser_->_post_impl ();
        this->MDTYPE_parser_->post_MDTYPE ();
        this->MDTYPE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->MDTYPE = true;
      return true;
    }

    if (n == "OTHERMDTYPE" && ns.empty ())
    {
      if (this->OTHERMDTYPE_parser_)
      {
        this->OTHERMDTYPE_parser_->pre ();
        this->OTHERMDTYPE_parser_->_pre_impl ();
        this->OTHERMDTYPE_parser_->_characters (s);
        this->OTHERMDTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERMDTYPE_parser_->post_string ());
        this->OTHERMDTYPE (tmp);
      }

      return true;
    }

    if (n == "MIMETYPE" && ns.empty ())
    {
      if (this->MIMETYPE_parser_)
      {
        this->MIMETYPE_parser_->pre ();
        this->MIMETYPE_parser_->_pre_impl ();
        this->MIMETYPE_parser_->_characters (s);
        this->MIMETYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->MIMETYPE_parser_->post_string ());
        this->MIMETYPE (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    if (n == "XPTR" && ns.empty ())
    {
      if (this->XPTR_parser_)
      {
        this->XPTR_parser_->pre ();
        this->XPTR_parser_->_pre_impl ();
        this->XPTR_parser_->_characters (s);
        this->XPTR_parser_->_post_impl ();
        const ::std::string& tmp (this->XPTR_parser_->post_string ());
        this->XPTR (tmp);
      }

      return true;
    }

    return false;
  }

  void mdRef_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.LOCTYPE = false;
    as.MDTYPE = false;
  }

  void mdRef_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.LOCTYPE)
      this->_expected_attribute (
        "", "LOCTYPE");
    if (!as.MDTYPE)
      this->_expected_attribute (
        "", "MDTYPE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for mdWrap_pskel.
  //
  bool mdWrap_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "MIMETYPE" && ns.empty ())
    {
      if (this->MIMETYPE_parser_)
      {
        this->MIMETYPE_parser_->pre ();
        this->MIMETYPE_parser_->_pre_impl ();
        this->MIMETYPE_parser_->_characters (s);
        this->MIMETYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->MIMETYPE_parser_->post_string ());
        this->MIMETYPE (tmp);
      }

      return true;
    }

    if (n == "MDTYPE" && ns.empty ())
    {
      if (this->MDTYPE_parser_)
      {
        this->MDTYPE_parser_->pre ();
        this->MDTYPE_parser_->_pre_impl ();
        this->MDTYPE_parser_->_characters (s);
        this->MDTYPE_parser_->_post_impl ();
        this->MDTYPE_parser_->post_MDTYPE ();
        this->MDTYPE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->MDTYPE = true;
      return true;
    }

    if (n == "OTHERMDTYPE" && ns.empty ())
    {
      if (this->OTHERMDTYPE_parser_)
      {
        this->OTHERMDTYPE_parser_->pre ();
        this->OTHERMDTYPE_parser_->_pre_impl ();
        this->OTHERMDTYPE_parser_->_characters (s);
        this->OTHERMDTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERMDTYPE_parser_->post_string ());
        this->OTHERMDTYPE (tmp);
      }

      return true;
    }

    if (n == "LABEL" && ns.empty ())
    {
      if (this->LABEL_parser_)
      {
        this->LABEL_parser_->pre ();
        this->LABEL_parser_->_pre_impl ();
        this->LABEL_parser_->_characters (s);
        this->LABEL_parser_->_post_impl ();
        const ::std::string& tmp (this->LABEL_parser_->post_string ());
        this->LABEL (tmp);
      }

      return true;
    }

    return false;
  }

  void mdWrap_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.MDTYPE = false;
  }

  void mdWrap_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.MDTYPE)
      this->_expected_attribute (
        "", "MDTYPE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for agent_pskel.
  //
  bool agent_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "ROLE" && ns.empty ())
    {
      if (this->ROLE_parser_)
      {
        this->ROLE_parser_->pre ();
        this->ROLE_parser_->_pre_impl ();
        this->ROLE_parser_->_characters (s);
        this->ROLE_parser_->_post_impl ();
        this->ROLE_parser_->post_ROLE ();
        this->ROLE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ROLE = true;
      return true;
    }

    if (n == "OTHERROLE" && ns.empty ())
    {
      if (this->OTHERROLE_parser_)
      {
        this->OTHERROLE_parser_->pre ();
        this->OTHERROLE_parser_->_pre_impl ();
        this->OTHERROLE_parser_->_characters (s);
        this->OTHERROLE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERROLE_parser_->post_string ());
        this->OTHERROLE (tmp);
      }

      return true;
    }

    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        this->TYPE_parser_->post_TYPE ();
        this->TYPE ();
      }

      return true;
    }

    if (n == "OTHERTYPE" && ns.empty ())
    {
      if (this->OTHERTYPE_parser_)
      {
        this->OTHERTYPE_parser_->pre ();
        this->OTHERTYPE_parser_->_pre_impl ();
        this->OTHERTYPE_parser_->_characters (s);
        this->OTHERTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERTYPE_parser_->post_string ());
        this->OTHERTYPE (tmp);
      }

      return true;
    }

    return false;
  }

  void agent_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ROLE = false;
  }

  void agent_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ROLE)
      this->_expected_attribute (
        "", "ROLE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for altRecordID_pskel.
  //
  bool altRecordID_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "TYPE" && ns.empty ())
    {
      if (this->TYPE_parser_)
      {
        this->TYPE_parser_->pre ();
        this->TYPE_parser_->_pre_impl ();
        this->TYPE_parser_->_characters (s);
        this->TYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->TYPE_parser_->post_string ());
        this->TYPE (tmp);
      }

      return true;
    }

    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for FLocat_pskel.
  //
  bool FLocat_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    if (n == "LOCTYPE" && ns.empty ())
    {
      if (this->LOCTYPE_parser_)
      {
        this->LOCTYPE_parser_->pre ();
        this->LOCTYPE_parser_->_pre_impl ();
        this->LOCTYPE_parser_->_characters (s);
        this->LOCTYPE_parser_->_post_impl ();
        this->LOCTYPE_parser_->post_LOCTYPE ();
        this->LOCTYPE ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->LOCTYPE = true;
      return true;
    }

    if (n == "OTHERLOCTYPE" && ns.empty ())
    {
      if (this->OTHERLOCTYPE_parser_)
      {
        this->OTHERLOCTYPE_parser_->pre ();
        this->OTHERLOCTYPE_parser_->_pre_impl ();
        this->OTHERLOCTYPE_parser_->_characters (s);
        this->OTHERLOCTYPE_parser_->_post_impl ();
        const ::std::string& tmp (this->OTHERLOCTYPE_parser_->post_string ());
        this->OTHERLOCTYPE (tmp);
      }

      return true;
    }

    if (n == "USE" && ns.empty ())
    {
      if (this->USE_parser_)
      {
        this->USE_parser_->pre ();
        this->USE_parser_->_pre_impl ();
        this->USE_parser_->_characters (s);
        this->USE_parser_->_post_impl ();
        const ::std::string& tmp (this->USE_parser_->post_string ());
        this->USE (tmp);
      }

      return true;
    }

    if (n == "type" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_string ());
        this->type (tmp);
      }

      return true;
    }

    if (n == "href" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();
        this->href_parser_->_pre_impl ();
        this->href_parser_->_characters (s);
        this->href_parser_->_post_impl ();
        const ::std::string& tmp (this->href_parser_->post_uri ());
        this->href (tmp);
      }

      return true;
    }

    if (n == "role" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->role_parser_)
      {
        this->role_parser_->pre ();
        this->role_parser_->_pre_impl ();
        this->role_parser_->_characters (s);
        this->role_parser_->_post_impl ();
        const ::std::string& tmp (this->role_parser_->post_string ());
        this->role (tmp);
      }

      return true;
    }

    if (n == "arcrole" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->arcrole_parser_)
      {
        this->arcrole_parser_->pre ();
        this->arcrole_parser_->_pre_impl ();
        this->arcrole_parser_->_characters (s);
        this->arcrole_parser_->_post_impl ();
        const ::std::string& tmp (this->arcrole_parser_->post_string ());
        this->arcrole (tmp);
      }

      return true;
    }

    if (n == "title" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "show" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->show_parser_)
      {
        this->show_parser_->pre ();
        this->show_parser_->_pre_impl ();
        this->show_parser_->_characters (s);
        this->show_parser_->_post_impl ();
        this->show_parser_->post_show ();
        this->show ();
      }

      return true;
    }

    if (n == "actuate" &&
        ns == "http://www.w3.org/TR/xlink")
    {
      if (this->actuate_parser_)
      {
        this->actuate_parser_->pre ();
        this->actuate_parser_->_pre_impl ();
        this->actuate_parser_->_characters (s);
        this->actuate_parser_->_post_impl ();
        this->actuate_parser_->post_actuate ();
        this->actuate ();
      }

      return true;
    }

    return false;
  }

  void FLocat_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.LOCTYPE = false;
  }

  void FLocat_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.LOCTYPE)
      this->_expected_attribute (
        "", "LOCTYPE");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for FContent_pskel.
  //
  bool FContent_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "USE" && ns.empty ())
    {
      if (this->USE_parser_)
      {
        this->USE_parser_->pre ();
        this->USE_parser_->_pre_impl ();
        this->USE_parser_->_characters (s);
        this->USE_parser_->_post_impl ();
        const ::std::string& tmp (this->USE_parser_->post_string ());
        this->USE (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for par_pskel.
  //
  bool par_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
      {
        this->ID_parser_->pre ();
        this->ID_parser_->_pre_impl ();
        this->ID_parser_->_characters (s);
        this->ID_parser_->_post_impl ();
        const ::std::string& tmp (this->ID_parser_->post_id ());
        this->ID (tmp);
      }

      return true;
    }

    return false;
  }
}

namespace METS
{
}

// Begin epilogue.
//
//
// End epilogue.

