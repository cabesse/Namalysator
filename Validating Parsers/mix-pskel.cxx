// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "mix-pskel.hxx"

namespace mix
{
  // mixType_pskel
  //

  void mixType_pskel::
  BasicImageParameters ()
  {
  }

  void mixType_pskel::
  ImageCreation ()
  {
  }

  void mixType_pskel::
  ImagingPerformanceAssessment ()
  {
  }

  void mixType_pskel::
  ChangeHistory ()
  {
  }

  void mixType_pskel::
  post_mixType ()
  {
  }

  // BasicImageParametersType_pskel
  //

  void BasicImageParametersType_pskel::
  Format ()
  {
  }

  void BasicImageParametersType_pskel::
  File ()
  {
  }

  void BasicImageParametersType_pskel::
  PreferredPresentation ()
  {
  }

  void BasicImageParametersType_pskel::
  post_BasicImageParametersType ()
  {
  }

  // ImageCreationType_pskel
  //

  void ImageCreationType_pskel::
  SourceType ()
  {
  }

  void ImageCreationType_pskel::
  SourceID ()
  {
  }

  void ImageCreationType_pskel::
  ImageProducer ()
  {
  }

  void ImageCreationType_pskel::
  Host ()
  {
  }

  void ImageCreationType_pskel::
  DeviceSource ()
  {
  }

  void ImageCreationType_pskel::
  ScanningSystemCapture ()
  {
  }

  void ImageCreationType_pskel::
  DigitalCameraCapture ()
  {
  }

  void ImageCreationType_pskel::
  CameraCaptureSettings ()
  {
  }

  void ImageCreationType_pskel::
  Sensor ()
  {
  }

  void ImageCreationType_pskel::
  DateTimeCreated ()
  {
  }

  void ImageCreationType_pskel::
  Methodology ()
  {
  }

  void ImageCreationType_pskel::
  post_ImageCreationType ()
  {
  }

  // ImagingPerformanceAssessmentType_pskel
  //

  void ImagingPerformanceAssessmentType_pskel::
  SpatialMetrics ()
  {
  }

  void ImagingPerformanceAssessmentType_pskel::
  Energetics ()
  {
  }

  void ImagingPerformanceAssessmentType_pskel::
  TargetData ()
  {
  }

  void ImagingPerformanceAssessmentType_pskel::
  post_ImagingPerformanceAssessmentType ()
  {
  }

  // ChangeHistoryType_pskel
  //

  void ChangeHistoryType_pskel::
  ImageProcessing ()
  {
  }

  void ChangeHistoryType_pskel::
  PreviousImageMetadata ()
  {
  }

  void ChangeHistoryType_pskel::
  post_ChangeHistoryType ()
  {
  }

  // FormatType_pskel
  //

  void FormatType_pskel::
  post_FormatType ()
  {
  }

  // typeOfFormatType_pskel
  //

  void typeOfFormatType_pskel::
  use ()
  {
  }

  void typeOfFormatType_pskel::
  post_typeOfFormatType ()
  {
    post_FormatType ();
  }

  // ByteOrderType_pskel
  //

  void ByteOrderType_pskel::
  post_ByteOrderType ()
  {
  }

  // typeOfByteOrderType_pskel
  //

  void typeOfByteOrderType_pskel::
  use ()
  {
  }

  void typeOfByteOrderType_pskel::
  post_typeOfByteOrderType ()
  {
    post_ByteOrderType ();
  }

  // CompressionSchemeType_pskel
  //

  void CompressionSchemeType_pskel::
  post_CompressionSchemeType ()
  {
  }

  // typeOfCompressionSchemeType_pskel
  //

  void typeOfCompressionSchemeType_pskel::
  use ()
  {
  }

  void typeOfCompressionSchemeType_pskel::
  post_typeOfCompressionSchemeType ()
  {
    post_CompressionSchemeType ();
  }

  // CompressionLevelType_pskel
  //

  void CompressionLevelType_pskel::
  post_CompressionLevelType ()
  {
  }

  // typeOfCompressionLevelType_pskel
  //

  void typeOfCompressionLevelType_pskel::
  use ()
  {
  }

  void typeOfCompressionLevelType_pskel::
  post_typeOfCompressionLevelType ()
  {
    post_CompressionLevelType ();
  }

  // ColorSpaceType_pskel
  //

  void ColorSpaceType_pskel::
  post_ColorSpaceType ()
  {
  }

  // typeOfColorSpaceType_pskel
  //

  void typeOfColorSpaceType_pskel::
  use ()
  {
  }

  void typeOfColorSpaceType_pskel::
  post_typeOfColorSpaceType ()
  {
    post_ColorSpaceType ();
  }

  // typeOfProfileNameType_pskel
  //

  void typeOfProfileNameType_pskel::
  use ()
  {
  }

  void typeOfProfileNameType_pskel::
  post_typeOfProfileNameType ()
  {
  }

  // typeOfProfileURLType_pskel
  //

  void typeOfProfileURLType_pskel::
  use ()
  {
  }

  void typeOfProfileURLType_pskel::
  post_typeOfProfileURLType ()
  {
  }

  // YCbCrSubSamplingType_pskel
  //

  void YCbCrSubSamplingType_pskel::
  post_YCbCrSubSamplingType ()
  {
  }

  // typeOfYCbCrSubSamplingType_pskel
  //

  void typeOfYCbCrSubSamplingType_pskel::
  use ()
  {
  }

  void typeOfYCbCrSubSamplingType_pskel::
  post_typeOfYCbCrSubSamplingType ()
  {
    post_YCbCrSubSamplingType ();
  }

  // YCbCrPositioningType_pskel
  //

  void YCbCrPositioningType_pskel::
  post_YCbCrPositioningType ()
  {
  }

  // typeOfYCbCrPositioningType_pskel
  //

  void typeOfYCbCrPositioningType_pskel::
  use ()
  {
  }

  void typeOfYCbCrPositioningType_pskel::
  post_typeOfYCbCrPositioningType ()
  {
    post_YCbCrPositioningType ();
  }

  // YcbCrCoefficientsType_pskel
  //

  void YcbCrCoefficientsType_pskel::
  post_YcbCrCoefficientsType ()
  {
  }

  // typeOfYcbCrCoefficientsType_pskel
  //

  void typeOfYcbCrCoefficientsType_pskel::
  use ()
  {
  }

  void typeOfYcbCrCoefficientsType_pskel::
  post_typeOfYcbCrCoefficientsType ()
  {
    post_YcbCrCoefficientsType ();
  }

  // ReferenceBlackWhiteType_pskel
  //

  void ReferenceBlackWhiteType_pskel::
  post_ReferenceBlackWhiteType ()
  {
  }

  // typeOfReferenceBlackWhiteType_pskel
  //

  void typeOfReferenceBlackWhiteType_pskel::
  use ()
  {
  }

  void typeOfReferenceBlackWhiteType_pskel::
  post_typeOfReferenceBlackWhiteType ()
  {
    post_ReferenceBlackWhiteType ();
  }

  // SegmentTypeType_pskel
  //

  void SegmentTypeType_pskel::
  post_SegmentTypeType ()
  {
  }

  // typeOfSegmentTypeType_pskel
  //

  void typeOfSegmentTypeType_pskel::
  use ()
  {
  }

  void typeOfSegmentTypeType_pskel::
  post_typeOfSegmentTypeType ()
  {
    post_SegmentTypeType ();
  }

  // StripOffsetsType_pskel
  //

  void StripOffsetsType_pskel::
  post_StripOffsetsType ()
  {
  }

  // typeOfStripOffsetsType_pskel
  //

  void typeOfStripOffsetsType_pskel::
  use ()
  {
  }

  void typeOfStripOffsetsType_pskel::
  post_typeOfStripOffsetsType ()
  {
    post_StripOffsetsType ();
  }

  // RowsPerStripType_pskel
  //

  void RowsPerStripType_pskel::
  post_RowsPerStripType ()
  {
  }

  // typeOfRowsPerStripType_pskel
  //

  void typeOfRowsPerStripType_pskel::
  use ()
  {
  }

  void typeOfRowsPerStripType_pskel::
  post_typeOfRowsPerStripType ()
  {
    post_RowsPerStripType ();
  }

  // StripByteCountsType_pskel
  //

  void StripByteCountsType_pskel::
  post_StripByteCountsType ()
  {
  }

  // typeOfStripByteCountsType_pskel
  //

  void typeOfStripByteCountsType_pskel::
  use ()
  {
  }

  void typeOfStripByteCountsType_pskel::
  post_typeOfStripByteCountsType ()
  {
    post_StripByteCountsType ();
  }

  // TileWidthType_pskel
  //

  void TileWidthType_pskel::
  post_TileWidthType ()
  {
  }

  // typeOfTileWidthType_pskel
  //

  void typeOfTileWidthType_pskel::
  use ()
  {
  }

  void typeOfTileWidthType_pskel::
  post_typeOfTileWidthType ()
  {
    post_TileWidthType ();
  }

  // TileLengthType_pskel
  //

  void TileLengthType_pskel::
  post_TileLengthType ()
  {
  }

  // typeOfTileLengthType_pskel
  //

  void typeOfTileLengthType_pskel::
  use ()
  {
  }

  void typeOfTileLengthType_pskel::
  post_typeOfTileLengthType ()
  {
    post_TileLengthType ();
  }

  // TileOffsetsType_pskel
  //

  void TileOffsetsType_pskel::
  post_TileOffsetsType ()
  {
  }

  // typeOfTileOffsetsType_pskel
  //

  void typeOfTileOffsetsType_pskel::
  use ()
  {
  }

  void typeOfTileOffsetsType_pskel::
  post_typeOfTileOffsetsType ()
  {
    post_TileOffsetsType ();
  }

  // TileByteCountsType_pskel
  //

  void TileByteCountsType_pskel::
  post_TileByteCountsType ()
  {
  }

  // typeOfTileByteCountsType_pskel
  //

  void typeOfTileByteCountsType_pskel::
  use ()
  {
  }

  void typeOfTileByteCountsType_pskel::
  post_typeOfTileByteCountsType ()
  {
    post_TileByteCountsType ();
  }

  // PlanarConfigurationType_pskel
  //

  void PlanarConfigurationType_pskel::
  post_PlanarConfigurationType ()
  {
  }

  // typeOfPlanarConfigurationType_pskel
  //

  void typeOfPlanarConfigurationType_pskel::
  use ()
  {
  }

  void typeOfPlanarConfigurationType_pskel::
  post_typeOfPlanarConfigurationType ()
  {
    post_PlanarConfigurationType ();
  }

  // ImageIdentifierType_pskel
  //

  void ImageIdentifierType_pskel::
  post_ImageIdentifierType ()
  {
  }

  // typeOfImageIdentifierType_pskel
  //

  void typeOfImageIdentifierType_pskel::
  use ()
  {
  }

  void typeOfImageIdentifierType_pskel::
  imageIdentifierLocation ()
  {
  }

  void typeOfImageIdentifierType_pskel::
  post_typeOfImageIdentifierType ()
  {
    post_ImageIdentifierType ();
  }

  // FileSizeType_pskel
  //

  void FileSizeType_pskel::
  post_FileSizeType ()
  {
  }

  // typeOfFileSizeType_pskel
  //

  void typeOfFileSizeType_pskel::
  use ()
  {
  }

  void typeOfFileSizeType_pskel::
  post_typeOfFileSizeType ()
  {
    post_FileSizeType ();
  }

  // ChecksumMethodType_pskel
  //

  void ChecksumMethodType_pskel::
  post_ChecksumMethodType ()
  {
  }

  // typeOfChecksumMethodType_pskel
  //

  void typeOfChecksumMethodType_pskel::
  use ()
  {
  }

  void typeOfChecksumMethodType_pskel::
  post_typeOfChecksumMethodType ()
  {
    post_ChecksumMethodType ();
  }

  // ChecksumValueType_pskel
  //

  void ChecksumValueType_pskel::
  post_ChecksumValueType ()
  {
  }

  // typeOfChecksumValueType_pskel
  //

  void typeOfChecksumValueType_pskel::
  use ()
  {
  }

  void typeOfChecksumValueType_pskel::
  post_typeOfChecksumValueType ()
  {
    post_ChecksumValueType ();
  }

  // OrientationType_pskel
  //

  void OrientationType_pskel::
  post_OrientationType ()
  {
  }

  // typeOfOrientationType_pskel
  //

  void typeOfOrientationType_pskel::
  use ()
  {
  }

  void typeOfOrientationType_pskel::
  post_typeOfOrientationType ()
  {
    post_OrientationType ();
  }

  // DisplayOrientationType_pskel
  //

  void DisplayOrientationType_pskel::
  post_DisplayOrientationType ()
  {
  }

  // typeOfDisplayOrientationType_pskel
  //

  void typeOfDisplayOrientationType_pskel::
  use ()
  {
  }

  void typeOfDisplayOrientationType_pskel::
  post_typeOfDisplayOrientationType ()
  {
    post_DisplayOrientationType ();
  }

  // XTargetedDisplayARType_pskel
  //

  void XTargetedDisplayARType_pskel::
  post_XTargetedDisplayARType ()
  {
  }

  // typeOfXTargetedDisplayARType_pskel
  //

  void typeOfXTargetedDisplayARType_pskel::
  use ()
  {
  }

  void typeOfXTargetedDisplayARType_pskel::
  post_typeOfXTargetedDisplayARType ()
  {
    post_XTargetedDisplayARType ();
  }

  // YTargetedDisplayARType_pskel
  //

  void YTargetedDisplayARType_pskel::
  post_YTargetedDisplayARType ()
  {
  }

  // typeOfYTargetedDisplayARType_pskel
  //

  void typeOfYTargetedDisplayARType_pskel::
  use ()
  {
  }

  void typeOfYTargetedDisplayARType_pskel::
  post_typeOfYTargetedDisplayARType ()
  {
    post_YTargetedDisplayARType ();
  }

  // PreferredPresentationType_pskel
  //

  void PreferredPresentationType_pskel::
  post_PreferredPresentationType ()
  {
  }

  // typeOfPreferredPresentationType_pskel
  //

  void typeOfPreferredPresentationType_pskel::
  use ()
  {
  }

  void typeOfPreferredPresentationType_pskel::
  post_typeOfPreferredPresentationType ()
  {
    post_PreferredPresentationType ();
  }

  // SourceTypeType_pskel
  //

  void SourceTypeType_pskel::
  post_SourceTypeType ()
  {
  }

  // typeOfSourceTypeType_pskel
  //

  void typeOfSourceTypeType_pskel::
  use ()
  {
  }

  void typeOfSourceTypeType_pskel::
  post_typeOfSourceTypeType ()
  {
    post_SourceTypeType ();
  }

  // SourceIDType_pskel
  //

  void SourceIDType_pskel::
  post_SourceIDType ()
  {
  }

  // typeOfSourceIDType_pskel
  //

  void typeOfSourceIDType_pskel::
  use ()
  {
  }

  void typeOfSourceIDType_pskel::
  post_typeOfSourceIDType ()
  {
    post_SourceIDType ();
  }

  // ImageProducerType_pskel
  //

  void ImageProducerType_pskel::
  post_ImageProducerType ()
  {
  }

  // typeOfImageProducerType_pskel
  //

  void typeOfImageProducerType_pskel::
  use ()
  {
  }

  void typeOfImageProducerType_pskel::
  post_typeOfImageProducerType ()
  {
    post_ImageProducerType ();
  }

  // SubjectDistanceType_pskel
  //

  void SubjectDistanceType_pskel::
  post_SubjectDistanceType ()
  {
  }

  // typeOfSubjectDistanceType_pskel
  //

  void typeOfSubjectDistanceType_pskel::
  use ()
  {
  }

  void typeOfSubjectDistanceType_pskel::
  min ()
  {
  }

  void typeOfSubjectDistanceType_pskel::
  max ()
  {
  }

  void typeOfSubjectDistanceType_pskel::
  post_typeOfSubjectDistanceType ()
  {
    post_SubjectDistanceType ();
  }

  // MeteringModeType_pskel
  //

  void MeteringModeType_pskel::
  post_MeteringModeType ()
  {
  }

  // typeOfMeteringModeType_pskel
  //

  void typeOfMeteringModeType_pskel::
  use ()
  {
  }

  void typeOfMeteringModeType_pskel::
  post_typeOfMeteringModeType ()
  {
    post_MeteringModeType ();
  }

  // SceneIlluminantType_pskel
  //

  void SceneIlluminantType_pskel::
  post_SceneIlluminantType ()
  {
  }

  // typeOfSceneIlluminantType_pskel
  //

  void typeOfSceneIlluminantType_pskel::
  use ()
  {
  }

  void typeOfSceneIlluminantType_pskel::
  post_typeOfSceneIlluminantType ()
  {
    post_SceneIlluminantType ();
  }

  // FlashType_pskel
  //

  void FlashType_pskel::
  post_FlashType ()
  {
  }

  // typeOfFlashType_pskel
  //

  void typeOfFlashType_pskel::
  use ()
  {
  }

  void typeOfFlashType_pskel::
  post_typeOfFlashType ()
  {
    post_FlashType ();
  }

  // FlashReturnType_pskel
  //

  void FlashReturnType_pskel::
  post_FlashReturnType ()
  {
  }

  // typeOfFlashReturnType_pskel
  //

  void typeOfFlashReturnType_pskel::
  use ()
  {
  }

  void typeOfFlashReturnType_pskel::
  post_typeOfFlashReturnType ()
  {
    post_FlashReturnType ();
  }

  // BackLightType_pskel
  //

  void BackLightType_pskel::
  post_BackLightType ()
  {
  }

  // typeOfBackLightType_pskel
  //

  void typeOfBackLightType_pskel::
  use ()
  {
  }

  void typeOfBackLightType_pskel::
  post_typeOfBackLightType ()
  {
    post_BackLightType ();
  }

  // AutoFocusType_pskel
  //

  void AutoFocusType_pskel::
  post_AutoFocusType ()
  {
  }

  // typeOfAutoFocusType_pskel
  //

  void typeOfAutoFocusType_pskel::
  use ()
  {
  }

  void typeOfAutoFocusType_pskel::
  post_typeOfAutoFocusType ()
  {
    post_AutoFocusType ();
  }

  // SensorType_pskel
  //

  void SensorType_pskel::
  post_SensorType ()
  {
  }

  // typeOfSensorType_pskel
  //

  void typeOfSensorType_pskel::
  use ()
  {
  }

  void typeOfSensorType_pskel::
  post_typeOfSensorType ()
  {
    post_SensorType ();
  }

  // SamplingFrequencyPlaneType_pskel
  //

  void SamplingFrequencyPlaneType_pskel::
  post_SamplingFrequencyPlaneType ()
  {
  }

  // typeOfSamplingFrequencyPlaneType_pskel
  //

  void typeOfSamplingFrequencyPlaneType_pskel::
  use ()
  {
  }

  void typeOfSamplingFrequencyPlaneType_pskel::
  post_typeOfSamplingFrequencyPlaneType ()
  {
    post_SamplingFrequencyPlaneType ();
  }

  // SamplingFrequencyUnitType_pskel
  //

  void SamplingFrequencyUnitType_pskel::
  post_SamplingFrequencyUnitType ()
  {
  }

  // typeOfSamplingFrequencyUnitType_pskel
  //

  void typeOfSamplingFrequencyUnitType_pskel::
  use ()
  {
  }

  void typeOfSamplingFrequencyUnitType_pskel::
  post_typeOfSamplingFrequencyUnitType ()
  {
    post_SamplingFrequencyUnitType ();
  }

  // BitsPerSampleType_pskel
  //

  void BitsPerSampleType_pskel::
  post_BitsPerSampleType ()
  {
  }

  // typeOfBitsPerSampleType_pskel
  //

  void typeOfBitsPerSampleType_pskel::
  use ()
  {
  }

  void typeOfBitsPerSampleType_pskel::
  post_typeOfBitsPerSampleType ()
  {
    post_BitsPerSampleType ();
  }

  // SamplesPerPixelType_pskel
  //

  void SamplesPerPixelType_pskel::
  post_SamplesPerPixelType ()
  {
  }

  // typeOfSamplesPerPixelType_pskel
  //

  void typeOfSamplesPerPixelType_pskel::
  use ()
  {
  }

  void typeOfSamplesPerPixelType_pskel::
  post_typeOfSamplesPerPixelType ()
  {
    post_SamplesPerPixelType ();
  }

  // ExtraSamplesType_pskel
  //

  void ExtraSamplesType_pskel::
  post_ExtraSamplesType ()
  {
  }

  // typeOfExtraSamplesType_pskel
  //

  void typeOfExtraSamplesType_pskel::
  use ()
  {
  }

  void typeOfExtraSamplesType_pskel::
  post_typeOfExtraSamplesType ()
  {
    post_ExtraSamplesType ();
  }

  // ColormapType_pskel
  //

  void ColormapType_pskel::
  post_ColormapType ()
  {
  }

  // typeOfColormapType_pskel
  //

  void typeOfColormapType_pskel::
  use ()
  {
  }

  void typeOfColormapType_pskel::
  post_typeOfColormapType ()
  {
    post_ColormapType ();
  }

  // GrayResponseCurveType_pskel
  //

  void GrayResponseCurveType_pskel::
  post_GrayResponseCurveType ()
  {
  }

  // typeOfGrayResponseCurveType_pskel
  //

  void typeOfGrayResponseCurveType_pskel::
  use ()
  {
  }

  void typeOfGrayResponseCurveType_pskel::
  post_typeOfGrayResponseCurveType ()
  {
    post_GrayResponseCurveType ();
  }

  // GrayResponseUnitType_pskel
  //

  void GrayResponseUnitType_pskel::
  post_GrayResponseUnitType ()
  {
  }

  // typeOfGrayResponseUnitType_pskel
  //

  void typeOfGrayResponseUnitType_pskel::
  use ()
  {
  }

  void typeOfGrayResponseUnitType_pskel::
  post_typeOfGrayResponseUnitType ()
  {
    post_GrayResponseUnitType ();
  }

  // CIExyType_pskel
  //

  void CIExyType_pskel::
  post_CIExyType ()
  {
  }

  // typeOfCIExyType_pskel
  //

  void typeOfCIExyType_pskel::
  use ()
  {
  }

  void typeOfCIExyType_pskel::
  post_typeOfCIExyType ()
  {
    post_CIExyType ();
  }

  // TargetTypeType_pskel
  //

  void TargetTypeType_pskel::
  post_TargetTypeType ()
  {
  }

  // typeOfTargetTypeType_pskel
  //

  void typeOfTargetTypeType_pskel::
  use ()
  {
  }

  void typeOfTargetTypeType_pskel::
  post_typeOfTargetTypeType ()
  {
    post_TargetTypeType ();
  }

  // typeOfPreviousImageMetadataType_pskel
  //

  void typeOfPreviousImageMetadataType_pskel::
  post_typeOfPreviousImageMetadataType ()
  {
  }

  // StringType_pskel
  //

  void StringType_pskel::
  post_StringType ()
  {
  }

  // typeOfStringType_pskel
  //

  void typeOfStringType_pskel::
  use ()
  {
  }

  void typeOfStringType_pskel::
  post_typeOfStringType ()
  {
    post_StringType ();
  }

  // NonNegativeRealType_pskel
  //

  void NonNegativeRealType_pskel::
  post_NonNegativeRealType ()
  {
  }

  // typeOfNonNegativeRealType_pskel
  //

  void typeOfNonNegativeRealType_pskel::
  use ()
  {
  }

  void typeOfNonNegativeRealType_pskel::
  post_typeOfNonNegativeRealType ()
  {
    post_NonNegativeRealType ();
  }

  // PositiveIntegerType_pskel
  //

  void PositiveIntegerType_pskel::
  post_PositiveIntegerType ()
  {
  }

  // typeOfPositiveIntegerType_pskel
  //

  void typeOfPositiveIntegerType_pskel::
  use ()
  {
  }

  void typeOfPositiveIntegerType_pskel::
  post_typeOfPositiveIntegerType ()
  {
    post_PositiveIntegerType ();
  }

  // DateTimeType_pskel
  //

  void DateTimeType_pskel::
  post_DateTimeType ()
  {
  }

  // typeOfDateTimeType_pskel
  //

  void typeOfDateTimeType_pskel::
  use ()
  {
  }

  void typeOfDateTimeType_pskel::
  post_typeOfDateTimeType ()
  {
    post_DateTimeType ();
  }

  // ReferenceType_pskel
  //

  void ReferenceType_pskel::
  post_ReferenceType ()
  {
  }

  // typeOfReferenceType_pskel
  //

  void typeOfReferenceType_pskel::
  use ()
  {
  }

  void typeOfReferenceType_pskel::
  post_typeOfReferenceType ()
  {
    post_ReferenceType ();
  }

  // mix_pskel
  //

  void mix_pskel::
  post_mix ()
  {
    post_mixType ();
  }

  // Format_pskel
  //

  void Format_pskel::
  MIMEType ()
  {
  }

  void Format_pskel::
  ByteOrder ()
  {
  }

  void Format_pskel::
  Compression ()
  {
  }

  void Format_pskel::
  PhotometricInterpretation ()
  {
  }

  void Format_pskel::
  Segments ()
  {
  }

  void Format_pskel::
  PlanarConfiguration ()
  {
  }

  void Format_pskel::
  post_Format ()
  {
  }

  // File_pskel
  //

  void File_pskel::
  ImageIdentifier ()
  {
  }

  void File_pskel::
  FileSize ()
  {
  }

  void File_pskel::
  Checksum ()
  {
  }

  void File_pskel::
  Orientation ()
  {
  }

  void File_pskel::
  DisplayOrientation ()
  {
  }

  void File_pskel::
  TargetedDisplayAR ()
  {
  }

  void File_pskel::
  post_File ()
  {
  }

  // Host_pskel
  //

  void Host_pskel::
  HostComputer ()
  {
  }

  void Host_pskel::
  OperatingSystem ()
  {
  }

  void Host_pskel::
  OSVersion ()
  {
  }

  void Host_pskel::
  post_Host ()
  {
  }

  // ScanningSystemCapture_pskel
  //

  void ScanningSystemCapture_pskel::
  ScanningSystemHardware ()
  {
  }

  void ScanningSystemCapture_pskel::
  ScanningSystemSoftware ()
  {
  }

  void ScanningSystemCapture_pskel::
  ScannerCaptureSettings ()
  {
  }

  void ScanningSystemCapture_pskel::
  post_ScanningSystemCapture ()
  {
  }

  // DigitalCameraCapture_pskel
  //

  void DigitalCameraCapture_pskel::
  DigitalCameraManufacturer ()
  {
  }

  void DigitalCameraCapture_pskel::
  DigitalCameraModel ()
  {
  }

  void DigitalCameraCapture_pskel::
  post_DigitalCameraCapture ()
  {
  }

  // CameraCaptureSettings_pskel
  //

  void CameraCaptureSettings_pskel::
  FNumber ()
  {
  }

  void CameraCaptureSettings_pskel::
  ExposureTime ()
  {
  }

  void CameraCaptureSettings_pskel::
  Brightness ()
  {
  }

  void CameraCaptureSettings_pskel::
  ExposureBias ()
  {
  }

  void CameraCaptureSettings_pskel::
  SubjectDistance ()
  {
  }

  void CameraCaptureSettings_pskel::
  MeteringMode ()
  {
  }

  void CameraCaptureSettings_pskel::
  SceneIlluminant ()
  {
  }

  void CameraCaptureSettings_pskel::
  ColorTemp ()
  {
  }

  void CameraCaptureSettings_pskel::
  FocalLength ()
  {
  }

  void CameraCaptureSettings_pskel::
  Flash ()
  {
  }

  void CameraCaptureSettings_pskel::
  FlashEnergy ()
  {
  }

  void CameraCaptureSettings_pskel::
  FlashReturn ()
  {
  }

  void CameraCaptureSettings_pskel::
  BackLight ()
  {
  }

  void CameraCaptureSettings_pskel::
  ExposureIndex ()
  {
  }

  void CameraCaptureSettings_pskel::
  AutoFocus ()
  {
  }

  void CameraCaptureSettings_pskel::
  PrintAspectRatio ()
  {
  }

  void CameraCaptureSettings_pskel::
  post_CameraCaptureSettings ()
  {
  }

  // SpatialMetrics_pskel
  //

  void SpatialMetrics_pskel::
  SamplingFrequencyPlane ()
  {
  }

  void SpatialMetrics_pskel::
  SamplingFrequencyUnit ()
  {
  }

  void SpatialMetrics_pskel::
  XSamplingFrequency ()
  {
  }

  void SpatialMetrics_pskel::
  YSamplingFrequency ()
  {
  }

  void SpatialMetrics_pskel::
  ImageWidth ()
  {
  }

  void SpatialMetrics_pskel::
  ImageLength ()
  {
  }

  void SpatialMetrics_pskel::
  Source_X ()
  {
  }

  void SpatialMetrics_pskel::
  Source_Y ()
  {
  }

  void SpatialMetrics_pskel::
  post_SpatialMetrics ()
  {
  }

  // Energetics_pskel
  //

  void Energetics_pskel::
  BitsPerSample ()
  {
  }

  void Energetics_pskel::
  SamplesPerPixel ()
  {
  }

  void Energetics_pskel::
  ExtraSamples ()
  {
  }

  void Energetics_pskel::
  Colormap ()
  {
  }

  void Energetics_pskel::
  GrayResponse ()
  {
  }

  void Energetics_pskel::
  WhitePoint ()
  {
  }

  void Energetics_pskel::
  PrimaryChromaticities ()
  {
  }

  void Energetics_pskel::
  post_Energetics ()
  {
  }

  // TargetData_pskel
  //

  void TargetData_pskel::
  TargetType ()
  {
  }

  void TargetData_pskel::
  TargetID ()
  {
  }

  void TargetData_pskel::
  ImageData ()
  {
  }

  void TargetData_pskel::
  PerformanceData ()
  {
  }

  void TargetData_pskel::
  Profiles ()
  {
  }

  void TargetData_pskel::
  post_TargetData ()
  {
  }

  // ImageProcessing_pskel
  //

  void ImageProcessing_pskel::
  DateTimeProcessed ()
  {
  }

  void ImageProcessing_pskel::
  SourceData ()
  {
  }

  void ImageProcessing_pskel::
  ProcessingAgency ()
  {
  }

  void ImageProcessing_pskel::
  ProcessingSoftware ()
  {
  }

  void ImageProcessing_pskel::
  ProcessingActions ()
  {
  }

  void ImageProcessing_pskel::
  post_ImageProcessing ()
  {
  }

  // Compression_pskel
  //

  void Compression_pskel::
  CompressionScheme ()
  {
  }

  void Compression_pskel::
  CompressionLevel ()
  {
  }

  void Compression_pskel::
  post_Compression ()
  {
  }

  // PhotometricInterpretation_pskel
  //

  void PhotometricInterpretation_pskel::
  ColorSpace ()
  {
  }

  void PhotometricInterpretation_pskel::
  ICCProfile ()
  {
  }

  void PhotometricInterpretation_pskel::
  YCbCrSubSampling ()
  {
  }

  void PhotometricInterpretation_pskel::
  YCbCrPositioning ()
  {
  }

  void PhotometricInterpretation_pskel::
  YcbCrCoefficients ()
  {
  }

  void PhotometricInterpretation_pskel::
  ReferenceBlackWhite ()
  {
  }

  void PhotometricInterpretation_pskel::
  post_PhotometricInterpretation ()
  {
  }

  // Segments_pskel
  //

  void Segments_pskel::
  SegmentType ()
  {
  }

  void Segments_pskel::
  StripOffsets ()
  {
  }

  void Segments_pskel::
  RowsPerStrip ()
  {
  }

  void Segments_pskel::
  StripByteCounts ()
  {
  }

  void Segments_pskel::
  TileWidth ()
  {
  }

  void Segments_pskel::
  TileLength ()
  {
  }

  void Segments_pskel::
  TileOffsets ()
  {
  }

  void Segments_pskel::
  TileByteCounts ()
  {
  }

  void Segments_pskel::
  post_Segments ()
  {
  }

  // Checksum_pskel
  //

  void Checksum_pskel::
  ChecksumMethod ()
  {
  }

  void Checksum_pskel::
  ChecksumValue ()
  {
  }

  void Checksum_pskel::
  post_Checksum ()
  {
  }

  // TargetedDisplayAR_pskel
  //

  void TargetedDisplayAR_pskel::
  XTargetedDisplayAR ()
  {
  }

  void TargetedDisplayAR_pskel::
  YTargetedDisplayAR ()
  {
  }

  void TargetedDisplayAR_pskel::
  post_TargetedDisplayAR ()
  {
  }

  // ScanningSystemHardware_pskel
  //

  void ScanningSystemHardware_pskel::
  ScannerManufacturer ()
  {
  }

  void ScanningSystemHardware_pskel::
  ScannerModel ()
  {
  }

  void ScanningSystemHardware_pskel::
  post_ScanningSystemHardware ()
  {
  }

  // ScanningSystemSoftware_pskel
  //

  void ScanningSystemSoftware_pskel::
  ScanningSoftware ()
  {
  }

  void ScanningSystemSoftware_pskel::
  ScanningSoftwareVersionNo ()
  {
  }

  void ScanningSystemSoftware_pskel::
  post_ScanningSystemSoftware ()
  {
  }

  // ScannerCaptureSettings_pskel
  //

  void ScannerCaptureSettings_pskel::
  PixelSize ()
  {
  }

  void ScannerCaptureSettings_pskel::
  PhysScanResolution ()
  {
  }

  void ScannerCaptureSettings_pskel::
  post_ScannerCaptureSettings ()
  {
  }

  // PrintAspectRatio_pskel
  //

  void PrintAspectRatio_pskel::
  XPrintAspectRatio ()
  {
  }

  void PrintAspectRatio_pskel::
  YPrintAspectRatio ()
  {
  }

  void PrintAspectRatio_pskel::
  post_PrintAspectRatio ()
  {
  }

  // Source_X_pskel
  //

  void Source_X_pskel::
  Source_Xdimension ()
  {
  }

  void Source_X_pskel::
  Source_XdimensionUnit ()
  {
  }

  void Source_X_pskel::
  post_Source_X ()
  {
  }

  // Source_Y_pskel
  //

  void Source_Y_pskel::
  Source_Ydimension ()
  {
  }

  void Source_Y_pskel::
  Source_YdimensionUnit ()
  {
  }

  void Source_Y_pskel::
  post_Source_Y ()
  {
  }

  // Colormap_pskel
  //

  void Colormap_pskel::
  Colormap_BitCodeValue ()
  {
  }

  void Colormap_pskel::
  Colormap_RedValue ()
  {
  }

  void Colormap_pskel::
  Colormap_GreenValue ()
  {
  }

  void Colormap_pskel::
  Colormap_BlueValue ()
  {
  }

  void Colormap_pskel::
  post_Colormap ()
  {
  }

  // GrayResponse_pskel
  //

  void GrayResponse_pskel::
  GrayResponseCurve ()
  {
  }

  void GrayResponse_pskel::
  GrayResponseUnit ()
  {
  }

  void GrayResponse_pskel::
  post_GrayResponse ()
  {
  }

  // WhitePoint_pskel
  //

  void WhitePoint_pskel::
  WhitePoint_Xvalue ()
  {
  }

  void WhitePoint_pskel::
  WhitePoint_Yvalue ()
  {
  }

  void WhitePoint_pskel::
  post_WhitePoint ()
  {
  }

  // PrimaryChromaticities_pskel
  //

  void PrimaryChromaticities_pskel::
  PrimaryChromaticities_RedX ()
  {
  }

  void PrimaryChromaticities_pskel::
  PrimaryChromaticities_RedY ()
  {
  }

  void PrimaryChromaticities_pskel::
  PrimaryChromaticities_GreenX ()
  {
  }

  void PrimaryChromaticities_pskel::
  PrimaryChromaticities_GreenY ()
  {
  }

  void PrimaryChromaticities_pskel::
  PrimaryChromaticities_BlueX ()
  {
  }

  void PrimaryChromaticities_pskel::
  PrimaryChromaticities_BlueY ()
  {
  }

  void PrimaryChromaticities_pskel::
  post_PrimaryChromaticities ()
  {
  }

  // TargetID_pskel
  //

  void TargetID_pskel::
  TargetIDManufacturer ()
  {
  }

  void TargetID_pskel::
  TargetIDName ()
  {
  }

  void TargetID_pskel::
  TargetIDNo ()
  {
  }

  void TargetID_pskel::
  TargetIDMedia ()
  {
  }

  void TargetID_pskel::
  post_TargetID ()
  {
  }

  // ProcessingSoftware_pskel
  //

  void ProcessingSoftware_pskel::
  ProcessingSoftwareName ()
  {
  }

  void ProcessingSoftware_pskel::
  ProcessingSoftwareVersion ()
  {
  }

  void ProcessingSoftware_pskel::
  post_ProcessingSoftware ()
  {
  }

  // ICCProfile_pskel
  //

  void ICCProfile_pskel::
  ProfileName ()
  {
  }

  void ICCProfile_pskel::
  ProfileURL ()
  {
  }

  void ICCProfile_pskel::
  post_ICCProfile ()
  {
  }

  // ScannerModel_pskel
  //

  void ScannerModel_pskel::
  ScannerModelName ()
  {
  }

  void ScannerModel_pskel::
  ScannerModelNumber ()
  {
  }

  void ScannerModel_pskel::
  ScannerModelSerialNo ()
  {
  }

  void ScannerModel_pskel::
  post_ScannerModel ()
  {
  }

  // PhysScanResolution_pskel
  //

  void PhysScanResolution_pskel::
  XphysScanResolution ()
  {
  }

  void PhysScanResolution_pskel::
  YphysScanResolution ()
  {
  }

  void PhysScanResolution_pskel::
  post_PhysScanResolution ()
  {
  }
}

#include <cassert>

namespace mix
{
  // Element validation and dispatch functions for mixType_pskel.
  //
  bool mixType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "BasicImageParameters" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ImageCreation" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ImagingPerformanceAssessment" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "ChangeHistory" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &mixType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool mixType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void mixType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void mixType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void mixType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "BasicImageParameters" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->BasicImageParameters_parser_;

            if (this->BasicImageParameters_parser_)
              this->BasicImageParameters_parser_->pre ();
          }
          else
          {
            if (this->BasicImageParameters_parser_)
            {
              this->BasicImageParameters_parser_->post_BasicImageParametersType ();
              this->BasicImageParameters ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ImageCreation" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageCreation_parser_;

            if (this->ImageCreation_parser_)
              this->ImageCreation_parser_->pre ();
          }
          else
          {
            if (this->ImageCreation_parser_)
            {
              this->ImageCreation_parser_->post_ImageCreationType ();
              this->ImageCreation ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ImagingPerformanceAssessment" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImagingPerformanceAssessment_parser_;

            if (this->ImagingPerformanceAssessment_parser_)
              this->ImagingPerformanceAssessment_parser_->pre ();
          }
          else
          {
            if (this->ImagingPerformanceAssessment_parser_)
            {
              this->ImagingPerformanceAssessment_parser_->post_ImagingPerformanceAssessmentType ();
              this->ImagingPerformanceAssessment ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "ChangeHistory" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ChangeHistory_parser_;

            if (this->ChangeHistory_parser_)
              this->ChangeHistory_parser_->pre ();
          }
          else
          {
            if (this->ChangeHistory_parser_)
            {
              this->ChangeHistory_parser_->post_ChangeHistoryType ();
              this->ChangeHistory ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for BasicImageParametersType_pskel.
  //
  bool BasicImageParametersType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Format" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "File" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "PreferredPresentation" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &BasicImageParametersType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool BasicImageParametersType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void BasicImageParametersType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void BasicImageParametersType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void BasicImageParametersType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Format" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Format_parser_;

            if (this->Format_parser_)
              this->Format_parser_->pre ();
          }
          else
          {
            if (this->Format_parser_)
            {
              this->Format_parser_->post_Format ();
              this->Format ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "File" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->File_parser_;

            if (this->File_parser_)
              this->File_parser_->pre ();
          }
          else
          {
            if (this->File_parser_)
            {
              this->File_parser_->post_File ();
              this->File ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "PreferredPresentation" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PreferredPresentation_parser_;

            if (this->PreferredPresentation_parser_)
              this->PreferredPresentation_parser_->pre ();
          }
          else
          {
            if (this->PreferredPresentation_parser_)
            {
              this->PreferredPresentation_parser_->post_typeOfStringType ();
              this->PreferredPresentation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ImageCreationType_pskel.
  //
  bool ImageCreationType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "SourceType" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "SourceID" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ImageProducer" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "Host" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "DeviceSource" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "ScanningSystemCapture" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;
        else if (n == "DigitalCameraCapture" &&
                 ns == "http://www.loc.gov/mix/")
          s = 6UL;
        else if (n == "CameraCaptureSettings" &&
                 ns == "http://www.loc.gov/mix/")
          s = 7UL;
        else if (n == "Sensor" &&
                 ns == "http://www.loc.gov/mix/")
          s = 8UL;
        else if (n == "DateTimeCreated" &&
                 ns == "http://www.loc.gov/mix/")
          s = 9UL;
        else if (n == "Methodology" &&
                 ns == "http://www.loc.gov/mix/")
          s = 10UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ImageCreationType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ImageCreationType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ImageCreationType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ImageCreationType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ImageCreationType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "SourceType" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SourceType_parser_;

            if (this->SourceType_parser_)
              this->SourceType_parser_->pre ();
          }
          else
          {
            if (this->SourceType_parser_)
            {
              this->SourceType_parser_->post_typeOfStringType ();
              this->SourceType ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "SourceID" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SourceID_parser_;

            if (this->SourceID_parser_)
              this->SourceID_parser_->pre ();
          }
          else
          {
            if (this->SourceID_parser_)
            {
              this->SourceID_parser_->post_typeOfStringType ();
              this->SourceID ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ImageProducer" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageProducer_parser_;

            if (this->ImageProducer_parser_)
              this->ImageProducer_parser_->pre ();
          }
          else
          {
            if (this->ImageProducer_parser_)
            {
              this->ImageProducer_parser_->post_typeOfStringType ();
              this->ImageProducer ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "Host" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Host_parser_;

            if (this->Host_parser_)
              this->Host_parser_->pre ();
          }
          else
          {
            if (this->Host_parser_)
            {
              this->Host_parser_->post_Host ();
              this->Host ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "DeviceSource" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DeviceSource_parser_;

            if (this->DeviceSource_parser_)
              this->DeviceSource_parser_->pre ();
          }
          else
          {
            if (this->DeviceSource_parser_)
            {
              this->DeviceSource_parser_->post_typeOfStringType ();
              this->DeviceSource ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "ScanningSystemCapture" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScanningSystemCapture_parser_;

            if (this->ScanningSystemCapture_parser_)
              this->ScanningSystemCapture_parser_->pre ();
          }
          else
          {
            if (this->ScanningSystemCapture_parser_)
            {
              this->ScanningSystemCapture_parser_->post_ScanningSystemCapture ();
              this->ScanningSystemCapture ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "DigitalCameraCapture" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DigitalCameraCapture_parser_;

            if (this->DigitalCameraCapture_parser_)
              this->DigitalCameraCapture_parser_->pre ();
          }
          else
          {
            if (this->DigitalCameraCapture_parser_)
            {
              this->DigitalCameraCapture_parser_->post_DigitalCameraCapture ();
              this->DigitalCameraCapture ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "CameraCaptureSettings" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->CameraCaptureSettings_parser_;

            if (this->CameraCaptureSettings_parser_)
              this->CameraCaptureSettings_parser_->pre ();
          }
          else
          {
            if (this->CameraCaptureSettings_parser_)
            {
              this->CameraCaptureSettings_parser_->post_CameraCaptureSettings ();
              this->CameraCaptureSettings ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "Sensor" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Sensor_parser_;

            if (this->Sensor_parser_)
              this->Sensor_parser_->pre ();
          }
          else
          {
            if (this->Sensor_parser_)
            {
              this->Sensor_parser_->post_typeOfSensorType ();
              this->Sensor ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "DateTimeCreated" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DateTimeCreated_parser_;

            if (this->DateTimeCreated_parser_)
              this->DateTimeCreated_parser_->pre ();
          }
          else
          {
            if (this->DateTimeCreated_parser_)
            {
              this->DateTimeCreated_parser_->post_typeOfDateTimeType ();
              this->DateTimeCreated ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "Methodology" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Methodology_parser_;

            if (this->Methodology_parser_)
              this->Methodology_parser_->pre ();
          }
          else
          {
            if (this->Methodology_parser_)
            {
              this->Methodology_parser_->post_typeOfStringType ();
              this->Methodology ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ImagingPerformanceAssessmentType_pskel.
  //
  bool ImagingPerformanceAssessmentType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "SpatialMetrics" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "Energetics" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "TargetData" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ImagingPerformanceAssessmentType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ImagingPerformanceAssessmentType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ImagingPerformanceAssessmentType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ImagingPerformanceAssessmentType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ImagingPerformanceAssessmentType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "SpatialMetrics" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SpatialMetrics_parser_;

            if (this->SpatialMetrics_parser_)
              this->SpatialMetrics_parser_->pre ();
          }
          else
          {
            if (this->SpatialMetrics_parser_)
            {
              this->SpatialMetrics_parser_->post_SpatialMetrics ();
              this->SpatialMetrics ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "Energetics" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Energetics_parser_;

            if (this->Energetics_parser_)
              this->Energetics_parser_->pre ();
          }
          else
          {
            if (this->Energetics_parser_)
            {
              this->Energetics_parser_->post_Energetics ();
              this->Energetics ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "TargetData" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetData_parser_;

            if (this->TargetData_parser_)
              this->TargetData_parser_->pre ();
          }
          else
          {
            if (this->TargetData_parser_)
            {
              this->TargetData_parser_->post_TargetData ();
              this->TargetData ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ChangeHistoryType_pskel.
  //
  bool ChangeHistoryType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ImageProcessing" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "PreviousImageMetadata" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ChangeHistoryType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ChangeHistoryType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ChangeHistoryType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ChangeHistoryType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ChangeHistoryType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ImageProcessing" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageProcessing_parser_;

            if (this->ImageProcessing_parser_)
              this->ImageProcessing_parser_->pre ();
          }
          else
          {
            if (this->ImageProcessing_parser_)
            {
              this->ImageProcessing_parser_->post_ImageProcessing ();
              this->ImageProcessing ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "PreviousImageMetadata" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PreviousImageMetadata_parser_;

            if (this->PreviousImageMetadata_parser_)
              this->PreviousImageMetadata_parser_->pre ();
          }
          else
          {
            if (this->PreviousImageMetadata_parser_)
            {
              this->PreviousImageMetadata_parser_->post_typeOfPreviousImageMetadataType ();
              this->PreviousImageMetadata ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for typeOfPreviousImageMetadataType_pskel.
  //
  bool typeOfPreviousImageMetadataType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (!n.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &typeOfPreviousImageMetadataType_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool typeOfPreviousImageMetadataType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void typeOfPreviousImageMetadataType_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void typeOfPreviousImageMetadataType_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void typeOfPreviousImageMetadataType_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (!n.empty ())
        {
          if (start)
          {
            this->_start_any_element (ns, n, t);
            this->::xml_schema::complex_content::context_.top ().any_ = true;
          }
          else
          {
            this->::xml_schema::complex_content::context_.top ().any_ = false;
            this->_end_any_element (ns, n);
            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Format_pskel.
  //
  bool Format_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "MIMEType" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ByteOrder" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "Compression" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "PhotometricInterpretation" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "Segments" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "PlanarConfiguration" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Format_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Format_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Format_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Format_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Format_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "MIMEType" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->MIMEType_parser_;

            if (this->MIMEType_parser_)
              this->MIMEType_parser_->pre ();
          }
          else
          {
            if (this->MIMEType_parser_)
            {
              this->MIMEType_parser_->post_typeOfFormatType ();
              this->MIMEType ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ByteOrder" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ByteOrder_parser_;

            if (this->ByteOrder_parser_)
              this->ByteOrder_parser_->pre ();
          }
          else
          {
            if (this->ByteOrder_parser_)
            {
              this->ByteOrder_parser_->post_typeOfByteOrderType ();
              this->ByteOrder ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "Compression" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Compression_parser_;

            if (this->Compression_parser_)
              this->Compression_parser_->pre ();
          }
          else
          {
            if (this->Compression_parser_)
            {
              this->Compression_parser_->post_Compression ();
              this->Compression ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "PhotometricInterpretation" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PhotometricInterpretation_parser_;

            if (this->PhotometricInterpretation_parser_)
              this->PhotometricInterpretation_parser_->pre ();
          }
          else
          {
            if (this->PhotometricInterpretation_parser_)
            {
              this->PhotometricInterpretation_parser_->post_PhotometricInterpretation ();
              this->PhotometricInterpretation ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "Segments" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Segments_parser_;

            if (this->Segments_parser_)
              this->Segments_parser_->pre ();
          }
          else
          {
            if (this->Segments_parser_)
            {
              this->Segments_parser_->post_Segments ();
              this->Segments ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "PlanarConfiguration" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PlanarConfiguration_parser_;

            if (this->PlanarConfiguration_parser_)
              this->PlanarConfiguration_parser_->pre ();
          }
          else
          {
            if (this->PlanarConfiguration_parser_)
            {
              this->PlanarConfiguration_parser_->post_typeOfPlanarConfigurationType ();
              this->PlanarConfiguration ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for File_pskel.
  //
  bool File_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ImageIdentifier" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "FileSize" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "Checksum" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "Orientation" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "DisplayOrientation" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "TargetedDisplayAR" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &File_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool File_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void File_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void File_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void File_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ImageIdentifier" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageIdentifier_parser_;

            if (this->ImageIdentifier_parser_)
              this->ImageIdentifier_parser_->pre ();
          }
          else
          {
            if (this->ImageIdentifier_parser_)
            {
              this->ImageIdentifier_parser_->post_typeOfImageIdentifierType ();
              this->ImageIdentifier ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "FileSize" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FileSize_parser_;

            if (this->FileSize_parser_)
              this->FileSize_parser_->pre ();
          }
          else
          {
            if (this->FileSize_parser_)
            {
              this->FileSize_parser_->post_typeOfFileSizeType ();
              this->FileSize ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "Checksum" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Checksum_parser_;

            if (this->Checksum_parser_)
              this->Checksum_parser_->pre ();
          }
          else
          {
            if (this->Checksum_parser_)
            {
              this->Checksum_parser_->post_Checksum ();
              this->Checksum ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "Orientation" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Orientation_parser_;

            if (this->Orientation_parser_)
              this->Orientation_parser_->pre ();
          }
          else
          {
            if (this->Orientation_parser_)
            {
              this->Orientation_parser_->post_typeOfOrientationType ();
              this->Orientation ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "DisplayOrientation" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DisplayOrientation_parser_;

            if (this->DisplayOrientation_parser_)
              this->DisplayOrientation_parser_->pre ();
          }
          else
          {
            if (this->DisplayOrientation_parser_)
            {
              this->DisplayOrientation_parser_->post_typeOfDisplayOrientationType ();
              this->DisplayOrientation ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "TargetedDisplayAR" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetedDisplayAR_parser_;

            if (this->TargetedDisplayAR_parser_)
              this->TargetedDisplayAR_parser_->pre ();
          }
          else
          {
            if (this->TargetedDisplayAR_parser_)
            {
              this->TargetedDisplayAR_parser_->post_TargetedDisplayAR ();
              this->TargetedDisplayAR ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Host_pskel.
  //
  bool Host_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "HostComputer" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "OperatingSystem" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "OSVersion" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Host_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Host_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Host_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Host_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Host_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "HostComputer" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->HostComputer_parser_;

            if (this->HostComputer_parser_)
              this->HostComputer_parser_->pre ();
          }
          else
          {
            if (this->HostComputer_parser_)
            {
              this->HostComputer_parser_->post_typeOfStringType ();
              this->HostComputer ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "OperatingSystem" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->OperatingSystem_parser_;

            if (this->OperatingSystem_parser_)
              this->OperatingSystem_parser_->pre ();
          }
          else
          {
            if (this->OperatingSystem_parser_)
            {
              this->OperatingSystem_parser_->post_typeOfStringType ();
              this->OperatingSystem ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "OSVersion" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->OSVersion_parser_;

            if (this->OSVersion_parser_)
              this->OSVersion_parser_->pre ();
          }
          else
          {
            if (this->OSVersion_parser_)
            {
              this->OSVersion_parser_->post_typeOfStringType ();
              this->OSVersion ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ScanningSystemCapture_pskel.
  //
  bool ScanningSystemCapture_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ScanningSystemHardware" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ScanningSystemSoftware" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ScannerCaptureSettings" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ScanningSystemCapture_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ScanningSystemCapture_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ScanningSystemCapture_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ScanningSystemCapture_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ScanningSystemCapture_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ScanningSystemHardware" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScanningSystemHardware_parser_;

            if (this->ScanningSystemHardware_parser_)
              this->ScanningSystemHardware_parser_->pre ();
          }
          else
          {
            if (this->ScanningSystemHardware_parser_)
            {
              this->ScanningSystemHardware_parser_->post_ScanningSystemHardware ();
              this->ScanningSystemHardware ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ScanningSystemSoftware" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScanningSystemSoftware_parser_;

            if (this->ScanningSystemSoftware_parser_)
              this->ScanningSystemSoftware_parser_->pre ();
          }
          else
          {
            if (this->ScanningSystemSoftware_parser_)
            {
              this->ScanningSystemSoftware_parser_->post_ScanningSystemSoftware ();
              this->ScanningSystemSoftware ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ScannerCaptureSettings" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScannerCaptureSettings_parser_;

            if (this->ScannerCaptureSettings_parser_)
              this->ScannerCaptureSettings_parser_->pre ();
          }
          else
          {
            if (this->ScannerCaptureSettings_parser_)
            {
              this->ScannerCaptureSettings_parser_->post_ScannerCaptureSettings ();
              this->ScannerCaptureSettings ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for DigitalCameraCapture_pskel.
  //
  bool DigitalCameraCapture_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "DigitalCameraManufacturer" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "DigitalCameraModel" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &DigitalCameraCapture_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool DigitalCameraCapture_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void DigitalCameraCapture_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void DigitalCameraCapture_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void DigitalCameraCapture_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "DigitalCameraManufacturer" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DigitalCameraManufacturer_parser_;

            if (this->DigitalCameraManufacturer_parser_)
              this->DigitalCameraManufacturer_parser_->pre ();
          }
          else
          {
            if (this->DigitalCameraManufacturer_parser_)
            {
              this->DigitalCameraManufacturer_parser_->post_typeOfStringType ();
              this->DigitalCameraManufacturer ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "DigitalCameraModel" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DigitalCameraModel_parser_;

            if (this->DigitalCameraModel_parser_)
              this->DigitalCameraModel_parser_->pre ();
          }
          else
          {
            if (this->DigitalCameraModel_parser_)
            {
              this->DigitalCameraModel_parser_->post_typeOfStringType ();
              this->DigitalCameraModel ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CameraCaptureSettings_pskel.
  //
  bool CameraCaptureSettings_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "FNumber" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ExposureTime" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "Brightness" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "ExposureBias" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "SubjectDistance" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "MeteringMode" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;
        else if (n == "SceneIlluminant" &&
                 ns == "http://www.loc.gov/mix/")
          s = 6UL;
        else if (n == "ColorTemp" &&
                 ns == "http://www.loc.gov/mix/")
          s = 7UL;
        else if (n == "FocalLength" &&
                 ns == "http://www.loc.gov/mix/")
          s = 8UL;
        else if (n == "Flash" &&
                 ns == "http://www.loc.gov/mix/")
          s = 9UL;
        else if (n == "FlashEnergy" &&
                 ns == "http://www.loc.gov/mix/")
          s = 10UL;
        else if (n == "FlashReturn" &&
                 ns == "http://www.loc.gov/mix/")
          s = 11UL;
        else if (n == "BackLight" &&
                 ns == "http://www.loc.gov/mix/")
          s = 12UL;
        else if (n == "ExposureIndex" &&
                 ns == "http://www.loc.gov/mix/")
          s = 13UL;
        else if (n == "AutoFocus" &&
                 ns == "http://www.loc.gov/mix/")
          s = 14UL;
        else if (n == "PrintAspectRatio" &&
                 ns == "http://www.loc.gov/mix/")
          s = 15UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CameraCaptureSettings_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CameraCaptureSettings_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CameraCaptureSettings_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void CameraCaptureSettings_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void CameraCaptureSettings_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "FNumber" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FNumber_parser_;

            if (this->FNumber_parser_)
              this->FNumber_parser_->pre ();
          }
          else
          {
            if (this->FNumber_parser_)
            {
              this->FNumber_parser_->post_typeOfNonNegativeRealType ();
              this->FNumber ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ExposureTime" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ExposureTime_parser_;

            if (this->ExposureTime_parser_)
              this->ExposureTime_parser_->pre ();
          }
          else
          {
            if (this->ExposureTime_parser_)
            {
              this->ExposureTime_parser_->post_typeOfNonNegativeRealType ();
              this->ExposureTime ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "Brightness" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Brightness_parser_;

            if (this->Brightness_parser_)
              this->Brightness_parser_->pre ();
          }
          else
          {
            if (this->Brightness_parser_)
            {
              this->Brightness_parser_->post_typeOfNonNegativeRealType ();
              this->Brightness ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "ExposureBias" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ExposureBias_parser_;

            if (this->ExposureBias_parser_)
              this->ExposureBias_parser_->pre ();
          }
          else
          {
            if (this->ExposureBias_parser_)
            {
              this->ExposureBias_parser_->post_typeOfNonNegativeRealType ();
              this->ExposureBias ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "SubjectDistance" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SubjectDistance_parser_;

            if (this->SubjectDistance_parser_)
              this->SubjectDistance_parser_->pre ();
          }
          else
          {
            if (this->SubjectDistance_parser_)
            {
              this->SubjectDistance_parser_->post_typeOfSubjectDistanceType ();
              this->SubjectDistance ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "MeteringMode" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->MeteringMode_parser_;

            if (this->MeteringMode_parser_)
              this->MeteringMode_parser_->pre ();
          }
          else
          {
            if (this->MeteringMode_parser_)
            {
              this->MeteringMode_parser_->post_typeOfMeteringModeType ();
              this->MeteringMode ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "SceneIlluminant" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SceneIlluminant_parser_;

            if (this->SceneIlluminant_parser_)
              this->SceneIlluminant_parser_->pre ();
          }
          else
          {
            if (this->SceneIlluminant_parser_)
            {
              this->SceneIlluminant_parser_->post_typeOfSceneIlluminantType ();
              this->SceneIlluminant ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "ColorTemp" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorTemp_parser_;

            if (this->ColorTemp_parser_)
              this->ColorTemp_parser_->pre ();
          }
          else
          {
            if (this->ColorTemp_parser_)
            {
              this->ColorTemp_parser_->post_typeOfNonNegativeRealType ();
              this->ColorTemp ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "FocalLength" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FocalLength_parser_;

            if (this->FocalLength_parser_)
              this->FocalLength_parser_->pre ();
          }
          else
          {
            if (this->FocalLength_parser_)
            {
              this->FocalLength_parser_->post_typeOfNonNegativeRealType ();
              this->FocalLength ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "Flash" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Flash_parser_;

            if (this->Flash_parser_)
              this->Flash_parser_->pre ();
          }
          else
          {
            if (this->Flash_parser_)
            {
              this->Flash_parser_->post_typeOfFlashType ();
              this->Flash ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "FlashEnergy" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FlashEnergy_parser_;

            if (this->FlashEnergy_parser_)
              this->FlashEnergy_parser_->pre ();
          }
          else
          {
            if (this->FlashEnergy_parser_)
            {
              this->FlashEnergy_parser_->post_typeOfNonNegativeRealType ();
              this->FlashEnergy ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "FlashReturn" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->FlashReturn_parser_;

            if (this->FlashReturn_parser_)
              this->FlashReturn_parser_->pre ();
          }
          else
          {
            if (this->FlashReturn_parser_)
            {
              this->FlashReturn_parser_->post_typeOfFlashReturnType ();
              this->FlashReturn ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "BackLight" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->BackLight_parser_;

            if (this->BackLight_parser_)
              this->BackLight_parser_->pre ();
          }
          else
          {
            if (this->BackLight_parser_)
            {
              this->BackLight_parser_->post_typeOfBackLightType ();
              this->BackLight ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "ExposureIndex" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ExposureIndex_parser_;

            if (this->ExposureIndex_parser_)
              this->ExposureIndex_parser_->pre ();
          }
          else
          {
            if (this->ExposureIndex_parser_)
            {
              this->ExposureIndex_parser_->post_typeOfNonNegativeRealType ();
              this->ExposureIndex ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "AutoFocus" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->AutoFocus_parser_;

            if (this->AutoFocus_parser_)
              this->AutoFocus_parser_->pre ();
          }
          else
          {
            if (this->AutoFocus_parser_)
            {
              this->AutoFocus_parser_->post_typeOfAutoFocusType ();
              this->AutoFocus ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "PrintAspectRatio" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrintAspectRatio_parser_;

            if (this->PrintAspectRatio_parser_)
              this->PrintAspectRatio_parser_->pre ();
          }
          else
          {
            if (this->PrintAspectRatio_parser_)
            {
              this->PrintAspectRatio_parser_->post_PrintAspectRatio ();
              this->PrintAspectRatio ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SpatialMetrics_pskel.
  //
  bool SpatialMetrics_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "SamplingFrequencyPlane" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "SamplingFrequencyUnit" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "XSamplingFrequency" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "YSamplingFrequency" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "ImageWidth" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "ImageLength" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;
        else if (n == "Source_X" &&
                 ns == "http://www.loc.gov/mix/")
          s = 6UL;
        else if (n == "Source_Y" &&
                 ns == "http://www.loc.gov/mix/")
          s = 7UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SpatialMetrics_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SpatialMetrics_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SpatialMetrics_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void SpatialMetrics_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SpatialMetrics_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "SamplingFrequencyPlane" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SamplingFrequencyPlane_parser_;

            if (this->SamplingFrequencyPlane_parser_)
              this->SamplingFrequencyPlane_parser_->pre ();
          }
          else
          {
            if (this->SamplingFrequencyPlane_parser_)
            {
              this->SamplingFrequencyPlane_parser_->post_typeOfSamplingFrequencyPlaneType ();
              this->SamplingFrequencyPlane ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "SamplingFrequencyUnit" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SamplingFrequencyUnit_parser_;

            if (this->SamplingFrequencyUnit_parser_)
              this->SamplingFrequencyUnit_parser_->pre ();
          }
          else
          {
            if (this->SamplingFrequencyUnit_parser_)
            {
              this->SamplingFrequencyUnit_parser_->post_typeOfSamplingFrequencyUnitType ();
              this->SamplingFrequencyUnit ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "XSamplingFrequency" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->XSamplingFrequency_parser_;

            if (this->XSamplingFrequency_parser_)
              this->XSamplingFrequency_parser_->pre ();
          }
          else
          {
            if (this->XSamplingFrequency_parser_)
            {
              this->XSamplingFrequency_parser_->post_typeOfPositiveIntegerType ();
              this->XSamplingFrequency ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "YSamplingFrequency" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YSamplingFrequency_parser_;

            if (this->YSamplingFrequency_parser_)
              this->YSamplingFrequency_parser_->pre ();
          }
          else
          {
            if (this->YSamplingFrequency_parser_)
            {
              this->YSamplingFrequency_parser_->post_typeOfPositiveIntegerType ();
              this->YSamplingFrequency ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "ImageWidth" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageWidth_parser_;

            if (this->ImageWidth_parser_)
              this->ImageWidth_parser_->pre ();
          }
          else
          {
            if (this->ImageWidth_parser_)
            {
              this->ImageWidth_parser_->post_typeOfPositiveIntegerType ();
              this->ImageWidth ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "ImageLength" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageLength_parser_;

            if (this->ImageLength_parser_)
              this->ImageLength_parser_->pre ();
          }
          else
          {
            if (this->ImageLength_parser_)
            {
              this->ImageLength_parser_->post_typeOfPositiveIntegerType ();
              this->ImageLength ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "Source_X" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Source_X_parser_;

            if (this->Source_X_parser_)
              this->Source_X_parser_->pre ();
          }
          else
          {
            if (this->Source_X_parser_)
            {
              this->Source_X_parser_->post_Source_X ();
              this->Source_X ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "Source_Y" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Source_Y_parser_;

            if (this->Source_Y_parser_)
              this->Source_Y_parser_->pre ();
          }
          else
          {
            if (this->Source_Y_parser_)
            {
              this->Source_Y_parser_->post_Source_Y ();
              this->Source_Y ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Energetics_pskel.
  //
  bool Energetics_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "BitsPerSample" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "SamplesPerPixel" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ExtraSamples" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "Colormap" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "GrayResponse" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "WhitePoint" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;
        else if (n == "PrimaryChromaticities" &&
                 ns == "http://www.loc.gov/mix/")
          s = 6UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Energetics_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Energetics_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Energetics_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Energetics_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Energetics_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "BitsPerSample" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->BitsPerSample_parser_;

            if (this->BitsPerSample_parser_)
              this->BitsPerSample_parser_->pre ();
          }
          else
          {
            if (this->BitsPerSample_parser_)
            {
              this->BitsPerSample_parser_->post_typeOfBitsPerSampleType ();
              this->BitsPerSample ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "SamplesPerPixel" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SamplesPerPixel_parser_;

            if (this->SamplesPerPixel_parser_)
              this->SamplesPerPixel_parser_->pre ();
          }
          else
          {
            if (this->SamplesPerPixel_parser_)
            {
              this->SamplesPerPixel_parser_->post_typeOfSamplesPerPixelType ();
              this->SamplesPerPixel ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ExtraSamples" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ExtraSamples_parser_;

            if (this->ExtraSamples_parser_)
              this->ExtraSamples_parser_->pre ();
          }
          else
          {
            if (this->ExtraSamples_parser_)
            {
              this->ExtraSamples_parser_->post_typeOfExtraSamplesType ();
              this->ExtraSamples ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "Colormap" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Colormap_parser_;

            if (this->Colormap_parser_)
              this->Colormap_parser_->pre ();
          }
          else
          {
            if (this->Colormap_parser_)
            {
              this->Colormap_parser_->post_Colormap ();
              this->Colormap ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "GrayResponse" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->GrayResponse_parser_;

            if (this->GrayResponse_parser_)
              this->GrayResponse_parser_->pre ();
          }
          else
          {
            if (this->GrayResponse_parser_)
            {
              this->GrayResponse_parser_->post_GrayResponse ();
              this->GrayResponse ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "WhitePoint" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->WhitePoint_parser_;

            if (this->WhitePoint_parser_)
              this->WhitePoint_parser_->pre ();
          }
          else
          {
            if (this->WhitePoint_parser_)
            {
              this->WhitePoint_parser_->post_WhitePoint ();
              this->WhitePoint ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "PrimaryChromaticities" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_parser_;

            if (this->PrimaryChromaticities_parser_)
              this->PrimaryChromaticities_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_parser_)
            {
              this->PrimaryChromaticities_parser_->post_PrimaryChromaticities ();
              this->PrimaryChromaticities ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TargetData_pskel.
  //
  bool TargetData_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "TargetType" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "TargetID" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ImageData" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "PerformanceData" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "Profiles" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TargetData_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TargetData_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TargetData_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void TargetData_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void TargetData_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "TargetType" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetType_parser_;

            if (this->TargetType_parser_)
              this->TargetType_parser_->pre ();
          }
          else
          {
            if (this->TargetType_parser_)
            {
              this->TargetType_parser_->post_typeOfTargetTypeType ();
              this->TargetType ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "TargetID" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetID_parser_;

            if (this->TargetID_parser_)
              this->TargetID_parser_->pre ();
          }
          else
          {
            if (this->TargetID_parser_)
            {
              this->TargetID_parser_->post_TargetID ();
              this->TargetID ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ImageData" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ImageData_parser_;

            if (this->ImageData_parser_)
              this->ImageData_parser_->pre ();
          }
          else
          {
            if (this->ImageData_parser_)
            {
              this->ImageData_parser_->post_typeOfReferenceType ();
              this->ImageData ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "PerformanceData" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PerformanceData_parser_;

            if (this->PerformanceData_parser_)
              this->PerformanceData_parser_->pre ();
          }
          else
          {
            if (this->PerformanceData_parser_)
            {
              this->PerformanceData_parser_->post_typeOfReferenceType ();
              this->PerformanceData ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "Profiles" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Profiles_parser_;

            if (this->Profiles_parser_)
              this->Profiles_parser_->pre ();
          }
          else
          {
            if (this->Profiles_parser_)
            {
              this->Profiles_parser_->post_typeOfReferenceType ();
              this->Profiles ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ImageProcessing_pskel.
  //
  bool ImageProcessing_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "DateTimeProcessed" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "SourceData" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ProcessingAgency" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "ProcessingSoftware" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "ProcessingActions" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ImageProcessing_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ImageProcessing_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ImageProcessing_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ImageProcessing_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ImageProcessing_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "DateTimeProcessed" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->DateTimeProcessed_parser_;

            if (this->DateTimeProcessed_parser_)
              this->DateTimeProcessed_parser_->pre ();
          }
          else
          {
            if (this->DateTimeProcessed_parser_)
            {
              this->DateTimeProcessed_parser_->post_typeOfDateTimeType ();
              this->DateTimeProcessed ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "SourceData" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SourceData_parser_;

            if (this->SourceData_parser_)
              this->SourceData_parser_->pre ();
          }
          else
          {
            if (this->SourceData_parser_)
            {
              this->SourceData_parser_->post_typeOfReferenceType ();
              this->SourceData ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ProcessingAgency" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProcessingAgency_parser_;

            if (this->ProcessingAgency_parser_)
              this->ProcessingAgency_parser_->pre ();
          }
          else
          {
            if (this->ProcessingAgency_parser_)
            {
              this->ProcessingAgency_parser_->post_typeOfStringType ();
              this->ProcessingAgency ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "ProcessingSoftware" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProcessingSoftware_parser_;

            if (this->ProcessingSoftware_parser_)
              this->ProcessingSoftware_parser_->pre ();
          }
          else
          {
            if (this->ProcessingSoftware_parser_)
            {
              this->ProcessingSoftware_parser_->post_ProcessingSoftware ();
              this->ProcessingSoftware ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "ProcessingActions" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProcessingActions_parser_;

            if (this->ProcessingActions_parser_)
              this->ProcessingActions_parser_->pre ();
          }
          else
          {
            if (this->ProcessingActions_parser_)
            {
              this->ProcessingActions_parser_->post_typeOfStringType ();
              this->ProcessingActions ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Compression_pskel.
  //
  bool Compression_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "CompressionScheme" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "CompressionLevel" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Compression_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Compression_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Compression_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Compression_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Compression_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "CompressionScheme" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->CompressionScheme_parser_;

            if (this->CompressionScheme_parser_)
              this->CompressionScheme_parser_->pre ();
          }
          else
          {
            if (this->CompressionScheme_parser_)
            {
              this->CompressionScheme_parser_->post_typeOfCompressionSchemeType ();
              this->CompressionScheme ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "CompressionLevel" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->CompressionLevel_parser_;

            if (this->CompressionLevel_parser_)
              this->CompressionLevel_parser_->pre ();
          }
          else
          {
            if (this->CompressionLevel_parser_)
            {
              this->CompressionLevel_parser_->post_typeOfCompressionLevelType ();
              this->CompressionLevel ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PhotometricInterpretation_pskel.
  //
  bool PhotometricInterpretation_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ColorSpace" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ICCProfile" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "YCbCrSubSampling" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "YCbCrPositioning" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "YcbCrCoefficients" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "ReferenceBlackWhite" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &PhotometricInterpretation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PhotometricInterpretation_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PhotometricInterpretation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void PhotometricInterpretation_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PhotometricInterpretation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ColorSpace" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorSpace_parser_;

            if (this->ColorSpace_parser_)
              this->ColorSpace_parser_->pre ();
          }
          else
          {
            if (this->ColorSpace_parser_)
            {
              this->ColorSpace_parser_->post_typeOfColorSpaceType ();
              this->ColorSpace ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ICCProfile" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ICCProfile_parser_;

            if (this->ICCProfile_parser_)
              this->ICCProfile_parser_->pre ();
          }
          else
          {
            if (this->ICCProfile_parser_)
            {
              this->ICCProfile_parser_->post_ICCProfile ();
              this->ICCProfile ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "YCbCrSubSampling" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YCbCrSubSampling_parser_;

            if (this->YCbCrSubSampling_parser_)
              this->YCbCrSubSampling_parser_->pre ();
          }
          else
          {
            if (this->YCbCrSubSampling_parser_)
            {
              this->YCbCrSubSampling_parser_->post_typeOfYCbCrSubSamplingType ();
              this->YCbCrSubSampling ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "YCbCrPositioning" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YCbCrPositioning_parser_;

            if (this->YCbCrPositioning_parser_)
              this->YCbCrPositioning_parser_->pre ();
          }
          else
          {
            if (this->YCbCrPositioning_parser_)
            {
              this->YCbCrPositioning_parser_->post_typeOfYCbCrPositioningType ();
              this->YCbCrPositioning ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "YcbCrCoefficients" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YcbCrCoefficients_parser_;

            if (this->YcbCrCoefficients_parser_)
              this->YcbCrCoefficients_parser_->pre ();
          }
          else
          {
            if (this->YcbCrCoefficients_parser_)
            {
              this->YcbCrCoefficients_parser_->post_typeOfYcbCrCoefficientsType ();
              this->YcbCrCoefficients ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "ReferenceBlackWhite" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ReferenceBlackWhite_parser_;

            if (this->ReferenceBlackWhite_parser_)
              this->ReferenceBlackWhite_parser_->pre ();
          }
          else
          {
            if (this->ReferenceBlackWhite_parser_)
            {
              this->ReferenceBlackWhite_parser_->post_typeOfReferenceBlackWhiteType ();
              this->ReferenceBlackWhite ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Segments_pskel.
  //
  bool Segments_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "SegmentType" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "StripOffsets" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "RowsPerStrip" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "StripByteCounts" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "TileWidth" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "TileLength" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;
        else if (n == "TileOffsets" &&
                 ns == "http://www.loc.gov/mix/")
          s = 6UL;
        else if (n == "TileByteCounts" &&
                 ns == "http://www.loc.gov/mix/")
          s = 7UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Segments_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Segments_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Segments_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Segments_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Segments_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "SegmentType" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentType_parser_;

            if (this->SegmentType_parser_)
              this->SegmentType_parser_->pre ();
          }
          else
          {
            if (this->SegmentType_parser_)
            {
              this->SegmentType_parser_->post_typeOfSegmentTypeType ();
              this->SegmentType ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "StripOffsets" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->StripOffsets_parser_;

            if (this->StripOffsets_parser_)
              this->StripOffsets_parser_->pre ();
          }
          else
          {
            if (this->StripOffsets_parser_)
            {
              this->StripOffsets_parser_->post_typeOfStripOffsetsType ();
              this->StripOffsets ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "RowsPerStrip" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->RowsPerStrip_parser_;

            if (this->RowsPerStrip_parser_)
              this->RowsPerStrip_parser_->pre ();
          }
          else
          {
            if (this->RowsPerStrip_parser_)
            {
              this->RowsPerStrip_parser_->post_typeOfRowsPerStripType ();
              this->RowsPerStrip ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "StripByteCounts" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->StripByteCounts_parser_;

            if (this->StripByteCounts_parser_)
              this->StripByteCounts_parser_->pre ();
          }
          else
          {
            if (this->StripByteCounts_parser_)
            {
              this->StripByteCounts_parser_->post_typeOfStripByteCountsType ();
              this->StripByteCounts ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "TileWidth" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TileWidth_parser_;

            if (this->TileWidth_parser_)
              this->TileWidth_parser_->pre ();
          }
          else
          {
            if (this->TileWidth_parser_)
            {
              this->TileWidth_parser_->post_typeOfTileWidthType ();
              this->TileWidth ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "TileLength" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TileLength_parser_;

            if (this->TileLength_parser_)
              this->TileLength_parser_->pre ();
          }
          else
          {
            if (this->TileLength_parser_)
            {
              this->TileLength_parser_->post_typeOfTileLengthType ();
              this->TileLength ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "TileOffsets" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TileOffsets_parser_;

            if (this->TileOffsets_parser_)
              this->TileOffsets_parser_->pre ();
          }
          else
          {
            if (this->TileOffsets_parser_)
            {
              this->TileOffsets_parser_->post_typeOfTileOffsetsType ();
              this->TileOffsets ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "TileByteCounts" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TileByteCounts_parser_;

            if (this->TileByteCounts_parser_)
              this->TileByteCounts_parser_->pre ();
          }
          else
          {
            if (this->TileByteCounts_parser_)
            {
              this->TileByteCounts_parser_->post_typeOfTileByteCountsType ();
              this->TileByteCounts ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Checksum_pskel.
  //
  bool Checksum_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ChecksumMethod" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ChecksumValue" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Checksum_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Checksum_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Checksum_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Checksum_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Checksum_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ChecksumMethod" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ChecksumMethod_parser_;

            if (this->ChecksumMethod_parser_)
              this->ChecksumMethod_parser_->pre ();
          }
          else
          {
            if (this->ChecksumMethod_parser_)
            {
              this->ChecksumMethod_parser_->post_typeOfChecksumMethodType ();
              this->ChecksumMethod ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ChecksumValue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ChecksumValue_parser_;

            if (this->ChecksumValue_parser_)
              this->ChecksumValue_parser_->pre ();
          }
          else
          {
            if (this->ChecksumValue_parser_)
            {
              this->ChecksumValue_parser_->post_typeOfChecksumValueType ();
              this->ChecksumValue ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TargetedDisplayAR_pskel.
  //
  bool TargetedDisplayAR_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "XTargetedDisplayAR" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "YTargetedDisplayAR" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TargetedDisplayAR_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TargetedDisplayAR_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TargetedDisplayAR_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void TargetedDisplayAR_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void TargetedDisplayAR_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "XTargetedDisplayAR" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->XTargetedDisplayAR_parser_;

            if (this->XTargetedDisplayAR_parser_)
              this->XTargetedDisplayAR_parser_->pre ();
          }
          else
          {
            if (this->XTargetedDisplayAR_parser_)
            {
              this->XTargetedDisplayAR_parser_->post_typeOfXTargetedDisplayARType ();
              this->XTargetedDisplayAR ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "YTargetedDisplayAR" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YTargetedDisplayAR_parser_;

            if (this->YTargetedDisplayAR_parser_)
              this->YTargetedDisplayAR_parser_->pre ();
          }
          else
          {
            if (this->YTargetedDisplayAR_parser_)
            {
              this->YTargetedDisplayAR_parser_->post_typeOfYTargetedDisplayARType ();
              this->YTargetedDisplayAR ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ScanningSystemHardware_pskel.
  //
  bool ScanningSystemHardware_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ScannerManufacturer" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ScannerModel" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ScanningSystemHardware_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ScanningSystemHardware_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ScanningSystemHardware_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ScanningSystemHardware_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ScanningSystemHardware_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ScannerManufacturer" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScannerManufacturer_parser_;

            if (this->ScannerManufacturer_parser_)
              this->ScannerManufacturer_parser_->pre ();
          }
          else
          {
            if (this->ScannerManufacturer_parser_)
            {
              this->ScannerManufacturer_parser_->post_typeOfStringType ();
              this->ScannerManufacturer ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ScannerModel" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScannerModel_parser_;

            if (this->ScannerModel_parser_)
              this->ScannerModel_parser_->pre ();
          }
          else
          {
            if (this->ScannerModel_parser_)
            {
              this->ScannerModel_parser_->post_ScannerModel ();
              this->ScannerModel ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ScanningSystemSoftware_pskel.
  //
  bool ScanningSystemSoftware_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ScanningSoftware" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ScanningSoftwareVersionNo" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ScanningSystemSoftware_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ScanningSystemSoftware_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ScanningSystemSoftware_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ScanningSystemSoftware_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ScanningSystemSoftware_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ScanningSoftware" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScanningSoftware_parser_;

            if (this->ScanningSoftware_parser_)
              this->ScanningSoftware_parser_->pre ();
          }
          else
          {
            if (this->ScanningSoftware_parser_)
            {
              this->ScanningSoftware_parser_->post_typeOfStringType ();
              this->ScanningSoftware ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ScanningSoftwareVersionNo" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScanningSoftwareVersionNo_parser_;

            if (this->ScanningSoftwareVersionNo_parser_)
              this->ScanningSoftwareVersionNo_parser_->pre ();
          }
          else
          {
            if (this->ScanningSoftwareVersionNo_parser_)
            {
              this->ScanningSoftwareVersionNo_parser_->post_typeOfStringType ();
              this->ScanningSoftwareVersionNo ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ScannerCaptureSettings_pskel.
  //
  bool ScannerCaptureSettings_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "PixelSize" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "PhysScanResolution" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ScannerCaptureSettings_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ScannerCaptureSettings_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ScannerCaptureSettings_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ScannerCaptureSettings_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ScannerCaptureSettings_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "PixelSize" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PixelSize_parser_;

            if (this->PixelSize_parser_)
              this->PixelSize_parser_->pre ();
          }
          else
          {
            if (this->PixelSize_parser_)
            {
              this->PixelSize_parser_->post_typeOfNonNegativeRealType ();
              this->PixelSize ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "PhysScanResolution" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PhysScanResolution_parser_;

            if (this->PhysScanResolution_parser_)
              this->PhysScanResolution_parser_->pre ();
          }
          else
          {
            if (this->PhysScanResolution_parser_)
            {
              this->PhysScanResolution_parser_->post_PhysScanResolution ();
              this->PhysScanResolution ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PrintAspectRatio_pskel.
  //
  bool PrintAspectRatio_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "XPrintAspectRatio" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "YPrintAspectRatio" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &PrintAspectRatio_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PrintAspectRatio_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PrintAspectRatio_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void PrintAspectRatio_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PrintAspectRatio_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "XPrintAspectRatio" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->XPrintAspectRatio_parser_;

            if (this->XPrintAspectRatio_parser_)
              this->XPrintAspectRatio_parser_->pre ();
          }
          else
          {
            if (this->XPrintAspectRatio_parser_)
            {
              this->XPrintAspectRatio_parser_->post_typeOfNonNegativeRealType ();
              this->XPrintAspectRatio ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "YPrintAspectRatio" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YPrintAspectRatio_parser_;

            if (this->YPrintAspectRatio_parser_)
              this->YPrintAspectRatio_parser_->pre ();
          }
          else
          {
            if (this->YPrintAspectRatio_parser_)
            {
              this->YPrintAspectRatio_parser_->post_typeOfNonNegativeRealType ();
              this->YPrintAspectRatio ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Source_X_pskel.
  //
  bool Source_X_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Source_Xdimension" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "Source_XdimensionUnit" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Source_X_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Source_X_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Source_X_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Source_X_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Source_X_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Source_Xdimension" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Source_Xdimension_parser_;

            if (this->Source_Xdimension_parser_)
              this->Source_Xdimension_parser_->pre ();
          }
          else
          {
            if (this->Source_Xdimension_parser_)
            {
              this->Source_Xdimension_parser_->post_typeOfNonNegativeRealType ();
              this->Source_Xdimension ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "Source_XdimensionUnit" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Source_XdimensionUnit_parser_;

            if (this->Source_XdimensionUnit_parser_)
              this->Source_XdimensionUnit_parser_->pre ();
          }
          else
          {
            if (this->Source_XdimensionUnit_parser_)
            {
              this->Source_XdimensionUnit_parser_->post_typeOfStringType ();
              this->Source_XdimensionUnit ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Source_Y_pskel.
  //
  bool Source_Y_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Source_Ydimension" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "Source_YdimensionUnit" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Source_Y_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Source_Y_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Source_Y_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Source_Y_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Source_Y_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Source_Ydimension" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Source_Ydimension_parser_;

            if (this->Source_Ydimension_parser_)
              this->Source_Ydimension_parser_->pre ();
          }
          else
          {
            if (this->Source_Ydimension_parser_)
            {
              this->Source_Ydimension_parser_->post_typeOfNonNegativeRealType ();
              this->Source_Ydimension ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "Source_YdimensionUnit" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Source_YdimensionUnit_parser_;

            if (this->Source_YdimensionUnit_parser_)
              this->Source_YdimensionUnit_parser_->pre ();
          }
          else
          {
            if (this->Source_YdimensionUnit_parser_)
            {
              this->Source_YdimensionUnit_parser_->post_typeOfStringType ();
              this->Source_YdimensionUnit ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Colormap_pskel.
  //
  bool Colormap_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Colormap_BitCodeValue" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "Colormap_RedValue" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "Colormap_GreenValue" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "Colormap_BlueValue" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Colormap_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Colormap_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Colormap_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Colormap_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Colormap_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Colormap_BitCodeValue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Colormap_BitCodeValue_parser_;

            if (this->Colormap_BitCodeValue_parser_)
              this->Colormap_BitCodeValue_parser_->pre ();
          }
          else
          {
            if (this->Colormap_BitCodeValue_parser_)
            {
              this->Colormap_BitCodeValue_parser_->post_typeOfColormapType ();
              this->Colormap_BitCodeValue ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "Colormap_RedValue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Colormap_RedValue_parser_;

            if (this->Colormap_RedValue_parser_)
              this->Colormap_RedValue_parser_->pre ();
          }
          else
          {
            if (this->Colormap_RedValue_parser_)
            {
              this->Colormap_RedValue_parser_->post_typeOfColormapType ();
              this->Colormap_RedValue ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "Colormap_GreenValue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Colormap_GreenValue_parser_;

            if (this->Colormap_GreenValue_parser_)
              this->Colormap_GreenValue_parser_->pre ();
          }
          else
          {
            if (this->Colormap_GreenValue_parser_)
            {
              this->Colormap_GreenValue_parser_->post_typeOfColormapType ();
              this->Colormap_GreenValue ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "Colormap_BlueValue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->Colormap_BlueValue_parser_;

            if (this->Colormap_BlueValue_parser_)
              this->Colormap_BlueValue_parser_->pre ();
          }
          else
          {
            if (this->Colormap_BlueValue_parser_)
            {
              this->Colormap_BlueValue_parser_->post_typeOfColormapType ();
              this->Colormap_BlueValue ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for GrayResponse_pskel.
  //
  bool GrayResponse_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "GrayResponseCurve" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "GrayResponseUnit" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &GrayResponse_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool GrayResponse_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void GrayResponse_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void GrayResponse_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void GrayResponse_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "GrayResponseCurve" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->GrayResponseCurve_parser_;

            if (this->GrayResponseCurve_parser_)
              this->GrayResponseCurve_parser_->pre ();
          }
          else
          {
            if (this->GrayResponseCurve_parser_)
            {
              this->GrayResponseCurve_parser_->post_typeOfGrayResponseCurveType ();
              this->GrayResponseCurve ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "GrayResponseUnit" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->GrayResponseUnit_parser_;

            if (this->GrayResponseUnit_parser_)
              this->GrayResponseUnit_parser_->pre ();
          }
          else
          {
            if (this->GrayResponseUnit_parser_)
            {
              this->GrayResponseUnit_parser_->post_typeOfGrayResponseUnitType ();
              this->GrayResponseUnit ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for WhitePoint_pskel.
  //
  bool WhitePoint_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "WhitePoint_Xvalue" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "WhitePoint_Yvalue" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &WhitePoint_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool WhitePoint_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void WhitePoint_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void WhitePoint_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void WhitePoint_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "WhitePoint_Xvalue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->WhitePoint_Xvalue_parser_;

            if (this->WhitePoint_Xvalue_parser_)
              this->WhitePoint_Xvalue_parser_->pre ();
          }
          else
          {
            if (this->WhitePoint_Xvalue_parser_)
            {
              this->WhitePoint_Xvalue_parser_->post_typeOfCIExyType ();
              this->WhitePoint_Xvalue ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "WhitePoint_Yvalue" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->WhitePoint_Yvalue_parser_;

            if (this->WhitePoint_Yvalue_parser_)
              this->WhitePoint_Yvalue_parser_->pre ();
          }
          else
          {
            if (this->WhitePoint_Yvalue_parser_)
            {
              this->WhitePoint_Yvalue_parser_->post_typeOfCIExyType ();
              this->WhitePoint_Yvalue ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PrimaryChromaticities_pskel.
  //
  bool PrimaryChromaticities_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "PrimaryChromaticities_RedX" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "PrimaryChromaticities_RedY" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "PrimaryChromaticities_GreenX" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "PrimaryChromaticities_GreenY" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;
        else if (n == "PrimaryChromaticities_BlueX" &&
                 ns == "http://www.loc.gov/mix/")
          s = 4UL;
        else if (n == "PrimaryChromaticities_BlueY" &&
                 ns == "http://www.loc.gov/mix/")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &PrimaryChromaticities_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PrimaryChromaticities_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PrimaryChromaticities_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void PrimaryChromaticities_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PrimaryChromaticities_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "PrimaryChromaticities_RedX" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_RedX_parser_;

            if (this->PrimaryChromaticities_RedX_parser_)
              this->PrimaryChromaticities_RedX_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_RedX_parser_)
            {
              this->PrimaryChromaticities_RedX_parser_->post_typeOfCIExyType ();
              this->PrimaryChromaticities_RedX ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "PrimaryChromaticities_RedY" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_RedY_parser_;

            if (this->PrimaryChromaticities_RedY_parser_)
              this->PrimaryChromaticities_RedY_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_RedY_parser_)
            {
              this->PrimaryChromaticities_RedY_parser_->post_typeOfCIExyType ();
              this->PrimaryChromaticities_RedY ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "PrimaryChromaticities_GreenX" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_GreenX_parser_;

            if (this->PrimaryChromaticities_GreenX_parser_)
              this->PrimaryChromaticities_GreenX_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_GreenX_parser_)
            {
              this->PrimaryChromaticities_GreenX_parser_->post_typeOfCIExyType ();
              this->PrimaryChromaticities_GreenX ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "PrimaryChromaticities_GreenY" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_GreenY_parser_;

            if (this->PrimaryChromaticities_GreenY_parser_)
              this->PrimaryChromaticities_GreenY_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_GreenY_parser_)
            {
              this->PrimaryChromaticities_GreenY_parser_->post_typeOfCIExyType ();
              this->PrimaryChromaticities_GreenY ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "PrimaryChromaticities_BlueX" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_BlueX_parser_;

            if (this->PrimaryChromaticities_BlueX_parser_)
              this->PrimaryChromaticities_BlueX_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_BlueX_parser_)
            {
              this->PrimaryChromaticities_BlueX_parser_->post_typeOfCIExyType ();
              this->PrimaryChromaticities_BlueX ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "PrimaryChromaticities_BlueY" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->PrimaryChromaticities_BlueY_parser_;

            if (this->PrimaryChromaticities_BlueY_parser_)
              this->PrimaryChromaticities_BlueY_parser_->pre ();
          }
          else
          {
            if (this->PrimaryChromaticities_BlueY_parser_)
            {
              this->PrimaryChromaticities_BlueY_parser_->post_typeOfCIExyType ();
              this->PrimaryChromaticities_BlueY ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TargetID_pskel.
  //
  bool TargetID_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "TargetIDManufacturer" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "TargetIDName" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "TargetIDNo" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;
        else if (n == "TargetIDMedia" &&
                 ns == "http://www.loc.gov/mix/")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TargetID_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TargetID_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TargetID_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void TargetID_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void TargetID_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "TargetIDManufacturer" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetIDManufacturer_parser_;

            if (this->TargetIDManufacturer_parser_)
              this->TargetIDManufacturer_parser_->pre ();
          }
          else
          {
            if (this->TargetIDManufacturer_parser_)
            {
              this->TargetIDManufacturer_parser_->post_typeOfStringType ();
              this->TargetIDManufacturer ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "TargetIDName" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetIDName_parser_;

            if (this->TargetIDName_parser_)
              this->TargetIDName_parser_->pre ();
          }
          else
          {
            if (this->TargetIDName_parser_)
            {
              this->TargetIDName_parser_->post_typeOfStringType ();
              this->TargetIDName ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "TargetIDNo" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetIDNo_parser_;

            if (this->TargetIDNo_parser_)
              this->TargetIDNo_parser_->pre ();
          }
          else
          {
            if (this->TargetIDNo_parser_)
            {
              this->TargetIDNo_parser_->post_typeOfStringType ();
              this->TargetIDNo ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "TargetIDMedia" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->TargetIDMedia_parser_;

            if (this->TargetIDMedia_parser_)
              this->TargetIDMedia_parser_->pre ();
          }
          else
          {
            if (this->TargetIDMedia_parser_)
            {
              this->TargetIDMedia_parser_->post_typeOfStringType ();
              this->TargetIDMedia ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ProcessingSoftware_pskel.
  //
  bool ProcessingSoftware_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ProcessingSoftwareName" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ProcessingSoftwareVersion" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ProcessingSoftware_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ProcessingSoftware_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ProcessingSoftware_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ProcessingSoftware_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ProcessingSoftware_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ProcessingSoftwareName" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProcessingSoftwareName_parser_;

            if (this->ProcessingSoftwareName_parser_)
              this->ProcessingSoftwareName_parser_->pre ();
          }
          else
          {
            if (this->ProcessingSoftwareName_parser_)
            {
              this->ProcessingSoftwareName_parser_->post_typeOfStringType ();
              this->ProcessingSoftwareName ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ProcessingSoftwareVersion" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProcessingSoftwareVersion_parser_;

            if (this->ProcessingSoftwareVersion_parser_)
              this->ProcessingSoftwareVersion_parser_->pre ();
          }
          else
          {
            if (this->ProcessingSoftwareVersion_parser_)
            {
              this->ProcessingSoftwareVersion_parser_->post_typeOfStringType ();
              this->ProcessingSoftwareVersion ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ICCProfile_pskel.
  //
  bool ICCProfile_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ProfileName" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ProfileURL" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ICCProfile_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ICCProfile_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ICCProfile_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ICCProfile_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ICCProfile_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ProfileName" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProfileName_parser_;

            if (this->ProfileName_parser_)
              this->ProfileName_parser_->pre ();
          }
          else
          {
            if (this->ProfileName_parser_)
            {
              this->ProfileName_parser_->post_typeOfStringType ();
              this->ProfileName ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ProfileURL" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ProfileURL_parser_;

            if (this->ProfileURL_parser_)
              this->ProfileURL_parser_->pre ();
          }
          else
          {
            if (this->ProfileURL_parser_)
            {
              this->ProfileURL_parser_->post_typeOfStringType ();
              this->ProfileURL ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ScannerModel_pskel.
  //
  bool ScannerModel_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ScannerModelName" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "ScannerModelNumber" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;
        else if (n == "ScannerModelSerialNo" &&
                 ns == "http://www.loc.gov/mix/")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ScannerModel_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ScannerModel_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ScannerModel_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ScannerModel_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ScannerModel_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ScannerModelName" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScannerModelName_parser_;

            if (this->ScannerModelName_parser_)
              this->ScannerModelName_parser_->pre ();
          }
          else
          {
            if (this->ScannerModelName_parser_)
            {
              this->ScannerModelName_parser_->post_typeOfStringType ();
              this->ScannerModelName ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ScannerModelNumber" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScannerModelNumber_parser_;

            if (this->ScannerModelNumber_parser_)
              this->ScannerModelNumber_parser_->pre ();
          }
          else
          {
            if (this->ScannerModelNumber_parser_)
            {
              this->ScannerModelNumber_parser_->post_typeOfStringType ();
              this->ScannerModelNumber ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ScannerModelSerialNo" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->ScannerModelSerialNo_parser_;

            if (this->ScannerModelSerialNo_parser_)
              this->ScannerModelSerialNo_parser_->pre ();
          }
          else
          {
            if (this->ScannerModelSerialNo_parser_)
            {
              this->ScannerModelSerialNo_parser_->post_typeOfStringType ();
              this->ScannerModelSerialNo ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PhysScanResolution_pskel.
  //
  bool PhysScanResolution_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "XphysScanResolution" &&
            ns == "http://www.loc.gov/mix/")
          s = 0UL;
        else if (n == "YphysScanResolution" &&
                 ns == "http://www.loc.gov/mix/")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &PhysScanResolution_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PhysScanResolution_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PhysScanResolution_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void PhysScanResolution_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PhysScanResolution_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "XphysScanResolution" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->XphysScanResolution_parser_;

            if (this->XphysScanResolution_parser_)
              this->XphysScanResolution_parser_->pre ();
          }
          else
          {
            if (this->XphysScanResolution_parser_)
            {
              this->XphysScanResolution_parser_->post_typeOfNonNegativeRealType ();
              this->XphysScanResolution ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "YphysScanResolution" &&
            ns == "http://www.loc.gov/mix/")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->YphysScanResolution_parser_;

            if (this->YphysScanResolution_parser_)
              this->YphysScanResolution_parser_->pre ();
          }
          else
          {
            if (this->YphysScanResolution_parser_)
            {
              this->YphysScanResolution_parser_->post_typeOfNonNegativeRealType ();
              this->YphysScanResolution ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace mix
{
  // Attribute validation and dispatch functions for typeOfFormatType_pskel.
  //
  bool typeOfFormatType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::FormatType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfByteOrderType_pskel.
  //
  bool typeOfByteOrderType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ByteOrderType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfCompressionSchemeType_pskel.
  //
  bool typeOfCompressionSchemeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::CompressionSchemeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfCompressionLevelType_pskel.
  //
  bool typeOfCompressionLevelType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::CompressionLevelType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfColorSpaceType_pskel.
  //
  bool typeOfColorSpaceType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ColorSpaceType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfProfileNameType_pskel.
  //
  bool typeOfProfileNameType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfProfileURLType_pskel.
  //
  bool typeOfProfileURLType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfYCbCrSubSamplingType_pskel.
  //
  bool typeOfYCbCrSubSamplingType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::YCbCrSubSamplingType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfYCbCrPositioningType_pskel.
  //
  bool typeOfYCbCrPositioningType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::YCbCrPositioningType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfYcbCrCoefficientsType_pskel.
  //
  bool typeOfYcbCrCoefficientsType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::YcbCrCoefficientsType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfReferenceBlackWhiteType_pskel.
  //
  bool typeOfReferenceBlackWhiteType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ReferenceBlackWhiteType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSegmentTypeType_pskel.
  //
  bool typeOfSegmentTypeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SegmentTypeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfStripOffsetsType_pskel.
  //
  bool typeOfStripOffsetsType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::StripOffsetsType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfRowsPerStripType_pskel.
  //
  bool typeOfRowsPerStripType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::RowsPerStripType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfStripByteCountsType_pskel.
  //
  bool typeOfStripByteCountsType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::StripByteCountsType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfTileWidthType_pskel.
  //
  bool typeOfTileWidthType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::TileWidthType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfTileLengthType_pskel.
  //
  bool typeOfTileLengthType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::TileLengthType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfTileOffsetsType_pskel.
  //
  bool typeOfTileOffsetsType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::TileOffsetsType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfTileByteCountsType_pskel.
  //
  bool typeOfTileByteCountsType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::TileByteCountsType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfPlanarConfigurationType_pskel.
  //
  bool typeOfPlanarConfigurationType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::PlanarConfigurationType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfImageIdentifierType_pskel.
  //
  bool typeOfImageIdentifierType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    if (n == "imageIdentifierLocation" && ns.empty ())
    {
      if (this->imageIdentifierLocation_parser_)
      {
        this->imageIdentifierLocation_parser_->pre ();
        this->imageIdentifierLocation_parser_->_pre_impl ();
        this->imageIdentifierLocation_parser_->_characters (s);
        this->imageIdentifierLocation_parser_->_post_impl ();
        this->imageIdentifierLocation_parser_->post_any_simple_type ();
        this->imageIdentifierLocation ();
      }

      return true;
    }

    return this->::mix::ImageIdentifierType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfFileSizeType_pskel.
  //
  bool typeOfFileSizeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::FileSizeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfChecksumMethodType_pskel.
  //
  bool typeOfChecksumMethodType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ChecksumMethodType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfChecksumValueType_pskel.
  //
  bool typeOfChecksumValueType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ChecksumValueType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfOrientationType_pskel.
  //
  bool typeOfOrientationType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::OrientationType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfDisplayOrientationType_pskel.
  //
  bool typeOfDisplayOrientationType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::DisplayOrientationType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfXTargetedDisplayARType_pskel.
  //
  bool typeOfXTargetedDisplayARType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::XTargetedDisplayARType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfYTargetedDisplayARType_pskel.
  //
  bool typeOfYTargetedDisplayARType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::YTargetedDisplayARType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfPreferredPresentationType_pskel.
  //
  bool typeOfPreferredPresentationType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::PreferredPresentationType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSourceTypeType_pskel.
  //
  bool typeOfSourceTypeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SourceTypeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSourceIDType_pskel.
  //
  bool typeOfSourceIDType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SourceIDType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfImageProducerType_pskel.
  //
  bool typeOfImageProducerType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ImageProducerType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSubjectDistanceType_pskel.
  //
  bool typeOfSubjectDistanceType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    if (n == "min" && ns.empty ())
    {
      if (this->min_parser_)
      {
        this->min_parser_->pre ();
        this->min_parser_->_pre_impl ();
        this->min_parser_->_characters (s);
        this->min_parser_->_post_impl ();
        this->min_parser_->post_any_simple_type ();
        this->min ();
      }

      return true;
    }

    if (n == "max" && ns.empty ())
    {
      if (this->max_parser_)
      {
        this->max_parser_->pre ();
        this->max_parser_->_pre_impl ();
        this->max_parser_->_characters (s);
        this->max_parser_->_post_impl ();
        this->max_parser_->post_any_simple_type ();
        this->max ();
      }

      return true;
    }

    return this->::mix::SubjectDistanceType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfMeteringModeType_pskel.
  //
  bool typeOfMeteringModeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::MeteringModeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSceneIlluminantType_pskel.
  //
  bool typeOfSceneIlluminantType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SceneIlluminantType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfFlashType_pskel.
  //
  bool typeOfFlashType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::FlashType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfFlashReturnType_pskel.
  //
  bool typeOfFlashReturnType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::FlashReturnType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfBackLightType_pskel.
  //
  bool typeOfBackLightType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::BackLightType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfAutoFocusType_pskel.
  //
  bool typeOfAutoFocusType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::AutoFocusType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSensorType_pskel.
  //
  bool typeOfSensorType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SensorType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSamplingFrequencyPlaneType_pskel.
  //
  bool typeOfSamplingFrequencyPlaneType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SamplingFrequencyPlaneType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSamplingFrequencyUnitType_pskel.
  //
  bool typeOfSamplingFrequencyUnitType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SamplingFrequencyUnitType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfBitsPerSampleType_pskel.
  //
  bool typeOfBitsPerSampleType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::BitsPerSampleType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfSamplesPerPixelType_pskel.
  //
  bool typeOfSamplesPerPixelType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::SamplesPerPixelType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfExtraSamplesType_pskel.
  //
  bool typeOfExtraSamplesType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ExtraSamplesType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfColormapType_pskel.
  //
  bool typeOfColormapType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ColormapType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfGrayResponseCurveType_pskel.
  //
  bool typeOfGrayResponseCurveType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::GrayResponseCurveType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfGrayResponseUnitType_pskel.
  //
  bool typeOfGrayResponseUnitType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::GrayResponseUnitType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfCIExyType_pskel.
  //
  bool typeOfCIExyType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::CIExyType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfTargetTypeType_pskel.
  //
  bool typeOfTargetTypeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::TargetTypeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfStringType_pskel.
  //
  bool typeOfStringType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::StringType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfNonNegativeRealType_pskel.
  //
  bool typeOfNonNegativeRealType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::NonNegativeRealType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfPositiveIntegerType_pskel.
  //
  bool typeOfPositiveIntegerType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::PositiveIntegerType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfDateTimeType_pskel.
  //
  bool typeOfDateTimeType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::DateTimeType_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for typeOfReferenceType_pskel.
  //
  bool typeOfReferenceType_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "use" && ns.empty ())
    {
      if (this->use_parser_)
      {
        this->use_parser_->pre ();
        this->use_parser_->_pre_impl ();
        this->use_parser_->_characters (s);
        this->use_parser_->_post_impl ();
        this->use_parser_->post_any_simple_type ();
        this->use ();
      }

      return true;
    }

    return this->::mix::ReferenceType_pskel::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace mix
{
}

// Begin epilogue.
//
//
// End epilogue.

